\chapter{The Monero Blockchain}
\label{chapter:blockchain}

The Internet Age has brought a new dimension to the human experience. We can correspond with people on every corner of the planet, and an unimaginable wealth of information is at our fingertips. Exchanging goods and services is fundamental to a peaceful and prosperous society, and in the digital realm we can offer our productivity to the whole world.

Media of exchange (moneys) are essential, giving us a point of reference to an immense diversity of economic goods that would otherwise be impossible to evaluate, and enabling mutually beneficial interactions between people with nothing in common. Throughout history there have been many kinds of money, from sea shells to paper to gold. Those were exchanged by hand, and now money can be exchanged electronically.

In the current, by far most pervasive, model, electronic transactions are handled by third party financial institutions. These institutions are given custody of money and trusted to transfer it upon request. Such institutions must mediate disputes, their payments are reversible, and they can be censored or controlled by powerful organizations. \cite{Nakamoto_bitcoin}

It seems appropriate for the Internet Age to have its own unique currencies.

Note: this chapter includes more implementation details than previous chapters, as a blockchain's nature depends heavily on its parameters and specific structure.



\section{Digital currency}
\label{sec:digital-currency}

Let's try to make a digital currency from scratch.

Suppose two pals Jim and Dwight need a currency for their Secret Society of Stealthy Sleuths. Jim sends an email to Dwight saying ``As co-founder, I hereby conjure 5 Stealthbucks for myself and 5 Stealthbucks for you." Later that day Dwight discovers Kevin had made 69 Stealthbucks for himself and used them to buy Dwight's bobblehead from Jim. There should only be 10 Stealthbucks, what went wrong?

In the \textbf{email model} anyone can make Stealthbucks, and anyone can send their Stealthbucks over and over. It does not have a limited supply, nor is it `double spend proof'.

Jim proposes a new system, Stealthbucks 2.0, where he keeps a record on his computer of who owns all the Stealthbucks. To exchange them, people need to talk to Jim. Since Jim is the sole custodian, there is no question the Stealthbucks on Kevin's computer are bogus. Jim promises Dwight they will start off with 100 Stealthbucks each and that's it - no more. Dwight tries to buy his bobblehead back and Jim says ``You need to prove your identity!" What went wrong?

In the \textbf{video game model}, where the entire currency is stored on one central database, users rely on the custodian to be honest. The currency's supply is unverifiable for observers, and the custodian can change the rules at any time, or be censored by powerful outsiders.


\subsection{Shared version of events}
\label{subsec:shared-version-events}

Since Jim can't be trusted to manage Stealthbucks, Dwight suggests setting up a bunch of computers that each have a record of every Stealthbuck transaction. When a new transaction is made on one computer, it is broadcast to the other computers, which only accept it if it follows the rules.

\begin{itemize}
    \item[] \textbf{Rule 1}: Money can only be created in clearly defined scenarios.
    \item[] \textbf{Rule 2}: Transactions spend money that already exists.
    \item[] \textbf{Rule 3}: Transactions output money equal to the money spent.
    \item[] \textbf{Rule 4}: Transactions are formatted correctly.
    \item[] \textbf{Rule 5}: Only the person who owns a piece of money can spend it.
    \item[] \textbf{Rule 6}: A person can only spend a piece of money once.
\end{itemize}

Rules 2-6 are already covered by the transaction schemes discussed in Chapter \ref{chapter:transactions}, which add the benefits of ambiguous signing, anonymous receipt of funds, and unreadable amount transfers. We explain Rule 1 later in this chapter.

What if one of the computers goes rogue and starts making a bunch of Stealthbucks for itself? Users only benefit from Stealthbucks when other users accept it in exchange, so no one will accept transactions spending counterfeit Stealthbucks if they expect {\em other} users only want legitimate coins. Each user must act honestly and follow the same rules as everyone else if they want to spend their money. We call this situation a `social minima', `Schelling point', or `social contract'.\\


Simply storing all transactions has a problem. If two computers receive legitimate transactions spending the same money, before they have a chance to send the information to each other, how do they decide which is correct? There is a `fork' in the currency, because two different copies that follow the same rules exist.

It seems obvious the earliest legitimate transaction spending a piece of money should be canonical. This is easier said than done. As we will see, obtaining consensus for transaction histories constitutes the raison d'\^{e}tre of blockchain technology.


\subsection{Simple blockchain}
\label{subsec:simple-blockchain}

First we need all of the computers, henceforth referred to as {\em nodes}, to agree on the order of transactions.

Let's say Stealthbucks started with a `genesis' declaration by Jim and Dwight: ``Let the Stealthbucks begin!". We call this message a `block', and its block hash is \vspace{.2cm}
\[ \mathit{BH}_G = \mathcal{H}(\textrm{Let the Stealthbucks begin!}) \]

Every time a node receives some transactions, they use those transactions' hashes, $\mathit{TH}$, as messages, along with the previous block's hash, and compute new block hashes\vspace{.2cm}
\[ \mathit{BH}_1 = \mathcal{H}(\mathit{BH}_G, \mathit{TH}_1, \mathit{TH}_2,...) \]
\[ \mathit{BH}_2 = \mathcal{H}(\mathit{BH}_1, \mathit{TH}_1, \mathit{TH}_2,...) \]

And so on, publishing each new block of messages as it's made. Each new block references the previous, most recently published block. In this way a clear order of events extends all the way back to the genesis message. We have a chain of blocks: a very simple `blockchain'.\footnote{A blockchain is technically a `directed acyclic graph' (DAG), with Bitcoin-style blockchains a one-dimensional variant. DAGs contain a finite number of nodes and one-directional edges (vectors) connecting nodes. If you start at one node, you will never loop back to it no matter what path you take. \cite{DAG-wikipedia}}

Nodes can include a timestamp in their blocks to aid record keeping. If most nodes are honest with timestamps then the blockchain provides a decent picture of when each transaction was recorded.

What if different transactions spending the same money are added to blocks referencing the same previous block, which are published at the same time? The network of nodes will fork again, as each node receives one of the new blocks before the other (for simplicity, imagine about half the nodes have each side of the fork). Let's keep improving our blockchain.


\section{Difficulty}
\label{sec:difficulty}

If nodes can publish new blocks whenever they want, the network will tend to fracture and diverge into many different, equally legitimate, chains. Say it takes 30 seconds to make sure everyone in the network gets a new block. What if transactions are made every 31 seconds? New blocks would just barely make it everywhere before another one gets sent out. 

Now what if new blocks are every 15 seconds, 10 seconds, etc? Since message transmission time is a function of distance, the network would fracture into small clumps circumscribed by the time it takes for a new block to propagate before a new one is produced.

We can avoid this by controlling how fast the entire network makes new blocks. If the time it takes to make a new block is much higher than the time for the previous block to reach every node, the network will tend to remain intact.


\subsection{Mining a block}

The output of a cryptographic hash function is uniformly distributed. This means, for any given input, its hash is equally likely to be every single possible output. Furthermore, it takes a certain amount of time to compute a single hash.

Let's imagine a hash function $\mathcal{H}_i(x)$ which outputs a number from 1 to 100: $\mathcal{H}_i(x) \in^D_R \{1,...,100\}$. We use $\in^D_R$ to say the output is deterministically random. Given some $x$, $\mathcal{H}_i(x)$ selects the same `random' number from \{1,...,100\} every time you calculate it. It takes 1 minute to calculate $\mathcal{H}_i(x)$. 

Say we are given a message $\mathfrak{m}$ and so-called `nonce' $n = 1$, and told to find an $n$ such that $\mathcal{H}_i(\mathfrak{m},n)$ outputs a number less than or equal to the {\em target} $t = 10$ (i.e. $\mathcal{H}_i(\mathfrak{m},n) \in \{1,...,10\}$). Guessing and checking by incrementing $n$ for each new hash, how many hashes will it probably take?

It should be around 10 hashes, for 10 minutes of hashing, because there is only a $1/10$\nth chance any given input will output a good answer. This isn't to say $n = 10$ is the right answer, just that if we take a lot of messages and do this process for each one, $n = 10$ will be the {\em average} value.

We call searching for a useful nonce {\em mining}, and publishing the message with its nonce is a {\em proof of work} because it proves we looked for a useful nonce (even if we were lucky and it needed just one hash to find), which anyone can verify by computing $\mathcal{H}_i(\mathfrak{m},n)$.

Now\marginnote{src/crypto- note\_basic/ difficulty.cpp check\_hash()} say we have a hash function for generating proofs of work, $\mathcal{H}_{PoW} \in^D_R \{0,...,m\}$, where $m$ is its maximum possible output. Given a message $\mathfrak{m}$ (a block of information), a nonce $n$ to mine, and a target $t$, we can define the {\em difficulty} $d$, or expected number of hashes, like this: $d = m/t$. If $\mathcal{H}_{PoW}(\mathfrak{m},n)*d \leq m$, then $n$ is accepted.

As the target gets smaller, the difficulty rises and it takes a computer more and more hashes, and therefore longer and longer periods of time, to find useful nonces.


\subsection{Mining speed}

Assume all nodes are mining nonces at the same time, but quit on their `current' block when they receive a new one from the network. They immediately start mining a fresh block that references the new one.

Suppose we collect a bunch $b$ of blocks from the blockchain (say, with index $u \in \{1,...,b\}$) which each had a difficulty $d_u$. For now, assume the nodes who mined them were honest, so each block timestamp ${TS}_u$ is accurate. The total time between the earliest block and most recent block is $\mathit{totalTime} = {TS}_b - {TS}_1$. The approximate number of hashes to mine all the blocks is $\mathit{totalDifficulty} = \sum_u d_u$.

Now we can guess how fast the network, with all its nodes, can compute hashes. If the actual speed didn't change much while the bunch of blocks was being produced, it should be effectively\footnote{If node 1 tries nonce $n = 23$ and later node 2 also tries $n = 23$, node 2's effort is wasted because the network already `knows' $n = 23$ doesn't work (otherwise node 1 would have published that block). The network's {\em effective} hash rate depends on how fast it hashes {\em unique} nonces for a given block of messages. As we will see, since miners include a miner transaction with one-time address $K^o \in^E_R \mathbb{Z}_l$ (E = effectively) in their blocks, blocks are always unique between miners except with negligible probability.}
\[ \mathit{hashSpeed} \approx \mathit{totalDifficulty}/\mathit{totalTime} \]

If we want to set the target time to mine new blocks, so blocks are produced at a rate\\ \(\textrm{(one block)/(target time)}\), then from the hash speed we can calculate how many hashes it should take for the network to spend that amount of time mining.
\[ \mathit{miningHashes} = \mathit{hashSpeed}*\mathit{targetTime} \]

Since difficulty is approximately how many hashes it takes to generate a proof of work, we can set the new difficulty equal to $\mathit{miningHashes}$. Note: we round up so difficulty never equals zero.
\[ \mathit{newDifficulty} = (\mathit{totalDifficulty}/\mathit{totalTime})*\mathit{targetTime}\]

There is no guarantee the next block will take $\mathit{newDifficulty}$ amount of hashes to mine, but over time and many blocks and constantly re-calibrating, the difficulty will track with the network's real hash speed and blocks will tend to take $\mathit{targetTime}$.\footnote{If we assume network hash rate is constantly, gradually, increasing, then since new difficulties depend on {\em past} hashes (i.e. before the hash rate increased a tiny bit) we should expect actual block times to, on average, be slightly less than $\mathit{targetTime}$. The effect of this on the emission schedule (Section \ref{subsec:block-reward}) could be canceled out by penalties from increasing block sizes, which we explore in Section \ref{subsec:penalty}.}


\subsection{Consensus: largest cumulative difficulty}

Now we have a mechanism to resolve conflicts between chain forks. Since difficulty represents how much work was spent to mine a block, higher difficulty means more work performed.

By convention, the chain with highest cumulative difficulty (from all blocks in the chain), and therefore with most work spent constructing, is considered the real, legitimate version. If a chain splits and each fork has the same cumulative difficulty, nodes continue mining on their fork until one branch gets ahead of the other, at which point the weaker branch is discarded (`orphaned').%source?

If nodes wish to change or upgrade the basic protocol, i.e. the set of rules a node considers when deciding if a blockchain copy or new block is legitimate, they may easily do so by forking the chain. Whether the new branch has any impact on users depends on how many nodes switch and how much software infrastructure is modified.\footnote{Monero has successfully changed its protocol 7 times, with nearly all users and miners adopting the changes each time. v1 April 18, 2014 \cite{bitmonero-launched}; v2 March, 2016; v3 September, 2016; v4 January, 2017; v5 April, 2017; v6 September, 2017; v7 April, 2018; see src/cryptonote\_core/blockchain.cpp mainnet\_hard\_forks}

For an attacker to convince honest nodes to alter the transaction history, perhaps in order to respend/unspend funds, he must create a chain fork (on the current protocol) with higher total difficulty than the main chain (which meanwhile continues to grow). This is very hard to do unless you control over 50\% of the network hash speed and can outwork other miners. \cite{Nakamoto_bitcoin}


\subsection{Mining in Monero} %get_difficulty_for_next_block, next_difficulty

To make sure chain forks are on an even footing, we don't sample the most recent blocks (for calculating new difficulties), instead lagging our bunch $b$ by $l$. For example, if there are 29 blocks in the chain (blocks 1,...,29), $b = 10$, and $l = 5$, we sample blocks 15-24 in order to compute block 30's difficulty.

If mining nodes are dishonest they can manipulate timestamps so new difficulties don't match the network's real hash speed. We get around this by sorting timestamps chronologically, then chopping off the first $o$ outliers and last $o$ outliers. Now we have a `window' of blocks $w = b-2*o$. From the previous example, if $o = 3$ and timestamps are honest then we would chop blocks 15-17 and 22-24, leaving blocks 18-21 to compute block 30's difficulty from.

Monero is somewhat bizarre. Instead of sorting block difficulties so they correspond with their blocks' sorted timestamps, we use an array of the original bunch's blocks' cumulative difficulties, leave it unsorted, and chop off the $o$ outliers from that. Cumulative difficulty for a block is that block's difficulty plus the difficulty of all previous blocks in the chain.

Using\marginnote{src/crypto- note\_core\_ block- chain.cpp get\_diff- iculty\_for\_ next\_block()}[-1.5cm] the chopped arrays of $w$ timestamps and cumulative difficulties (indexed from 1,...,$w$), we define
\[ \mathit{totalTime} = \mathit{choppedSortedTimestamps}[w] - \mathit{choppedSortedTimestamps}[1]\]
\[ \mathit{totalDifficulty} = \mathit{choppedCumulativeDifficulties}[w] - \mathit{choppedCumulativeDifficulties}[1]\]

In\marginnote{src/crypto- note\_config.h} Monero the target time is 120 seconds (2 minutes), $l = 15$ (30 mins), $b = 720$ (one day), and $o = 60$ (2 hours).\footnote{In March, 2016, (v2 of the protocol) Monero changed from 1 minute target block times to 2 minute target block times \cite{monero-0.9.3}. Other difficulty parameters have always been the same.}

Block difficulties are not stored in the blockchain, so someone downloading a copy of the blockchain and verifying all blocks are legitimate needs to recalculate difficulties from recorded timestamps. There\marginnote{src/crypto- note\_basic\_ difficulty.cpp next\_diff- iculty()} are a few rules to consider for the first $b+l = 735$ blocks.

\begin{itemize}
    \item[] \textbf{Rule 1}: Ignore the genesis block (block 0, with $d = 1$) completely. Blocks 1 and 2 have $d = 1$.
    \item[] \textbf{Rule 2}: Before chopping off outliers, try to get the window $w$ to compute totals from.
    \item[] \textbf{Rule 3}: After $w$ blocks, chop off high and low outliers, scaling the amount chopped until $b$ blocks. If the amount of previous blocks (minus $w$) is odd, remove one more low outlier than high.
    \item[] \textbf{Rule 4}: After $b$ blocks, sample the earliest $b$ blocks until $b+l$ blocks, after which everything proceeds normally - lagging by $l$.
\end{itemize}


\subsection*{Monero proof of work (PoW)}

Monero\marginnote{src/crypto/ slow-hash.c} uses a proof of work hash algorithm known as Cryptonight, designed to be relatively inefficient on GPU, FPGA, and ASIC architectures \cite{CryptoNight} compared to standard hash functions like SHA256. In April, 2018, (v7 of the protocol) it was slightly modified to counter the advent of Cryptonight ASICs \cite{cryptonight7}.



\section{Money supply}
\label{sec:money-supply}

Obviously a digital currency needs a supply of money for users to transact with. There are two basic mechanisms for creating money in a blockchain-based cryptographic currency (a.k.a. cryptocurrency).

First, the currency's creators can simply conjure a set amount and distribute it to people in the genesis message. This is often called an `airdrop'. Sometimes cryptocurrency creators give themselves a large amount of money in a so-called `pre-mine'. \cite{premine-description}

Second, the currency can be automatically distributed as reward for mining a block, much like mining for gold. There are two types here. In the Bitcoin model the total possible supply is capped. Block rewards slowly decline to zero, after which no more money is ever made. In the inflation model the supply continues to rise indefinitely. 

Some cryptocurrencies employ both mechanisms for money creation. In fact, Monero is based on a currency known as Bytecoin that had a large pre-mine, followed by block rewards \cite{monero-history}. Monero had no pre-mine, and as we will see, its block rewards slowly decline to a small amount after which all new blocks reward that same amount, making Monero an inflationary currency.


\subsection{Block reward}
\label{subsec:block-reward} %get_block_reward

The block reward concept is straightforward. Block miners, before mining for a nonce, make a `miner transaction' with no inputs and one output. The output amount is equal to the block reward, plus transaction fees from all transactions to be included in the block, and is communicated in clear text. Nodes who receive a mined block must verify the block reward is correct, and can calculate the current money supply by summing all past block rewards together.

Besides distributing money, block rewards incentivize mining. If there were no block rewards (and no other mechanism), why would anyone mine new blocks? Perhaps altruism or curiosity. However, few miners makes it easy for a malicious actor to assemble $>$50\% of the network's hash rate, with which they can easily rewrite recent chain history.\footnote{As an attacker gets higher shares (beyond 50\%) of the hash rate, it becomes easier and easier to rewrite older and older blocks.}

With block rewards, competition between miners drives total hash rate up until the marginal cost of adding more hash rate is higher than the marginal reward of obtaining that proportion of mined blocks (which appear at a constant rate) (plus some premiums like risk and opportunity cost). This means as a cryptocurrency becomes more valuable, its total hash rate will increase and it becomes progressively more difficult and expensive to gather $>$50\%.


\subsubsection*{Bit shifting}

Bit shifting is used for calculating the base block reward (as we will see in Section \ref{subsec:penalty}, the block reward can sometimes be reduced below the base amount). 

Suppose we have an integer A = 13, which has a bit representation [1101]. If we shift the bits of A down by 2, denoted A $>>$ 2, we get [0011].01, which equals 3.25. In reality that last .01 outside the array, equal to 0.25, gets thrown away - `shifted' into oblivion, leaving us with [0011] = 3. 

This operation is equivalent to $\mathit{floor}$(13/4) = 3, or $\mathit{floor}$(A/2\^{}2), where $\mathit{floor}$ rounds the number down - chopping off the 01 part of [0011].01.

        
\subsubsection*{Calculating base block reward for Monero}

Let's call the current total money supply M, and the `limit' of the money supply L = $2^{64} - 1$ (in binary it is [11....11], with 64 bits). In the beginning of Monero, the base block reward \(\textrm{B = (L-M) $>>$ 20}\), or in other words $\mathit{floor}$((L-M)/2\^{}20). If M = 0, then, in decimal format,\vspace{.2cm}
\[ \textrm{L} = 18,446,744,073,709,551,615 \]
\[ \textrm{B}_0 = (L-0) >> 20 = 17,592,186,044,415 \]

These numbers are in `atomic units' - 1 atomic unit of Monero can't be divided (there is no 0.5 atomic units). Clearly atomic units are ridiculous - L is over 18 quintillion! We can divide everything by 10\^{}12 to move the decimal point over, giving us the standard units of Monero (a.k.a. XMR, Monero's so-called `stock ticker').\vspace{.15cm}
\[ \frac{\textrm{L}}{10^{12}} = 18,446,744.073709551615 \]
\[ \textrm{B}_0 = \frac{(L-0) >> 20}{10^{12}} = 17.592186044415 \]

And there it is, the very first block reward, dispersed to pseudonymous thankful\_for\_today (who was responsible for starting the Monero project) in Monero's genesis block \cite{bitmonero-launched}, was about 17.6 Moneroj! See Appendix \ref{appendix:genesis-block} to confirm this for yourself.\footnote{Monero amounts are stored in atomic-unit format in the blockchain.}

As more and more blocks are mined block rewards accumulate and M grows, continuously lowering future block rewards. Initially (since the genesis block in April, 2014) Monero blocks were mined once per minute, but in March, 2016, it became two minutes per block \cite{monero-0.9.3}. To keep the `emission schedule', i.e. the rate of money creation,\footnote{For an interesting comparison of Monero and Bitcoin's emission schedules see \cite{monero-coin-emission}.} the same, block rewards were doubled. This just means, after the change, we use (L-M) $>>$ 19 instead of $>>$ 20 for new blocks. Currently the base block reward is
\[ \textrm{B} = \frac{(L-M) >> 19}{10^{12}} \]


\subsection{Block size penalty}
\label{subsec:penalty}

It would be nice to mine every new transaction into a block right away. However, what if someone submits a lot of transactions maliciously? The blockchain, storing every transaction, would quickly grow unpleasantly large. 

One mitigation is a fixed block size, so the number of transactions per block is limited. What if honest transaction volume rises? Each transaction author would bid for a spot in new blocks by offering fees to miners. Miners would mine transactions with the highest fees in order to earn maximum money. As transaction volume increases, fees would become prohibitively large for transactions of small amounts (such as Alice buying an apple from Bob). Only people willing to outbid everyone else would get their transactions into the blockchain.\\

Monero avoids those extremes (limited vs unlimited block size) with a dynamic block size. Miners can make blocks bigger than typical blocks from the recent past, but they have to pay a penalty in the form of reduced block reward. It's the price of making a bigger block.\\

To calculate a new block's size penalty, we sample the most recent 100 blocks in the blockchain and find the {\em median} block size, $\mathit{median\_100blocks}$. We set the variable M100 to the larger value in the set \{$\mathit{median\_100blocks}$, 300kB\}.\footnote{In the beginning of Monero it was 20kB, then increased to 60kB in March, 2016, (v2 of the protocol) \cite{monero-0.9.3}, and has been 300kB since April, 2017 (v5 of the protocol) \cite{monero-v5}. This non-zero `floor' on the dynamic block size helps with transient transaction volume changes, especially in the early stages of Monero adoption.} Only blocks larger than M100 pay a penalty, but the median can slowly rise, allowing progressively bigger blocks with no penalty. The maximum block size is 2*M100.

If the intended block size is greater than M100, then, given base block reward B, the block reward penalty is
\[ \textrm{P} = \textrm{B}*((\textrm{block\_size}/\textrm{M100}) - 1)^2 \]

The\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp get\_block\_ reward()} actual block reward is therefore\vspace{.3cm}
\begin{align*}
    \textrm{B}^{\textrm{actual}} &= \textrm{B} - \textrm{P} \\
    \textrm{B}^{\textrm{actual}} &= \textrm{B}*(1-((\textrm{block\_size}/\textrm{M100}) - 1)^2)
\end{align*}

Using the \^{}2 operation means penalties are sub-proportional to block size. A block size 10\% larger than M100 has just a 1\% penalty, and so on. \cite{monero-coin-emission}\\

We can expect miners to create blocks larger than M100 when the fee from adding another transaction is bigger than the penalty incurred.


\subsection{Dynamic minimum fee}
\label{subsec:dynamic-minimum-fee} %get_dynamic_per_kb_fee

To prevent malicious actors from flooding the blockchain with transactions, which could be used to pollute ring signatures, and generally bloat it unnecessarily, Monero requires a minimum fee per kB of transaction data. Originally this was simply 0.002 XMR/kB, then in January, 2017, (v4 of the protocol) a formula was added to mitigate some security risks from transaction fees higher than block rewards, and to deincentivize miners from pushing M100 above 300kB during transient high volumes of submitted transactions \cite{dynamic-per-kb-fee}.

First we say the base dynamic fee is $f^{kB}_b$ = 0.0004/kB,\footnote{The base fee was changed from 0.002 XMR/kB to 0.0004 XMR/kB in April, 2017 (v5 of the protocol) \cite{monero-v5}.} then we compute $\textrm{B}^{\textrm{actual}}$ and M100 from the previous sections.

The\marginnote{src/crypto- note\_core\ block- chain.cpp get\_dyna- mic\_per\_ kb\_fee()} minimum fee per kB is\footnote{To check if a given fee is correct, we allow a 2\% buffer on $f^{kB}$ in case of integer overflow (we compute fee before tx size is completely determined). This means the effective minimum fee is 0.98*$f^{kB}$.}\vspace{.1cm}
\[ f^{kB} = f^{kB}_b*(\textrm{300kB}/\textrm{M100})*(\textrm{B}^{\textrm{actual}}/10) \]

Note: we round transaction size up to the nearest kB.


\subsection{Emission tail}
\label{subsec:emission-tail}

Let's suppose a cryptocurrency with fixed maximum supply and dynamic block size. After a while its block rewards fall to zero. With no more penalty on increasing block size, miners will simply add any transaction with a non-zero fee to their blocks. 

Block sizes will stabilize around the average rate of transactions submitted to the network, and transaction authors will have no compelling reason to use transaction fees above the minimum, which would be zero according to Section \ref{subsec:dynamic-minimum-fee}. 

This introduces an unstable, insecure situation. Miners will have little to no incentive to mine new blocks, leading to a fall in network hash rate as returns on investment decline. Block times will remain the same as difficulties adjust, but the cost of performing a double-spend attack may become feasible for malicious actors.\\
        
Monero\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp get\_block\_ reward()} mitigates this by not allowing the block reward to fall below 0.6 XMR (0.3 XMR per minute). This means when the following condition is met,\vspace{.2cm}
\begin{align*}
               0.6 &> ((L-M) >> 19)/10^{12} \\
        \textrm{M} &> \textrm{L} - 0.6*2^{19}*10^{12} \\
\textrm{M}/10^{12} &> \textrm{L}/10^{12} - 0.6*2^{19} \\
\textrm{M}/10^{12} &> 18,132,171.273709551615
\end{align*}

then the Monero chain will enter a so-called `emission tail', with constant 0.6 XMR (0.3 XMR/minute) block rewards forever after.\footnote{The Monero emission tail's estimated arrival is May, 2022 \cite{monero-tail-emission}.}


\subsection{Miner transaction}
\label{subsec:miner-transaction} %-fees -> summed into block reward and spent in the miner tx (construct_miner_tx function)

Each\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp construct\_ miner\_tx()} block has a miner transaction that permits whoever mined a block to send himself the block reward and any transaction fees from transactions included in the block (summed into one output).\footnote{The miner transaction output can theoretically be sent to a subaddress and/or use multisig and/or encoded (or not) payment ID. We don't know if any implementations have any of those features. Note that we need a transaction public key as usual.} The output of a miner transaction is locked, unspendable, for 60 blocks after it is published \cite{transaction-lock}.\footnote{Any transaction's author can lock its outputs, rendering them unspendable until after a specified block height. He only has the option to lock all outputs to the same block height. It is not clear if this offers any meaningful utility to transaction authors. Locked outputs are only mandatory for miner transactions.}\\%justification?

Since RingCT was implemented in January, 2017 (v4 of the protocol) \cite{ringct-dates}, people downloading a new copy of the blockchain compute a commitment to the miner transaction (a.k.a tx) amount\marginnote{src/block- chain\_db/ blockchain\_ db.cpp add\_trans- action()} $a$, as $C = 1G + aH$, and store it for referral. This means block miners can spend their miner transaction outputs just like a normal transaction's output, mixing them into MLSAG rings with other transaction outputs (both normal and miner tx's are eligible).\\

Blockchain verifiers store each post-RingCT block's miner tx amount commitment, for 32 bytes each, and compute them with:

\begin{itemize}
    \setlength\itemsep{\listspace}
    \item [\textbf{PA}] Point addition for some points $A, B$: $A + B$ \quad [1]
    \item [\textbf{KBSM}] Known-base scalar multiplications for some integer $a$: $a G$ \quad [2]
\end{itemize}


\section{Blockchain structure}
\label{sec:blockchain-structure}

The style of blockchain Monero uses is simple. \\

It starts with a genesis message of some kind (in our case basically a miner transaction dispersing the first block reward), which constitutes the genesis block. The next block contains a reference to the previous block, in the form of block ID. A block ID is simply a hash of: the block's header (a list of information about a block), a so-called `Merkle root' that attaches all the block's transaction IDs (which are hashes of each transaction), and the number of transactions (including the miner transaction). \\

To\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp get\_block\_ hashing\_ blob()} produce a new block, one must do proof of work hashes by changing a nonce value stored in the block header until the difficulty target condition is met. The proof of work and block ID hash the same information, except use different hash functions.


\subsection{Transaction ID}
\label{subsec:transaction-id} %calculate_transaction_hash
        %each arrow is a hash
Transaction IDs are similar to the message signed by input MLSAG signatures (Section \ref{full-signature}), but include the MLSAG signatures too.

The\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_uti- ls.cpp calculate\_ transaction\_ hash()} following information is hashed:
\begin{itemize}
    \item TX Prefix  = \{transaction era version (i.e. ringCT = 2), inputs \{key offsets, key images\}, outputs \{one-time addresses\}, extra \{transaction public key, payment ID or encoded payment ID, misc.\}\}
    \item TX Stuff   = \{signature type (null/miner vs simple vs full), transaction fee, pseudo output commitments for inputs, ecdhInfo (masks and amounts), output commitments\}
    \item Signatures = \{MLSAGs, range proofs\}
\end{itemize}

In this tree diagram, we use a black arrow to indicate a hash of inputs.
        
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {grow'=90, 
                    edge = {<-, > = triangle 60},
                    fork sep = 4.5 mm,
                    l sep = 8 mm,
                    rectangle, draw
                    },
        sn edges,
        where n children=0{tier=terminus}{},
        [Transaction ID
            [$\mathcal{H}_n$(TX Prefix)]
            [$\mathcal{H}_n$(TX Stuff)]
            [$\mathcal{H}_n$(Signatures)]
        ]
    \end{forest}    
\end{center}

In place of an `input', a miner transaction records the block height of its block. This ensures the miner transaction's ID, which is simply a normal transaction ID except with $\mathcal{H}_n$(Signatures) $\rightarrow$ $\mathcal{H}_n$(0), is always unique. No one can make different blocks with the same miner tx ID by setting the miner transaction's amount (i.e. with fees) and output one-time address the same, which could confuse people looking for the ID.


\subsection{Merkle tree}
\label{subsec:merkle-tree} %tree_hash

Some users may want to discard unnecessary data from their copy of the blockchain. For example, once you verify some transaction's range proofs and input signatures, the only reason to keep that signature information is so users who obtain it from you can verify it for themselves.\\

To\marginnote{src/crypto/ tree-hash.c tree\_hash()} facilitate `pruning' transaction data, and to more generally organize it within a block, we use a Merkle tree \cite{merkle-tree}, which is just a binary hash tree of transaction IDs. Any branch in a Merkle tree can be pruned if you keep its root hash.\footnote{We do not know of any Monero users who prune their blockchain, nor of any software able to do it. If pruning {\em were} implemented, it would probably involve deleting all signature data after verification, and keeping $\mathcal{H}_n$(Signatures) for computing transaction IDs. Signatures constitute most of a block's data, so this could allow a substantial reduction in blockchain size.}\\

An example Merkle tree based on four transactions and a miner transaction is diagrammed in Figure \ref*{chapter:blockchain}.1.\footnote{A bug in the code for computing Merkle trees led to a serious attack on Monero on September 4, 2014 \cite{MRL-0002}.}

\begin{center}
    \begin{forest}
        forked edges,
        for tree = {grow'=90, 
                    edge = {<-, > = triangle 60},
                    fork sep = 4.5 mm,
                    l sep = 8 mm,
                    rectangle, draw
                    },
        sn edges,
        where n children=0{tier=terminus}{},
        [Merkle Root  
            [$Hash$ B
                [Transaction ID \\1]
                [Transaction ID \\2]
            ] 
            [$Hash$ C
                [Transaction ID \\3]
                [$Hash$ A
                    [Transaction ID \\4]
                    [Miner Transaction ID]
                ]
            ]
        ]
        \node at (current bounding box.south)
        [below=3ex,thick,draw,rectangle]
        {\emph{Figure \ref*{chapter:blockchain}.1: Merkle Tree}};
    \end{forest}
\end{center}

We can use the Merkle root to reference all of a blocks transactions, while facilitating transaction, or transaction component, pruning.

\newpage
\subsection{Blocks}
\label{subsec:blocks} %https://monero.stackexchange.com/questions/3958/what-is-the-format-of-a-block-in-the-monero-blockchain/6461#6461

A block is basically a block header and some transactions. Block headers record important information about each block. A block's transactions can be referenced with their Merkle root. We present here the outline of a block's content. Our readers can find a real block example in Appendix \ref{appendix:block-content}.

\begin{itemize}
    \item Block header:
    \begin{itemize}
        \item Major version - Used to track hard forks (changes to protocol).
        \item Minor version - Previously used for voting, now just displays the major version again.
        \item Timestamp\marginnote{src/crypto- note\_core/ block- chain.cpp check\_block\_ timestamp()} - UTC (Coordinated Universal Time) time of block. Added by miners, timestamps are unverified but they won't be accepted if lower than the median timestamp of the last 60 blocks. %check_block_timestamp
        \item Previous block's ID - Referencing the previous block, this is the essential feature of a blockchain.
        \item nonce - A 32 byte integer that miners change over and over until the PoW hash meets the difficulty target. Block verifiers can easily recalculate the PoW hash.
    \end{itemize}
    \item Miner transaction - Disperses block reward and transaction fees to the block's miner.
    \item Transaction IDs - References to non-miner transactions added to the blockchain by this block. Tx IDs can, in combination with the miner tx ID, be used to calculate the Merkle root, and to find the actual transactions wherever they are stored.
\end{itemize}
\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp calculate\_ block\_hash()}[-2.3cm]
Block IDs are computed like this:\footnote{We add 1 to the number of transactions to account for the miner tx.} %calculate_block_hash, which ultimately uses cn_fast_hash(get_block_hashing_blob)
\[ \textrm{Block ID} = \mathcal{H}_n(\textrm{Block header}, \textrm{Merkle root}, \# \textrm{transactions} + 1) \]

And block mining\marginnote{get\_block\_ longhash()} is performed like this:\\ %get_block_hashing_blob, get_block_longhash
\quad - while ${PoW}_{output} > {target}$, keep changing the nonce and recalculating:
\[ {PoW}_{output} = \mathcal{H}_{PoW}(\textrm{Block header}, \textrm{Merkle root}, \# \textrm{transactions} + 1) \]

In addition to the data in each transaction (Section \ref{sec:transaction_summary}), we store the following information:
\begin{itemize}
    \setlength\itemsep{\listspace}
    \item Major and minor versions: variable integers $\leq$ 64 bits
    \item Timestamp: variable integer $\leq$ 64 bits
    \item Previous block's ID: 32 bytes
    \item nonce: 32 bytes
    \item Miner transaction: 32 bytes for one-time address, 32 bytes for transaction public key, and variable integers for unlock time, height, and amount. After downloading the blockchain, we also need 32 bytes to store a commitment to post-RingCT miner tx amounts, $C = 1G + a H$, which are computed with:
    \item [\textbf{PA}] Point addition for some points $A, B$: $A + B$ \quad [1]
    \item [\textbf{KBSM}] Known-base scalar multiplications for some integer $a$: $a G$ \quad [2]
    \item Transaction IDs: 32 bytes each
\end{itemize}