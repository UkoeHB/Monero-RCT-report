\chapter{Transazioni Monero Congiunte (TxTangle)}
\label{chapter:txtangle}

Esistono diverse e inevitabili euristiche del grafo delle transazioni dovute alla natura di diverse entità e scenari. In particolare, il comportamento di miner, pool (Sezione 5.1 di \cite{AnalysisOfLinkability}), marketplace in escrow e exchange presenta schemi chiari e aperti all'analisi anche all'interno del protocollo di firme ad anello di Monero. 

In questo capitolo verrà trattato \emph{TxTangle}, analogo a CoinJoin di Bitcoin \cite{coinjoin-wiki}, un metodo per confondere tali euristiche.\footnote{Questo capitolo costituisce la proposta per un protocollo di transazioni congiunte. Al momento della stesura, nessun protocollo di questo tipo è stato implementato. Una proposta precedente, denominata MoJoin e creata da un ricercatore del Monero Research Lab (MRL) sotto lo pseudonimo di Sarang Noether, richiedeva un dealer affidabile per funzionare. Tale dealer sembra essere in conflitto con l'impegno fondamentale del progetto Monero per la privacy e la fungibilità, e quindi MoJoin non è stato ulteriormente sviluppato.} In sostanza, diverse transazioni vengono compresse in un'unica transazione, facendo sì che i modelli di comportamento di ciascun partecipante si mescolino. 

Per raggiungere tale offuscamento, deve essere irragionevolmente difficile per gli osservatori utilizzare le informazioni contenute in una transazione congiunta per raggruppare input e output, associarli ai singoli partecipanti o sapere quanti partecipanti ci fossero effettivamente.\footnote{Poiché in Bitcoin gli importi sono chiaramente visibili, è spesso possibile raggruppare gli input e gli output di CoinJoin in base alle somme degli importi. \cite{coinjoin-sudoku}} Inoltre, anche i partecipanti stessi non dovrebbero essere a conoscenza del numero di partecipanti, o essere in grado di raggruppare gli input e gli output degli altri partecipanti a meno che non controllino tutti i raggruppamenti tranne uno.\footnote{L'inquinamento delle transazioni congiunte da parte di un attore malevolo è un potenziale attacco a questo metodo, identificato per la prima volta per CoinJoin. \cite{coinjoin-pollution}} Infine, dovrebbe essere possibile costruire transazioni congiunte senza fare affidamento su un'autorità centrale \cite{exa-blockchain-analysis}. Fortunatamente, tutti questi requisiti possono essere soddisfatti in Monero.



\section{Costruzione di Transazioni Congiunte}
\label{sec:building-txtangle}

In una transazione normale, input e output sono collegati utilizzando la dimostrazione sul bilanciamento degli importi. Dalla Sezione \ref{sec:commitments-and-fees}, la somma degli impegni pseudo-output è uguale alla somma degli impegni di output (più l'impegno della commissione):\vspace{0.175cm}
\[\sum_j C'^a_{j} - (\sum_t C^b_{t} + f H) = 0\]

Una transazione congiunta banale potrebbe prendere tutto il contenuto di più transazioni e raggrupparlo in una sola. I messaggi MLSAG firmerebbero tutti i dati delle sotto-transazioni, e il bilanciamento degli importi verrebbe dimostrato in modo piuttosto ovvio (0 + 0 + 0 = 0).\footnote{Poiché le prove di intervallo Bulletproof sono effettivamente aggregate in una sola (Sezione \ref{sec:range_proofs}), i partecipanti dovrebbero collaborare in una certa misura anche nel caso banale.} Tuttavia, i raggruppamenti di input e output potrebbero essere identificati altrettanto facilmente testando se i sottoinsiemi di input/output hanno importi bilanciati.\footnote{I partecipanti potrebbero provare a dividere la commissione in modo fantasioso per confondere gli osservatori, ma questo approccio fallirebbe di fronte alla forza bruta poiché le commissioni non sono così grandi (circa 32 bit o meno).}

Possiamo facilmente aggirare questo problema calcolando segreti condivisi tra ogni coppia di partecipanti, quindi aggiungendo questi offset alle maschere dei loro pseudo impegni di output (Sezione \ref{sec:ringct-introduction}). In ogni coppia, un partecipante aggiunge il segreto condiviso a uno dei suoi pseudo impegni di output, e l'altro partecipante lo sottrae da uno dei \emph{suoi} pseudo impegni. Quando sommati insieme, i segreti si annullano, e poiché ogni coppia di partecipanti ha un segreto condiviso, il bilanciamento degli importi appare solo dopo che tutti gli impegni sono stati combinati.\footnote{Compensiamo i pseudo impegni di output invece degli impegni di output poiché le maschere degli impegni di output sono costruite dall'indirizzo del destinatario (Sezione \ref{sec:pedersen_monero}).}

I segreti condivisi possono nascondere i raggruppamenti di input/output nel senso immediato, ma i partecipanti devono in qualche modo conoscere tutti gli input e gli output, e il modo più semplice è se ognuno comunica i propri raggruppamenti individuali di input/output. Chiaramente questo viola la premessa iniziale, e in ogni caso implica che i partecipanti conoscano il numero totale di partecipanti.


\subsection{Canale di Comunicazione a $n$ Vie }
\label{subsec:n-way-channel}

Il numero massimo di partecipanti ad una transazione congiunta è pari al numero di output o input (a seconda di quale sia inferiore). Il modello prevede che ogni partecipante reale finge di essere una persona diversa per ogni output che sta inviando. Questo serve allo scopo di impostare un canale di comunicazione di gruppo con altri potenziali partecipanti, senza rivelare quanti partecipanti ci sono.

Si supponga $n$ ($2 \leq n \leq 16$, anche se almeno 3 è raccomandato)\footnote{Attualmente, una transazione può avere al massimo 16 output.} persone apparentemente non correlate si riuniscano a intervalli apparentemente casuali in una stanza, programmata per aprirsi all'ora $t_0$ e chiudersi all'ora $t_1$ (solo 16 persone possono essere in una stanza alla volta, e la stanza ha condizioni come la priorità della commissione, la commissione base per byte [per semplificare il consenso attorno alla media attuale e alla ricompensa del blocco], e l'intervallo di tipi di transazione accettabili poiché, ad esempio, le monete di vecchi portafogli Monero non possono essere spese direttamente attraverso RingCT \cite{pre-ringct-outputs-like-coinbase-research-issue-59}). A $t_1$ tutti i membri fittizi segnalano il desiderio di procedere pubblicando una chiave pubblica, e la stanza viene convertita in un canale di comunicazione a $n$ vie costruendo un segreto condiviso tra tutti i membri fittizi.\footnote{Il metodo multisig della Sezione \ref{sec:m-of-n} è un modo, estendendo M-di-N fino a 1-di-N.} Questo segreto condiviso viene utilizzato per crittografare il contenuto dei messaggi, mentre i membri fittizi firmano i messaggi relativi all'input utilizzando firme SAG (Sezione \ref{SAG_section}) in modo che non sia mai chiaro chi ha inviato un determinato messaggio, e i messaggi relativi all'output con un bLSAG (Sezione \ref{blsag_note}) sull'insieme delle chiavi pubbliche dei membri fittizi in modo che gli output effettivi siano dissociati dai membri fittizi.\footnote{Ogni set separato di bLSAG di TxTangle dovrebbe utilizzare le stesse immagini chiave, poiché tutto ciò che è correlato a un dato output è collegato insieme.}% can create their key images using a different hash-to-point algorithm, or more simply by tagging the hash with a string, e.g.


\subsection{Turni di Messaggi per Costruire una Transazione Congiunta}
\label{subsec:message-rounds-txtangle}

Dopo aver impostato il canale, le transazioni TxTangle possono essere costruite in cinque turni di comunicazione, dove il turno successivo può iniziare solo dopo che il precedente è terminato, e a ogni turno viene assegnato un intervallo di tempo entro il quale i messaggi devono essere pubblicati in modo casuale. Questi intervalli hanno lo scopo di prevenire cluster di messaggi che rivelerebbero i raggruppamenti di input/output.
\begin{enumerate}
    \item Ogni membro fittizio genera privatamente uno scalare casuale per ogni output previsto e li firma con bLSAG. Un elenco ordinato di questi scalari viene utilizzato per determinare gli indici di output (si ricordi la Sezione \ref{sec:multi_out_transactions}; lo scalare più piccolo ottiene l'indice $t = 0$).\footnote{La selezione dell'indice di output dovrebbe corrispondere ad altre implementazioni di costruzione di transazioni per evitare il fingerprinting di diversi software. Utilizziamo questo approccio effettivamente casuale per allinearci con l'implementazione principale, che randomizza anche gli output.} Pubblicano questi bLSAG, e anche SAG che firmano la versione della transazione degli input previsti. Dopo questo turno i partecipanti possono calcolare il peso della transazione in base al numero di input e output, e stimare accuratamente la commissione richiesta.\footnote{Se si scopre che ci devono essere solo due partecipanti reali, in base al confronto del numero di input e output con il proprio conteggio di input/output, il TxTangle può essere abbandonato. Si raccomanda che ogni partecipante abbia almeno due input e due output, in caso di attori malevoli che non abbandonano i TxTangle anche quando si rendono conto che ci sono solo due partecipanti. Questa raccomandazione è aperta al dibattito, poiché l'utilizzo di più input e output non è euristicamente neutro.}\footnote{Le transazioni TxTangle non dovrebbero avere informazioni superflue memorizzate nel campo extra (ad esempio, nessun ID di pagamento crittografato a meno che non sia solo un TxTangle a 2 output che dovrebbe avere almeno un ID di pagamento crittografato fittizio).}\footnote{La stima della commissione dovrebbe basarsi su un approccio standardizzato, in modo che ogni partecipante calcoli la stessa cosa. Altrimenti gli output potrebbero essere raggruppati in base al metodo di calcolo della commissione. Questo stesso standard di commissione dovrebbe essere implementato al di fuori del TxTangle, per promuovere che le transazioni TxTangle appaiano uguali alle transazioni normali.}
    \item Ogni membro fittizio utilizza l'elenco delle chiavi pubbliche per costruire un segreto condiviso con ogni altro membro per bilanciare le maschere dei loro pseudo impegni di output, e decide chi aggiungere o rimuovere in base alla chiave pubblica più piccola di ogni coppia.\footnote{Poiché i punti sono compressi (Sezione \ref{point_compression_section}), basta interpretare le chiavi come interi a 32 byte. Il proprietario della chiave più piccola aggiunge, e il proprietario della chiave più grande rimuove, per convenzione.} Ogni membro fittizio deve pagare 1/$n$ della stima della commissione (utilizzando la divisione intera). Al membro fittizio con l'indice di output più basso viene data la responsabilità di pagare il resto della divisione (importo infinitesimale, ma che deve essere preso in considerazione per prevenire il fingerprinting delle transazioni TxTangle). Ogni membro genera privatamente chiavi pubbliche di transazione per ciascuno dei loro output (da non inviare ancora agli altri membri), e costruiscono i loro impegni di output, gli importi cifrati e le prove parziali della Parte A da utilizzare per la prova di intervallo aggregata Bulletproof, firmando tutto con bLSAG (un impegno, un importo codificato e una prova parziale per messaggio bLSAG, e l'immagine chiave li collega all'elenco originale di scalari casuali che è stato utilizzato per specificare gli indici di output). I pseudo impegni di output vengono generati normalmente (Sezione \ref{sec:ringct-introduction}), quindi bilanciati con i segreti condivisi e firmati con SAG. Dopo che i bLSAG e i SAG sono pubblicati, e supponendo che i partecipanti abbiano stimato la commissione totale nello stesso modo, possono ora verificare il bilancio complessivo degli importi.\footnote{Non vengono pubblicati gli importi separati della commissione pagati nel caso in cui un partecipante l'abbia calcolata male, il che potrebbe rivelare un cluster di output a causa di una collezione di importi di commissione non standard. Se gli importi non si bilanciano correttamente, la transazione TxTangle può essere abbandonata.}
    \item Se gli importi si bilanciano correttamente, inizia un breve turno aggiuntivo per costruire il Bulletproof aggregato che dimostra che tutti gli importi di output rientrano nell'intervallo. Ogni membro fittizio utilizza le prove parziali della Parte A e gli impegni di output del turno precedente, e calcola privatamente la sfida aggregata A. La utilizzano per costruire la loro prova parziale della Parte B, che inviano al canale con un bLSAG.
    \item I partecipanti iniziano a compilare il messaggio da firmare con MLSAG (si ricordi la nota a piè di pagina nella Sezione \ref{full-signature}). Gli offset dei membri dell'anello di ogni input e le immagini chiave sono firmati con un SAG e associati al corretto pseudo impegno di output. L'indirizzo monouso di ogni output, la chiave pubblica della transazione e la prova parziale della Parte C (calcolata in base alle prove parziali della Parte B e a una sfida aggregata B) sono firmati con un bLSAG (questi possono anche includere un componente casuale della chiave pubblica di transazione base, che come vedremo può essere utilizzato per una mitigazione fittizia di Janus). Questi due tipologie di messaggio sono pubblicate e trasmesse in ordine casuale durante l'intervallo di comunicazione. 
    \item I partecipanti utilizzano tutte le prove parziali per completare il Bulletproof aggregato e applicano privatamente una tecnica di prodotto interno logaritmico per comprimerlo per la prova finale da includere nei dati della transazione. Una volta raccolte tutte le informazioni da firmare con MLSAG, ogni partecipante completa i MLSAG dei propri input e li invia casualmente (con un SAG per ciascuno) al canale durante l'intervallo di comunicazione. Qualsiasi partecipante può inviare la transazione non appena ha tutti i pezzi.
\end{enumerate}{}

\subsubsection*{Chiavi Pubbliche della Transazione e Mitigazione di Janus}

Se ogni partecipante a un TxTangle conosce la chiave privata della transazione $r$ (Sezione \ref{sec:one-time-addresses}), allora chiunque di essi può testare gli indirizzi di output monouso degli altri rispetto a un elenco di indirizzi noti. Per questo motivo è necessario costruire le transazioni TxTangle come se fossero destinate ad un sottoindirizzo (Sezione \ref{sec:subaddresses}), includendo diverse chiavi pubbliche di transazione per ogni output.

Per supportare una possibile implementazione di una mitigazione per l'attacco di Janus relativa ai sottoindirizzi, in cui una chiave pubblica di transazione \emph{base} aggiuntiva è inclusa nel campo extra \cite{janus-mitigation-issue-62}, i TxTangle dovrebbero anche avere una chiave \emph{base} fittizia composta da una somma di chiavi casuali generate da ogni membro fittizio.\footnote{L'annullamento della chiave (Sezione \ref{subsec:drawbacks-naive-aggregation-cancellation}) non dovrebbe essere un problema, poiché è solo una chiave fittizia e dovrebbe idealmente essere indicizzata casualmente all'interno dell'elenco delle chiavi pubbliche di transazione.}

Molti partecipanti ad una TxTangle che inviano denaro a un sottoindirizzo avranno probabilmente almeno due output, uno dei quali reindirizza il resto al partecipante. Ciò significa che qualsiasi partecipante ad una TxTangle può ancora sfruttare la mitigazione di Janus rendendo la chiave pubblica della transazione del proprio resto anche la chiave \emph{base} per il destinatario del sottoindirizzo.\footnote{Se si invia al proprio sottoindirizzo, non è necessaria la mitigazione di Janus. I portafogli abilitati per la mitigazione di Janus dovrebbero riconoscere che l'importo speso in un TxTangle è uguale all'importo ricevuto dal proprio sottoindirizzo, in modo da non notificare erroneamente all'utente un problema.} Il destinatario del sottoindirizzo potrebbe rendersi conto che la transazione è un TxTangle e che la chiave \emph{base} probabilmente corrisponde all'output di resto del mittente.\footnote{Ciò presuppone che le chiavi pubbliche di transazione hanno una corrispendenza 1:1 con gli output, come apparentemente accade oggi. Se fosse prassi che le chiavi pubbliche di transazione siano in ordine casuale o ordinato all'interno del campo extra, allora le transazioni TxTangle e non-TxTangle sarebbero in gran parte indistinguibili per i destinatari dei sottoindirizzi. Ci sono casi particolari in cui i partecipanti ad una TxTangle non sono in grado di includere una chiave \emph{base} (ad esempio, quando tutti i loro output sono a sottoindirizzi), o dove è chiaramente non-TxTangle poiché il destinatario del sottoindirizzo riceve la maggior parte o tutti gli output. Si noti che poiché le transazioni TxTangle avrebbero generalmente molti più output di una transazione tipica, questa euristica può essere utilizzata per differenziare i TxTangle dalle normali transazioni con sottoindirizzo.}


\subsection{Debolezze}
\label{subsec:weaknesses-txtangle}

Gli attori malevoli hanno due modi principali per vanificare gli effetti di una TxTangle, che cerca di nascondere i raggruppamenti di input/output da potenziali avversari/analisti. Degli attaccanti potrebbero inquinare le transazioni, in modo che il sottoinsieme di partecipanti onesti sia più piccolo (o addirittura inesistente) \cite{coinjoin-pollution}. Potrebbero anche causare il fallimento dei tentativi di effettuare una TxTangle e utilizzare i tentativi successivi degli stessi partecipanti per stimare i raggruppamenti di input/output.

Il primo attacco non è facile da mitigare, specialmente nel caso di una decentralizzazione tale per cui nessun partecipante necessita di una reputazione minima per avviare una TxTangle. Una possibile applicazione di TxTangle può essere attuata con i pool collaborativi, che possono nascondere a quale pool appartengono i loro miner tra una collezione di pool. Tali pool conoscerebbero i raggruppamenti di input/output, ma poiché lo scopo è aiutare i loro miner connessi, sarebbe opportuno per loro mantenere segrete le informazioni. Inoltre, tali TxTangle non consentirebbero la partecipazione di attori malevoli, supponendo che i pool siano onesti.

Il secondo attacco può essere eluso limitando i tentativi di effettuare una TxTangle, inserendo una pausa prima di eseguirne di nuovi, e rigenerando sempre la maggior parte degli elementi casuali di una transazione per nuovi tentativi. Questi elementi includono le chiavi pubbliche della transazione, le maschere dei pseudo impegni, gli scalari delle prove di intervallo e gli scalari MLSAG. In particolare, l'insieme delle esche (decoy) dell'anello per ogni input dovrebbe rimanere lo stesso per prevenire confronti incrociati che rivelino l'input reale. Se possibile, dovrebbero essere utilizzati input reali diversi per ogni tentativo di TxTangle. Poiché questa debolezza è inevitabile rende più accettabile l'argomento trattato nella prossima sezione.



\section{TxTangle Ospitato}
\label{sec:hosted-txtangle}

Il TxTangle totalmente decentralizzato presenta alcune questioni aperte da risolvere. Come vengono avviati e fatti rispettare i turni temporali? Come vengono create le stanze, affinché i partecipanti possano incontrarsi? Il modo più diretto è attraverso un host TxTangle, che crea e gestisce queste stanze. 

Tale host sembrerebbe andare contro l'obiettivo della partecipazione offuscata, poiché ogni individuo deve connettersi e inviargli messaggi che potrebbero essere utilizzati per correlare i raggruppamenti di input/output (specialmente se l'host partecipa e conosce il contenuto dei messaggi). Possiamo usare una rete come I2P\footnote{The Invisible Internet Project (\url{https://geti2p.net/en/}).} per far sì che ogni messaggio ricevuto dall'host appaia come proveniente da un individuo unico.


\subsection{Comunicazione di Base con un Host su I2P e Altre Funzionalità}
\label{subsec:txtangle-host-communication}

Con I2P, gli utenti creano i cosiddetti \emph{tunnel} che fanno passare messaggi fortemente crittografati attraverso i client di altri utenti prima di raggiungere la loro destinazione. Da quanto comprendiamo, questi tunnel possono trasportare più messaggi prima di essere distrutti e ricreati (ad esempio, sembra esserci un timer di 10 minuti sui tunnel). È essenziale per il nostro caso d'uso controllare attentamente quando vengono creati nuovi tunnel e quali messaggi possono uscire dallo stesso tunnel.\footnote{In I2P ci sono "tunnel in uscita" e "tunnel in entrata" (vedi \url{https://geti2p.net/en/docs/how/tunnel-routing}). Tutto ciò che viene ricevuto tramite un tunnel in entrata sembra provenire dalla stessa fonte anche se da più fonti, quindi in superficie sembrerebbe che gli utenti TxTangle non abbiano bisogno di creare tunnel diversi per tutti i loro casi d'uso. Tuttavia, se l'host TxTangle si rende il punto di ingresso per il proprio tunnel in entrata, allora ottiene l'accesso diretto ai tunnel in uscita dei partecipanti TxTangle.}% \footnote{For the sake of absolutely minimal information leaks, what we describe here is probably incredibly inefficient, especially since I2P is already very inefficient compared to the `clear' web.} is it?
\begin{enumerate}
    \item \emph{Richiesta di TxTangle}: nella nostra proposta originale ad $n$ vie (Sezione \ref{subsec:n-way-channel}) i partecipanti aggiungono gradualmente i loro membri fittizi alle stanze TxTangle disponibili prima che siano programmate per chiudere. Tuttavia, se un volume sufficientemente elevato di utenti tenta di effettuare TxTangle contemporaneamente, è probabile che si verifichi un'alta percentuale di fallimenti poiché gli utenti tentano di inserire casualmente tutti i loro output previsti nella stessa "stanza" TxTangle, ma poi le stanze si riempirebbero troppo presto e i partecipanti sarebbero costretti a ritirarsi. Un bel caos.

    È possibile apportare un'ottimizzazione significativa comunicando all'host quanti output si posseggono (ad esempio, fornendogli un elenco delle nostre chiavi pubbliche di membri fittizi) e lasciandogli assemblare i partecipanti di ogni TxTangle. Poiché manteniamo ancora il protocollo di messaggistica bLSAG e SAG, l'host non sarà in grado di identificare i raggruppamenti di output nella transazione finale. Tutto ciò che sa è il numero di partecipanti e quanti output aveva ciascuno. Inoltre, in questo scenario gli osservatori non possono monitorare le stanze TxTangle aperte per dedurre informazioni sui partecipanti, un importante miglioramento della privacy. Si noti che la capacità dell'host di inquinare i TxTangle non è significativamente diversa dal design senza host, dunque questa modifica è neutrale rispetto a tale vettore di attacco.
    \item \emph{Metodo di comunicazione}: poiché l'host funge da centro di trasporto dei messaggi, è più semplice per lui gestire la comunicazione TxTangle. Durante ogni turno l'host raccoglie messaggi dai membri fittizi (ancora casualmente durante un intervallo di comunicazione), e alla fine di un turno c'è una breve fase di distribuzione dei dati in cui invia tutti i dati raccolti a ciascun partecipante, attendendo periodo di \emph{buffer} prima del turno successivo per garantire che i messaggi vengano ricevuti e abbiano il tempo di essere elaborati. % If someone controls multiple mock-members, it's possible that some of those messages just fizzle out, or perhaps that person receives duplicate messages (e.g. the host is given a different destination for each mock-member). L'host non dovrebbe rendersi conto a quante persone reali sta distribuendo queste informazione, né quale membro fittizio ha un fornito un determinato output.
    \item \emph{Tunnel e raggruppamenti input/output}: Una volta avviato un TxTangle, gli utenti devono dissociare le proprie identità fittizie dagli output effettivi che vengono creati. Ciò significa creare nuovi tunnel per i messaggi firmati bLSAG, dove ciascun tunnel può trasmettere solo messaggi relativi ad un output specifico (è accettabile trasmettere più messaggi simili attraverso lo stesso tunnel, poiché ovviamente le informazioni sullo stesso output provengono dalla stessa fonte). Devono anche creare nuovi tunnel per i messaggi firmati SAG relativi a input specifici.
    \item \emph{Minaccia di attacco MITM dell'host}: L'host potrebbe ingannare un partecipante fingendo di essere altri partecipanti, poiché controlla l'invio dell'elenco dei membri fittizi per la costruzione dei messaggi bLSAG e SAG. Ad esempio, l'elenco che l'host invia al partecipante A potrebbe contenere esclusivamente i membri fittizi del partecipante A e dell'host stesso. I messaggi ricevuti dal partecipante B potrebbero essere rifirmati utilizzando l'elenco di A prima di essere ritrasmessi ad A. Poiché tutti i messaggi firmati dall'elenco di A appartengono ad A, l'host avrebbe una conoscenza diretta dei raggruppamenti input/output di A! 
    
    Possiamo impedire all'host di agire come MITM delle interazioni oneste dei partecipanti modificando il modo in cui vengono create le chiavi pubbliche della transazione. I partecipanti si inviano a vicenda le rispettive chiavi pubbliche di transazione normalmente previste (con un bLSAG), quindi, in modo molto simile all'aggregazione robusta delle chiavi affrontata nella Sezione \ref{sec:robust-key-aggregation}, le chiavi effettive che vengono incluse nei dati della transazione (e utilizzate per creare le maschere degli impegni di output, ecc.) sono precedute da un hash dell'elenco dei membri fittizi. Definiamo dunque $\mathcal{H}_n(T_{agg},\mathbb{S}_{mock},r_t G)*r_t G$ come la $t$-esima chiave pubblica di transazione. Integrare l'elenco dei membri fittizi nella transazione stessa rende molto difficile completare i TxTangle senza comunicazione diretta tra tutti i partecipanti effettivi.\footnote{Se la mitigazione di Janus è implementata, questa difesa MITM dovrebbe invece essere fatta con la chiave base falsa di Janus. Ogni membro fittizio fornisce una chiave casuale $r_{mock} G$, dunque la chiave base effettiva è $\sum_{mock} \mathcal{H}_n(T_{agg},\mathbb{S}_{mock},r_{mock} G)*r_{mock} G$.}%Users must access the host's `eepsite/service' to discover available TxTangles, without revealing to the host how many prospective participants there are. Ciò significa che l'utente dovrebbe creare a intervalli casuali un nuovo tunnel verso l'host e attraverso di esso inviare una (falsa) richiesta per TxTangle disponibili. Gli utenti dovrebbero anche creare nuovi tunnel per ogni output/membro fittizio previsto, che vengono utilizzati per richiedere effettivamente un TxTangle.\footnote{In I2P ci sono "tunnel in uscita" e "tunnel in entrata" (vedi \url{https://geti2p.net/en/docs/how/tunnel-routing}). Tutto ciò che viene ricevuto tramite un tunnel in entrata sembra provenire dalla stessa fonte anche se da più fonti, quindi in superficie sembrerebbe che gli utenti TxTangle non abbiano bisogno di creare tunnel diversi per tutti i loro casi d'uso. Tuttavia, se l'host TxTangle si rende il punto di ingresso per il proprio tunnel in entrata, allora ottiene l'accesso diretto ai tunnel in uscita dei partecipanti TxTangle.}\footnote{Se un volume sufficientemente elevato di utenti tenta di creare TxTangle contemporaneamente, è probabile che si verifichi un'alta percentuale di fallimenti poiché gli utenti tentano di inserire casualmente tutti i loro output previsti nella stessa "stanza" TxTangle, ma poi le stanze si riempiono troppo presto e devono ritirarsi. Sarebbe un bel caos. Possiamo apportare un'ottimizzazione significativa dicendo all'host quanti output abbiamo (ad esempio, fornendogli un elenco delle nostre chiavi pubbliche di membri fittizi), e lasciandogli assemblare i partecipanti di ogni TxTangle. Poiché manteniamo ancora il protocollo di messaggistica bLSAG e SAG, l'host non sarà in grado di identificare i raggruppamenti di output nella transazione finale. Tutto ciò che sa è il numero di partecipanti e quanti output aveva ciascuno. Inoltre, in questo scenario gli osservatori non possono monitorare le stanze TxTangle aperte per dedurre informazioni sui partecipanti, un importante miglioramento della privacy. Si noti che il potere dell'host di inquinare i TxTangle non è significativamente influenzato, quindi questa modifica è neutrale rispetto a tale vettore di attacco. Possiamo impedire all'host di agire come MITM ("man in the middle") delle interazioni oneste dei partecipanti (potrebbe farlo servendo loro liste di membri fittizi false in cui si finge tutti gli altri partecipanti) modificando il modo in cui vengono create le chiavi pubbliche di transazione. I partecipanti si inviano a vicenda le loro chiavi pubbliche di transazione previste normalmente (con un bLSAG), quindi, molto simile all'aggregazione robusta delle chiavi della Sezione \ref{sec:robust-key-aggregation}, le chiavi effettive che vengono incluse nei dati della transazione sono precedute da un hash dell'elenco dei membri fittizi e dell'elenco delle chiavi pubbliche di transazione originali. In altre parole, $\mathcal{H}_n(T_{agg},\mathbb{S}_{mock},\mathbb{S}_{r-original},r_t*G)*r_t*G$ è la $t$-esima chiave pubblica di transazione. Integrare l'elenco dei membri fittizi nella transazione stessa rende molto difficile completare i TxTangle senza comunicazione diretta tra tutti i partecipanti effettivi.}
\end{enumerate}{}


\subsection{Host come Servizio}
\label{subsec:txtangle-host-service}

È importante per la sostenibilità e il continuo miglioramento che un servizio TxTangle operi a scopo di lucro\footnote{Mentre un servizio TxTangle implementato può essere a scopo di lucro, il codice stesso potrebbe essere open source. Questo sarebbe importante per l'audit del software wallet che interagisce con un servizio TxTangle.}. Anziché compromettere le identità degli utenti con un modello basato su account, l'host può partecipare a ogni TxTangle con un singolo output, e richiedere ai partecipanti di finanziarlo. Quando si accede all'\emph{eepsite} dell'host per richiedere i TxTangle, gli utenti ricevono in risposta la tariffa per il servizio, che dovrebbe essere pagata per output.

I partecipanti, inoltre, sono responsabili del pagamento delle frazioni della commissione \emph{e} della tariffa dell'host. In questa tipologia di servizio, la chiave pubblica del membro fittizio più piccola (esclusa la chiave dell'host) si prende il resto sia della commissione che della tariffa dell'host.\footnote{È necessario usare le chiavi dei membri fittizi qui poiché l'host non paga una commissione, e il suo indice di output è sconosciuto.} Poiché l'host non ha input, non ha pseudo impegni di output per annullare la maschera del suo impegno di output. Invece, crea segreti condivisi con gli altri membri fittizi come al solito, quindi separa la sua maschera di impegno reale in blocchi di dimensioni casuali per ogni altro membro fittizio e li divide per i segreti condivisi. Pubblica un elenco di tali scalari (corrispondendoli a ogni altro membro fittizio in base alla loro chiave pubblica), firmando con la sua chiave membro fittizia in modo che i partecipanti possano constatare che proviene dall'host. La comparsa di questo elenco segnala l'inizio del turno 1 della Sezione \ref{subsec:message-rounds-txtangle} (ad esempio, la fine del turno di impostazione `0'). I membri fittizi moltiplicheranno il loro scalare fornitogli dall'host per il segreto condiviso appropriato, e lo aggiungeranno alla loro maschera di pseudo impegno. In questo modo, anche l'output dell'host non può essere identificato da alcun partecipante nella transazione finale senza una coalizione completa contro di lui.

Per semplificare i calcoli della commissione, l'host può distribuire la commissione totale da utilizzare nella transazione alla fine del turno 1, poiché apprenderà presto il peso della transazione. I partecipanti possono verificare che l'importo sia simile all'importo previsto e pagarne la frazione.

Se i partecipanti collaborano per imbrogliare e non pagare la tariffa di hosting, l'host può terminare il TxTangle al turno 3. Può anche terminare se nel canale compaiono messaggi che non dovrebbero esserci o che non sono validi.

Alla fine del turno 5 l'host completa la transazione e la invia alla rete per la verifica, come parte del suo servizio. Include l'hash della transazione nel messaggio finale da distribuire.



\section{Dealer Fidato}
\label{sec:dealer-txtangle}

Ci sono alcuni svantaggi nel TxTangle totalmente decentralizzato. Richiede che tutti i partecipanti comunichino e collaborino attivamente all'interno di tempistiche rigorose (e si trovino a vicenda per iniziare), e ciò è difficile da implementare.

L'aggiunta di un \emph{dealer} centrale, che è responsabile della raccolta delle informazioni sulla transazione da ciascun partecipante e dell'offuscamento dei raggruppamenti input/output, può rendere il procedimento più semplice. Il costo da pagare è una soglia di fiducia più alta, poiché il \emph{dealer} deve (come minimo) conoscere quei raggruppamenti.\footnote{Questa sezione è ispirata al protocollo MoJoin.}


\subsection{Procedura Basata su Dealer}
\label{subsec:dealer-procedure-txtangle}

Il \emph{dealer} pubblicizzerà la sua disponibilità a gestire i TxTangle e raccoglierà le richieste da potenziali partecipanti (costituite dal numero di input previsti [con i loro tipi] e output). Il \emph{dealer} può partecipare con il proprio set di input/output se lo desidera.

Dopo che è stato assemblato un gruppo di massimo 16 output (dovrebbero esserci due o più partecipanti, e nessun partecipante può avere tutti gli output o input tranne uno), il \emph{dealer} avvierà il primo dei cinque turni di comunicazione. In ogni turno il \emph{dealer} raccoglie informazioni da ciascun partecipante, prende delle decisioni e invia messaggi che indicano l'inizio di un nuovo turno.
\begin{enumerate}
    \item Per iniziare, il dealer genera, per ogni coppia di partecipanti, uno scalare casuale, e decide quale partecipante in ogni coppia dovrebbe avere la versione positiva o negativa di tale scalare. Utilizza il numero e il tipo di input e output per stimare la commissione totale della richiesta. Somma gli scalari di ciascun partecipante, e invia privatamente a ciascuno la loro somma, insieme alla frazione della commissione che si presume paghino, e gli indici (scelti casualmente) dei loro output. Questi messaggi costituiscono un segnale ai partecipanti che un TxTangle sta iniziando.
    \item Ogni partecipante costruisce la propria sotto-transazione come farebbe normalmente, generando chiavi pubbliche di transazione separate per i propri output (con mitigazione di Janus se necessario), calcolando indirizzi di output monouso e codificando gli importi di output, creando pseudo impegni di output che bilanciano gli impegni di output e la frazione della commissione, assemblare un elenco di offset dei membri dell'anello da utilizzare nelle firme MLSAG insieme alle immagini chiave appropriate, e aggiungere a uno dei propri pseudo impegni di output lo scalare inviato dal dealer (moltiplicato per $G$). In seguito, i partecipanti creano prove parziali della Parte A per i propri output, e inviano tutte queste informazioni al dealer. Il dealer verifica il bilanciamento degli importi di input e output, e invia l'elenco completo delle prove parziali della Parte A a ciascun partecipante.
    \item Ogni partecipante calcola la sfida aggregata A, e genera prove parziali della Parte B che invia al dealer. Il dealer raccoglie le prove parziali e le distribuisce a tutti gli altri partecipanti.
    \item Ogni partecipante calcola la sfida aggregata B, e genera prove parziali della Parte C che invia al dealer. Il dealer le raccoglie, e applica la tecnica del prodotto interno logaritmico per comprimerle nella prova finale. Supponendo che la prova sia verificata come dovrebbe, genera una chiave pubblica di transazione \emph{base} falsa di Janus casuale, e invia il messaggio da firmare in MLSAG a ciascun partecipante.
    \item Ogni partecipante completa i propri MLSAG e li invia al dealer. Una volta che ha tutto il necessario, il \emph{dealer} può finire di costruire la transazione, e inviarla per essere inclusa nella blockchain. Può anche inviare l'ID della transazione a ciascun partecipante in modo che possano confermare che è stata pubblicata.
\end{enumerate}{}