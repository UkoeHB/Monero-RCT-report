\chapter{Firme Avanzate in Stile Schnorr}
\label{chapter:advanced-schnorr}

Una firma Schnorr di base utilizza una sola chiave. Tuttavia, è possibile sfruttare i suoi concetti fondamentali per creare una varietà di schemi di firma progressivamente più complessi. Uno di questi schemi, MLSAG, sarà di importanza centrale nel protocollo di transazione Monero.



%-same signing key across multiple bases
\section{Dimostrazione della Conoscenza di un Logaritmo Discreto su Basi Multiple}
\label{sec:proofs-discrete-logarithm-multiple-bases}

È spesso utile dimostrare che la stessa chiave privata è stata utilizzata per costruire chiavi pubbliche su diverse \emph{basi}. Ad esempio, potremmo avere una chiave pubblica tradizionale $k G$, e un segreto condiviso Diffie-Hellman $k R$ con la chiave pubblica di un'altra persona (si veda la Sezione \ref{DH_exchange_section}), dove le chiavi \emph{base} sono $G$ e $R$. Come spiegato più avanti, è possibile fornire una prova inconfutabile sulla conoscenza del logaritmo discreto $k$ in $k G$ e in $k R$, \emph{dimostrando} che $k$ è lo stesso in entrambi i casi, il tutto senza rivelare $k$.


\subsection*{Dimostrazione Non Interattiva}

Si supponga di avere una chiave privata $k$, e $d$ chiavi base $\mathcal{J} = \{J_1,...,J_d\}$. Le chiavi pubbliche corrispondenti sono $\mathcal{K} = \{K_1,...,K_d\}$. Realizziamo una dimostrazione in stile Schnorr (si veda la Sezione \ref{sec:schnorr-fiat-shamir}) su tutte le basi.\footnote{Anche se la chiamiamo `dimostrazione', può essere resa trivialmente una firma includendo un messaggio $\mathfrak{m}$ nell’hash della sfida. La terminologia è usata in modo intercambiabile in questo contesto.} Si supponga inoltre l’esistenza di una funzione hash \(\mathcal{H}_n\) 
che associa gli input del dominio ad interi da 0 a $l-1$.\footnote{In Monero, la funzione hash è $\mathcal{H}_n(x) = \textrm{sc\textunderscore reduce32}(\mathit{Keccak}(x))$, dove $\mathit{Keccak}$ è alla base di SHA3 e sc\textunderscore reduce32() riduce il risultato a 256 bit nell’intervallo da 0 a $l-1$ (anche se in realtà dovrebbe essere da 1 a $l-1$).} 

\begin{enumerate}
	\item Generare un numero casuale $\alpha \in_R \mathbb{Z}_l$, e calcola, per ogni $i \in (1,...,d)$, $\alpha J_i$.
	\item Calcolare la sfida,\vspace{.175cm}
	\[c = \mathcal{H}_n(\mathcal{J},\mathcal{K},[\alpha J_1],[\alpha J_2],...,[\alpha J_d])\]
	\item Definire la risposta $r = \alpha - c*k$.
	\item Pubblicare la firma $(c, r)$.
\end{enumerate}


\subsection*{Verifica}

Supponendo che il verificatore conosca $\mathcal{J}$ e $\mathcal{K}$, egli effettua i seguenti passaggi:

\begin{enumerate}
	\item Calcolare la sfida:\vspace{.175cm}
	\[c' = \mathcal{H}(\mathcal{J},\mathcal{K},[r J_1 + c*K_1],[r J_2 + c*K_2],...,[r J_d + c*K_d])\]
	\item Se $c = c'$, allora il firmatario conosce sicuramente il logaritmo discreto su tutte le basi, ed è lo stesso in ciascun caso (come sempre, salvo probabilità trascurabili).
\end{enumerate}


\subsection*{Perché Funziona}

Se invece di $d$ chiavi base ce ne fosse solo una, questa dimostrazione sarebbe chiaramente identica alla dimostrazione Schnorr originale (Sezione \ref{sec:schnorr-fiat-shamir}). È possibile considerare ogni chiave base singolarmente per rendersi conto che la dimostrazione multi-base è semplicemente un insieme di dimostrazioni Schnorr collegate tra loro. Inoltre, usare un'unica sfida e risposta per tutte queste dimostrazioni, comporta la condivisione dello stesso logaritmo discreto $k$. Per ottenere una singola risposta che funzioni per più chiavi, la sfida dovrebbe essere nota prima di definire un $\alpha$ per ciascuna chiave, ma questo non è possibile in quanto $c$ è funzione di $\alpha$!



%-multiple signing keys on their own unique bases (or they can be the same e.g. G)
\section{Più Chiavi Private in una Dimostrazione}
\label{sec:multiple_private_keys_in_one_proof}

Proprio come per la dimostrazione multi-base, possiamo combinare più dimostrazioni Schnorr che utilizzano chiavi private diverse. In questo modo dimostriamo di conoscere tutte le chiavi private associate a un insieme di chiavi pubbliche, e riduciamo i requisiti di memoria generando una sola sfida per tutte le dimostrazioni.


\subsection*{Dimostrazione Non Interattiva}

Si supponga di avere $d$ chiavi private $k_1,...,k_d$, e chiavi base $\mathcal{J} = \{J_1,...,J_d\}$,\footnote{Non c'è motivo per cui $\mathcal{J}$ non possa contenere chiavi base duplicate, o che tutte le basi non possano essere uguali (ad esempio $G$). I duplicati sarebbero ridondanti per le dimostrazioni multi-base, ma qui stiamo trattando chiavi private diverse.} con chiavi pubbliche corrispondenti $\mathcal{K} = \{K_1,...,K_d\}$. Per una dimostrazione tipo Schnorr per tutte le chiavi contemporaneamente, è necessario effettuare i seguenti passaggi:

\begin{enumerate}
	\item Generare numeri casuali $\alpha_i \in_R \mathbb{Z}_l$ per tutti $i \in (1,...,d)$, e calcolare tutti gli $\alpha_i J_i$.
	\item Calcolare la sfida:\vspace{.175cm}
	\[c = \mathcal{H}_n(\mathcal{J},\mathcal{K},[\alpha_1 J_1],[\alpha_2 J_2],...,[\alpha_d J_d])\]
	\item Definire ogni risposta $r_i = \alpha_i - c*k_i$.
	\item Pubblicare la firma $(c, r_1,...,r_d)$.
\end{enumerate}


\subsection*{Verifica}

Supponendo che il verificatore conosca $\mathcal{J}$ e $\mathcal{K}$, egli effettua i seguenti passaggi:

\begin{enumerate}
	\item Calcolare la sfida:\vspace{.175cm}
	\[c' = \mathcal{H}(\mathcal{J},\mathcal{K},[r_1 J_1 + c*K_1],[r_2 J_2 + c*K_2],...,[r_d J_d + c*K_d])\]
	\item Se $c = c'$, allora il firmatario conosce le chiavi private di tutte le chiavi pubbliche in $\mathcal{K}$ (salvo probabilità trascurabili).
\end{enumerate}



\section{Firme di Gruppo Anonime Spontanee (Spontaneous Anonymous Group, SAG)}
\label{SAG_section}

Le firme di gruppo sono un metodo per dimostrare che un firmatario appartiene a un gruppo, senza necessariamente identificarlo. In origine (Chaum in \cite{Chaum:1991:GS:1754868.1754897}), gli schemi di firme di gruppo richiedevano che il sistema fosse impostato, e in alcuni casi gestito, da una persona fidata, al fine di prevenire firme illegittime e, in alcuni schemi, mediare nelle controversie. Questi schemi si basavano su un {\em segreto di gruppo}, il che non è auspicabile poiché crea un rischio di divulgazione che potrebbe compromettere l'anonimato. Inoltre, la necessità di coordinazione tra i membri del gruppo (cioè per l'impostazione e la gestione) non è scalabile oltre piccoli gruppi o ambienti aziendali.

Liu {\em et al.} hanno presentato uno schema più interessante in \cite{Liu2004}, basandosi sul lavoro di Rivest {\em et al.} in \cite{rivest-leak-secret}. Gli autori hanno descritto un algoritmo di firma di gruppo chiamato LSAG, caratterizzato da tre proprietà: {\em anonimato, collegabilità} e {\em spontaneità}. In questa sezione verrà trattato il SAG, la versione non collegabile di LSAG, per maggiore chiarezza concettuale. Il concetto della collegabilità (linkability) verrà trattato nelle sezioni successive.
\\

Gli schemi con anonimato e spontaneità sono solitamente chiamati \emph{firme ad anello} (ring signatures). Nel contesto di Monero, queste firme permettono la realizzazione di transazioni non falsificabili e \emph{ambigue} rispetto al firmatario, che rendono i flussi di valuta opachi e non tracciabili.


\subsection*{Firma}

Le firme ad anello sono composte da un anello e da una firma. Ogni {\em anello} è un insieme di chiavi pubbliche, una delle quali appartiene al firmatario, mentre le altre non sono correlate. La {\em firma} viene generata con questo anello di chiavi, e chiunque la verifichi non sarà in grado di determinare quale membro dell’anello abbia firmato effettivamente.

Il nostro schema di firma tipo Schnorr descritto nella Sezione \ref{sec:signing-messages} può essere considerato una firma ad anello con una sola chiave. Possiamo arrivare a due chiavi generando, invece di definire subito $r$, un valore fittizio $r'$ e creando una nuova sfida per definire $r$.
\\

Sia \(\mathfrak{m}\) il messaggio da firmare, \(\mathcal{R} = \{K_1, K_2, ..., K_n\}\) un insieme di chiavi pubbliche distinte (anche detto gruppo o anello), e \(k_\pi\) la chiave privata del firmatario corrispondente alla sua chiave pubblica \(K_\pi \in \mathcal{R}\), dove $\pi$ è un indice segreto. Il firmatario dovrà dunque effettuare i seguenti passaggi:

\begin{enumerate}
	\item Generare un numero casuale \(\alpha \in_R \mathbb{Z}_l\) e risposte finte \(r_i \in_R \mathbb{Z}_l\) per \(i \in \{1, 2, ..., n\}\) escludendo però \(i = \pi\).

	\item Calcolare
	\[c_{\pi+1} = \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [\alpha G])\]

	\item Per \(i = \pi+1, \pi+2, ..., n, 1, 2, ..., \pi-1\) calcolare, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
	\[  c_{i+1} = \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_i G + c_i K_i])\] 

	\item Definire la risposta reale \(r_\pi\) tale che \(\alpha = r_\pi + c_\pi k_\pi \pmod l\).
\end{enumerate}

La firma ad anello prodotta conterrà dunque la firma \(\sigma(\mathfrak{m}) = (c_1, r_1, ..., r_n)\) e l’anello \(\mathcal{R}\).


\subsection*{Verifica}

La verifica consiste nel dimostrare che \(\sigma(\mathfrak{m})\) è una firma valida creata da una chiave privata corrispondente a una chiave pubblica in \(\mathcal{R}\) (senza necessariamente sapere quale), ed è effettuata come segue:

\begin{enumerate}
	\item Per \(i = 1, 2, ..., n\) calcolare iterativamente, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
	\begin{align*}
	c'_{i+1} = \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_i G + c_i K_i])
	\end{align*}

	\item Se \(c_1 = c'_1\) allora la firma è valida. Nota che \(c'_1\) è l’ultimo termine calcolato.
\end{enumerate}

In questo schema di verifica è necessario riservare spazio di memoria per gli \(1+n\) interi e le \(n\) chiavi pubbliche.


\subsection*{Perché Funziona}

Possiamo convincerci informalmente del corretto funzionamento dell’algoritmo attraverso un esempio. Dato l’anello \(R = \{K_1, K_2, K_3\}\) con \(k_\pi = k_2\), per generare la firma è necessario effettuare i seguenti passaggi:
\begin{enumerate}
    \item Generare numeri casuali: \(\alpha\), \(r_1\), \(r_3\)
\begin{align*}
    \intertext{\item Inizializzare il ciclo della firma:}	c_3 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [\alpha G])
    \intertext{\item Iterare: \vspace{-.2cm}}
    c_1 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_3 G + c_3 K_3])\\
    c_2 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_1 G + c_1 K_1])
\end{align*}
    \item Al termine del ciclo, calcolare la risposta: \(r_2 = \alpha - c_2 k_2 \pmod{l}\)
\end{enumerate}

Infine è necessario sostituire \(\alpha\) in \(c_3\) per capire da dove proviene il termine “anello”:\vspace{.175cm}
\begin{alignat*}{3}
    c_3 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [(r_2 + c_2 k_2) G &&])\\
    c_3 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_2 G + c_2 K_2 &&])
\end{alignat*}\vspace{.05cm}

In seguito, eseguire la verifica usando \(\mathcal{R}\) e \(\sigma(\mathfrak{m}) = (c_1, r_1, r_2, r_3)\):
\begin{enumerate}
    \item Usare \(r_1\) e \(c_1\) per calcolare\vspace{.175cm}
    \begin{align*}
c'_2 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_1 G + c_1 K_1])
    \intertext{\item Dal momento in cui abbiamo creato la firma, vediamo che \(c'_2 = c_2\). Dunque, con \(r_2\) e \(c'_2\) calcolare\vspace{.175cm}}
c'_3 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_2 G + c'_2 K_2])
    \intertext{\item È possibile verificare facilmente che \(c'_3 = c_3\) sostituendo \(c_2\) a \(c'_2\). Usando \(r_3\) e \(c'_3\) otteniamo\vspace{.175cm}}
c'_1 &= \mathcal{H}_n(\mathcal{R}, \mathfrak{m}, [r_3 G + c'_3 K_3])
    \end{align*}
\end{enumerate}
\quad Nessuna sorpresa: \(c'_1 = c_1\) se sostituiamo \(c'_3\) con \(c_3\).\vspace{-.3cm}



\section{Le Firme bLSAG}
\label{blsag_note}

Gli schemi di firma ad anello discussi da questa sezione in poi presentano diverse caratteristiche che saranno utili per la creazione di transazioni confidenziali.\footnote{Ricordare che tutti gli schemi di firma robusti hanno modelli di sicurezza che contengono varie proprietà. Le proprietà menzionate qui sono probabilmente quelle più rilevanti per comprendere lo scopo delle firme ad anello di Monero, ma non costituiscono una panoramica completa sulle firme ad anello collegabili.} Si noti che sia l’\emph{ambiguità del firmatario} sia l’\emph{impossibilità di falsificazione} si applicano anche alle firme SAG.

\begin{description}
	\item[Ambiguità del firmatario]
	Un osservatore deve poter essere in grado di constatare l'appartenenza del firmatario al gruppo dell’anello, senza identificarlo (eccetto con probabilità trascurabile).\footnote{\label{anonymity_note}L’anonimato per un’azione si esprime di solito in termini di un \emph{insieme di anonimato}, ovvero \emph{tutte le persone che potrebbero aver compiuto quell’azione}. Il più grande insieme di anonimato è \emph{l’umanità}, e per Monero è la dimensione dell’anello, o ad esempio il cosiddetto \emph{livello mixin} $v$ più il firmatario reale. Il mixin indica quanti membri fittizi ha ciascuna firma ad anello. Se il mixin è $v=4$ allora ci sono 5 firmatari possibili. Ampliare gli insiemi di anonimato rende progressivamente più difficile rintracciare i veri attori.} Monero utilizza questa proprietà per offuscare l’origine dei fondi in ogni transazione.

	\item[Collegabilità]
	Se una chiave privata viene usata per firmare due messaggi diversi, allora i messaggi risulteranno collegati.\footnote{\label{linkability_note}La proprietà di collegabilità non si applica alle chiavi pubbliche non firmanti. Cioè, un membro dell’anello la cui chiave pubblica è stata usata in firme ad anello diverse non causerà collegamenti.} Questa proprietà sarà utile per affrontare e prevenire gli attacchi di doppia spesa (double spending attack) in Monero (eccetto con probabilità trascurabile).

	\item[Impossibilità di falsificazione]
	Nessun attaccante può falsificare una firma eccetto con probabilità trascurabile.\footnote{\label{unforgeability_note}Alcuni schemi di firme ad anello, incluso quello di Monero, sono robusti contro attacchi adattivi con messaggi scelti e attacchi adattivi con chiavi pubbliche scelte. Un attaccante che può ottenere firme legittime per messaggi scelti e corrispondenti a specifiche chiavi pubbliche in anelli a sua scelta non può scoprire come falsificare la firma di nemmeno un messaggio. Questo è chiamato \emph{impossibilità di falsificazione esistenziale}; vedere \cite{MRL-0005-ringct} e \cite{Liu2004}.} Questa proprietà è usata per prevenire il furto di fondi Monero da parte di chi non possiede le chiavi private appropriate.
\end{description}

Nello schema di firma LSAG \cite{Liu2004}, il proprietario di una chiave privata può produrre una firma anonima non collegata per ogni anello\footnote{\label{lsag_linkability_note}Nello schema LSAG la collegabilità si applica solo a firme che usano anelli con gli stessi membri e nello stesso ordine, cioè \emph{lo stesso anello esatto}. In pratica significa ``una firma anonima per ogni membro dell’anello per ogni anello.” Le firme possono essere collegate anche se realizzate per messaggi diversi.}. In questa sezione presentiamo una versione migliorata dell’algoritmo LSAG in cui la collegabilità è indipendente dai membri fittizi dell’anello.\footnote{LSAG è stato trattato nella prima edizione di questo rapporto. \cite{ztm-1}}

Le modifiche apportate sono state sviluppate in \cite{MRL-0005-ringct} basandosi su una pubblicazione di Adam Back \cite{AdamBack-ring-efficiency} riguardante l’algoritmo di firma ad anello CryptoNote \cite{cryptoNoteWhitePaper} (precedentemente usato in Monero e ora deprecato; vedi Sezione \ref{subsec:proofs-input-creation-spendproof}), a sua volta ispirato dal lavoro di Fujisaki e Suzuki in \cite{Fujisaki2007}.


\subsection*{Firma}

Come per SAG, sia \(\mathfrak{m}\) il messaggio da firmare, \(\mathcal{R} = \{K_1, K_2, ..., K_n\}\) un insieme di chiavi pubbliche distinte, e \(k_\pi\) la chiave privata del firmatario corrispondente alla sua chiave pubblica \(K_\pi \in \mathcal{R}\), dove \(\pi\) è un indice segreto. Si assuma l'esistenza di una funzione di hash \(\mathcal{H}_p\), che dato un input restituisce un punto della curva ellittica.\footnote{Non importa se i punti di \(\mathcal{H}_p\) siano compressi o meno. Possono sempre essere decompressi.}\footnote{Monero utilizza una funzione di hash\marginnote{src/ringct/ rctOps.cpp {\tt hash\_to\_p3()}} che restituisce direttamente punti della curva, invece di calcolare un intero che viene poi moltiplicato per \(G\). \(\mathcal{H}_p\) sarebbe compromessa se qualcuno trovasse un modo per ottenere \(n_x\) tale che \(n_x G = \mathcal{H}_p(x)\). Una descrizione dell'algoritmo è in \cite{hashtopoint-writeup}. Secondo il whitepaper CryptoNote \cite{cryptoNoteWhitePaper} la sua origine è in questo articolo: \cite{hashtopoint-original-paper}.}

\begin{enumerate}
	\item Calcolare l'immagine della chiave \(\tilde{K} = k_\pi \mathcal{H}_p(K_\pi)\).\footnote{In Monero è importante usare la funzione hash-to-point per le immagini chiave invece di un altro punto base, così da evitare che la linearità porti al collegamento di firme create dallo stesso indirizzo (anche se per indirizzi monouso diversi). Vedi \cite{cryptoNoteWhitePaper} a pagina 18.}

	\item Generare un numero casuale \(\alpha \in_R \mathbb{Z}_l\) e numeri casuali \(r_i \in_R \mathbb{Z}_l\) per \(i \in \{1, 2, ..., n\}\) escluso \(i = \pi\).

	\item Calcolare
	\[c_{\pi+1} = \mathcal{H}_n(\mathfrak{m}, [\alpha G], [\alpha \mathcal{H}_p(K_\pi)])\]

	\item Per \(i = \pi+1, \pi+2, ..., n, 1, 2, ..., \pi-1\) calcolare, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
	\[c_{i+1} = \mathcal{H}_n(\mathfrak{m}, [r_i G + c_i K_i], [r_i \mathcal{H}_p(K_i) + c_i \tilde{K}])\]

	\item Definire \(r_\pi = \alpha - c_\pi k_\pi \pmod l\).
\end{enumerate}

La firma sarà \(\sigma(\mathfrak{m}) = (c_1, r_1, ..., r_n)\), con immagine chiave \(\tilde{K}\) e anello \(\mathcal{R}\).


\subsection*{Verifica}

La verifica consiste nel dimostrare che \(\sigma(\mathfrak{m})\) è una firma valida creata da una chiave privata corrispondente a una chiave pubblica in \(\mathcal{R}\), e si esegue nel modo seguente:

\begin{enumerate}
    \item Verificare \(l \tilde{K} \stackrel{?}{=} 0\).
	\item Per \(i = 1, 2, ..., n\) calcolare iterativamente, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
	\begin{align*}
	c'_{i+1} = \mathcal{H}_n(\mathfrak{m}, [r_i G + c_i K_i], [r_i \mathcal{H}_p(K_i) + c_i \tilde{K}])
	\end{align*}

	\item Se \(c_1 = c'_1\) allora la firma è valida.
\end{enumerate}

In questo schema sono memorizzati \(1 + n\) interi, viene prodotta un'immagine chiave EC e utilizzate \(n\) chiavi pubbliche.

È necessario\marginnote{src/crypto- note\_core/ cryptonote\_ core.cpp {\tt check\_tx\_ inputs\_key- images\_do- main()}} verificare che \(l \tilde{K} \stackrel{?}{=} 0\) affinché sia possibile aggiungere un punto EC dal sottogruppo di ordine \(h\) (il cofattore) a \(\tilde{K}\) e, se tutti i \(c_i\) sono multipli di \(h\) (cosa che potremmo ottenere tramite tentativi automatici con diversi valori di \(\alpha\) e \(r_i\)), generare \(h\) firme valide scollegate usando lo stesso anello e la stessa chiave di firma.\footnote{Non ci preoccupiamo dei punti provenienti da altri sottogruppi perché l'output di \(\mathcal{H}_n\) è limitato a \(\mathbb{Z}_l\). Per un ordine EC \(N = h l\), tutti i divisori di \(N\) (e quindi i possibili sottogruppi) sono o multipli di \(l\) (un primo) o divisori di \(h\).} Questo perché un punto EC moltiplicato per l'ordine del suo sottogruppo è zero.\footnote{Nella storia iniziale di Monero questo controllo non veniva effettuato. Fortunatamente, non è stato sfruttato prima che fosse implementata una correzione nell'aprile 2017 (versione 5 del protocollo) \cite{key-image-bug}.}

Per chiarire, dato un punto \(K\) nel sottogruppo di ordine \(l\), un punto \(K^h\) di ordine \(h\), e un intero \(c\) divisibile per \(h\):
\begin{align*}
    c*(K + K^h) &= cK + cK^h \\
                &= cK + 0
\end{align*}

È possibile dimostrare la correttezza (cioè il funzionamento) in modo simile al metodo utilizzato per lo schema di firma SAG.

Questa descrizione tenta di essere fedele alla spiegazione originale del bLSAG, che non include \(\mathcal{R}\) nella funzione hash che calcola \(c_i\). Includere le chiavi nell'hash è noto come `key prefixing'. Ricerche recenti \cite{key-prefix-paper} suggeriscono che potrebbe non essere necessario, anche se aggiungere il prefisso è prassi standard per schemi di firma simili (LSAG ad esempio usa il key prefixing).


\subsection*{Collegabilità}

Date due firme valide che differiscono in qualche modo (ad esempio risposte false differenti, messaggi diversi, membri complessivi del ring differenti):\vspace{.1cm}
\begin{align*}
	\sigma(\mathfrak{m})   &= (c_1, r_1, ..., r_n)\textrm{ con } \tilde{K}\textrm{, e}\\
	\sigma'(\mathfrak{m}')  &= (c_1', r'_1, ..., r'_{n'})\textrm{ con } \tilde{K}'\textrm{,}
\end{align*}
\quad Se \(\tilde{K} =  \tilde{K}'\) allora banalmente entrambe le firme derivano dalla stessa chiave privata.% perché $\tilde{K}= k_{\pi} \mathcal{H}_p(\mathcal{R})$.

Sebbene un osservatore possa collegare $\sigma$ e $\sigma'$, non saprebbe necessariamente a quale $K_i$ in $\mathcal{R}$ o $\mathcal{R}'$ corrisponda a meno che non ci fosse una sola chiave comune tra loro. Se ci fosse più di un membro comune del ring, la sua unica possibilità sarebbe risolvere il problema del logaritmo discreto o esaminare i ring in qualche modo (come imparare tutti i $k_i$ con $i \neq \pi$, o imparare $k_\pi$).\footnote{\label{lsag_unforgeable_note}LSAG, molto simile a bLSAG, è non falsificabile, cioè nessun attaccante può creare una firma valida senza conoscere la chiave privata. Se inventa un falso $\tilde{K}$ e avvia il calcolo della firma con $c_{\pi+1}$, allora, non conoscendo $k_\pi$, non può calcolare un numero $r_\pi = \alpha - c_\pi k_\pi$ che produca $[r_\pi G + c_\pi K_\pi] = \alpha G$. Un verificatore rifiuterebbe la firma. Liu {\em et al.} dimostrano che firme contraffatte in grado di passare la verifica sono estremamente improbabili \cite{Liu2004}.}



\section{Firme Multilivello MLSAG}
\label{sec:MLSAG}

Al fine di autorizzare correttamente una o più transazioni, occorre firmare con più chiavi private. In \cite{MRL-0005-ringct}, Shen Noether {\em et al.} descrivono una generalizzazione multilivello dello schema di firma bLSAG applicabile su un insieme di \(n \cdot m\) chiavi, overro l’insieme:\vspace{.175cm}
\[\mathcal{R} = \{K_{i,j}\}  \quad \textrm{con} \quad  i \in \{1, 2, ..., n\} \quad \textrm{e} \quad j \in \{1, 2, ..., m\}\]

Nel quale conosciamo le $m$ chiavi private \(\{k_{\pi, j}\}\) corrispondenti al sottoinsieme \(\{K_{\pi, j}\}\) per qualche indice \(i = \pi\). Tale algoritmo consente la generalizzazione della nozione di collegabilità (linkability):
\begin{description}
	\item[Collegabilità] Se una qualsiasi chiave privata \(k_{\pi, j}\) è usata in 2 firme differenti, allora queste firme sono collegate.
\end{description}


\subsection*{Firma}

\begin{enumerate}
	\item Calcolare le immagini delle chiavi \(\tilde{K_j} = k_{\pi, j} \mathcal{H}_p(K_{\pi, j})\) per ogni \(j \in \{1, 2, ..., m\}\).

	\item Generare numeri casuali  \(\alpha_j \in_R \mathbb{Z}_l\), e \(r_{i, j} \in_R \mathbb{Z}_l\) per \(i \in \{1, 2, ..., n\}\) (escluso \(i = \pi\)) e \(j \in \{1, 2, ..., m\}\).

	\item Calcolare\footnote{Monero\marginnote{src/ringct/ rctSigs.cpp {\tt MLSAG\_Gen()}} MLSAG usa il key prefixing. Ogni challenge contiene esplicitamente le chiavi pubbliche così (aggiungendo i termini $K$ assenti in bLSAG; le immagini delle chiavi sono incluse nel messaggio firmato):\vspace{-.25cm}
	\[c_{\pi+1} = \mathcal{H}_n(\mathfrak{m}, K_{\pi, 1}, [\alpha_1 G], [\alpha_1 \mathcal{H}_p(K_{\pi, 1})], ..., K_{\pi, m}, [\alpha_m G], [\alpha_m \mathcal{H}_p(K_{\pi, m})])
	\]}
	\[c_{\pi+1} = \mathcal{H}_n(\mathfrak{m}, [\alpha_1 G], [\alpha_1 \mathcal{H}_p(K_{\pi, 1})], ..., [\alpha_m G], [\alpha_m \mathcal{H}_p(K_{\pi, m})])\]

	\item Per \(i = \pi+1, \pi+2, ..., n, 1, 2, ..., \pi-1\) calcolare, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
	\[ c_{i+1} = \mathcal{H}_n(\mathfrak{m}, [r_{i, 1} G + c_i K_{i, 1}], [r_{i, 1} \mathcal{H}_p(K_{i, 1}) + c_i \tilde{K}_1], 
	..., [r_{i, m} G + c_i K_{i, m}], [r_{i, m} \mathcal{H}_p(K_{i, m}) + c_i \tilde{K}_m])\]

	\item Definire tutti i \(r_{\pi, j} = \alpha_j - c_\pi k_{\pi, j} \pmod l\).
\end{enumerate}

La firma prodotta è \(\sigma(\mathfrak{m}) = (c_1, r_{1, 1}, ..., r_{1, m}, ..., r_{n, 1}, ..., r_{n, m}) \), con immagini delle chiavi $(\tilde{K}_1, ...,  \tilde{K}_m)$.

%Un modo per pensare a MLSAG è che ci siano $m$ sotto-anelli di dimensione $n$, e in ogni sotto-anello conosciamo la chiave privata all’indice $i = \pi$ (in totale $m \cdot n$ chiavi pubbliche). L’algoritmo di firma lega insieme uno ‘stack’ di chiavi in ogni fase $c$, composto da una chiave per ciascun sotto-anello. bLSAG è il caso particolare con $m = 1$.


\subsection*{Verifica}

Per verificare la firma è necessario effettuare i seguenti passaggi:

\begin{enumerate}
    \item Per ogni \(j \in \{1,...,m\}\) controllare se \(l \tilde{K}_j \stackrel{?}{=} 0\).
    \item Per \(i = 1, ..., n\) calcolare, sostituendo \(n + 1 \rightarrow 1\),\vspace{.175cm}
    \begin{align*}
    c'_{i+1} = \mathcal{H}_n(\mathfrak{m}, [r_{i, 1} G + c_i K_{i, 1}], [r_{i, 1} \mathcal{H}_p(K_{i, 1}) + c_i \tilde{K}_1], 
    ..., [r_{i, m} G + c_i K_{i, m}], [r_{i, m} \mathcal{H}_p(K_{i, m}) + c_i \tilde{K}_m])
    \end{align*}

    \item Se \(c_1 = c'_1\) allora la firma è valida.
\end{enumerate}


\subsection*{Perché Funziona}

Proprio come nell’algoritmo SAG, è possibile notare che:

\begin{itemize}
    \item Se \(i \ne \pi \), allora i valori \(c'_{i + 1}\) sono calcolati come descritto nell’algoritmo di firma.

    \item Se \(i = \pi\) allora, dato che \(r_{\pi, j} = \alpha_j - c_\pi k_{\pi, j}\) termina il ciclo,\vspace{.175cm}
    \begin{alignat*}{6}
        r_{\pi, j} G + c_\pi K_{\pi,j} &= (\alpha_j - c_\pi k_{\pi, j}) G + c_\pi K_{\pi,j} = \alpha_j G\\
        \intertext{e}
        r_{\pi, j} \mathcal{H}_p(K_{\pi, j}) + c_\pi \tilde{K}_j &= (\alpha_j - c_\pi k_{\pi, j}) \mathcal{H}_p(K_{\pi, j}) + c_\pi \tilde{K}_j = \alpha_j \mathcal{H}_p(K_{\pi, j})\\
    \end{alignat*}
    In altre parole, vale anche che \(c'_{\pi + 1} = c_{\pi+1}\).
\end{itemize}


\subsection*{Collegabilità}

Se una chiave privata \(k_{\pi, j}\) viene riutilizzata per creare una firma, l’immagine della chiave corrispondente \(\tilde{K}_j\) fornita nella firma lo rivelerà. Questa osservazione coincide con la definizione generalizzata di linkabilità fornita precedentemente.\footnote{Come per bLSAG, le firme MLSAG collegate non indicano quale chiave pubblica sia stata usata per firmare. Tuttavia, se negli anelli dei sotto-cicli dell’immagine di chiave collegata c’è una sola chiave in comune, il colpevole è evidente. Se il colpevole viene identificato, tutti gli altri membri firmatari di entrambe le firme sono rivelati poiché condividono gli indici del colpevole.}


\subsection*{Requisiti di Memoria}

In questo schema sono memorizzati \(1 + m \cdot n\) interi, prodotte \(m\) immagini di chiavi EC, e usate \(m \cdot n\) chiavi pubbliche.



\section{Firme Concise CLSAG}
\label{sec:CLSAG}

CLSAG \cite{MRL-0011-CLSAG}\footnote{L’articolo su cui si basa questa sezione è un pre-print in fase di finalizzazione per revisione esterna. CLSAG è promettente come sostituto di MLSAG nelle future versioni del protocollo, ma non è stato ancora implementato e potrebbe non esserlo in futuro.} è una via di mezzo tra bLSAG e MLSAG. Supponiamo di avere una chiave \emph{primaria} e ad essa siano associate diverse chiavi \emph{ausiliarie}. È importante dimostrare la conoscenza di tutte le chiavi private, ma la collegabilità si applica solo alla primaria. Questa restrizione consente firme più piccole e veloci rispetto a MLSAG.

Come per MLSAG, si dispone di un insieme di \(n \cdot m\) chiavi (dove \(n\) è la dimensione dell’anello, \(m\) è il numero di chiavi da usare nella firma), e le chiavi primarie si trovano all’indice 1. In altre parole, ci sono \(n\) chiavi primarie, e la \(\pi\)\textsuperscipt{esima} di queste, insieme alle sue ausiliarie, verrà usata nella firma.\vspace{.175cm}
\[\mathcal{R} = \{K_{i,j}\} \quad \textrm{con} \quad i \in \{1, 2, ..., n\} \quad \textrm{e} \quad j \in \{1, 2, ..., m\}\]

Conosciamo le chiavi private \(\{k_{\pi, j}\}\) corrispondenti al sottoinsieme \(\{K_{\pi, j}\}\) per un certo indice \(i = \pi\).


\subsection*{Firma}

\begin{enumerate}
	\item Calcolare le immagini delle chiavi \(\tilde{K}_j = k_{\pi, j} \mathcal{H}_p(K_{\pi, 1})\) per ogni \(j \in \{1, 2, ..., m\}\). Si noti che la chiave base è sempre la stessa, quindi le immagini delle chiavi con \(j > 1\) sono dette `immagini delle chiavi ausiliarie'. Per semplicità verranno indicate tutte con \(\tilde{K}_j\).

	\item Generare numeri casuali \(\alpha \in_R \mathbb{Z}_l\) e \(r_i \in_R \mathbb{Z}_l\) per \(i \in \{1, 2, ..., n\}\) (eccetto \(i = \pi\)).

    \item Calcolare le chiavi pubbliche aggregate \(W_i\) per \(i \in \{1, 2, ..., n\}\), e l'immagine della chiave aggregata \(\tilde{W}\)\footnote{L'articolo CLSAG suggerisce di usare funzioni di hash diverse per la separazione del dominio, che modelliamo anteponendo a ogni hash un tag \cite{MRL-0011-CLSAG}, ad esempio \(T_1 =\) ``CLSAG\_1", \(T_c =\) ``CLSAG\_c", ecc. Le funzioni di hash separate per dominio producono output diversi anche con gli stessi input. Utilizziamo anche la prefissazione delle chiavi qui (inclusa \(\mathcal{R}\), che contiene tutte le chiavi, nell'hash). La separazione del dominio è una nuova politica per lo sviluppo di Monero, che sarà probabilmente applicata a tutte le future applicazioni delle funzioni hash (versione 13+). Gli usi storici probabilmente resteranno invariati.}
    \begin{align*}
    W_i &= \sum^{m}_{j=1} \mathcal{H}_n(T_j, \mathcal{R}, \tilde{K}_1,...,\tilde{K}_m) * K_{i,j}\\
    \tilde{W} &= \sum^{m}_{j=1} \mathcal{H}_n(T_j, \mathcal{R}, \tilde{K}_1,...,\tilde{K}_m) * \tilde{K}_j
    \end{align*}
    dove \(w_{\pi} = \sum_j \mathcal{H}_n(T_j, ...)*k_{\pi,j}\) è la chiave privata aggregata.

	\item Calcolare
	\[c_{\pi+1} = \mathcal{H}_n(T_c, \mathcal{R}, \mathfrak{m}, [\alpha G], [\alpha \mathcal{H}_p(K_{\pi, 1})])\]

	\item Per \(i = \pi+1, \pi+2, ..., n, 1, 2, ..., \pi-1\) calcolare, sostituendo \(n+1 \rightarrow 1\),\vspace{.175cm}
	\[c_{i+1} = \mathcal{H}_n(T_c, \mathcal{R}, \mathfrak{m}, [r_i G + c_i W_i], [r_i \mathcal{H}_p(K_{i,1}) + c_i \tilde{W}])\]

	\item Definire \(r_{\pi} = \alpha - c_{\pi} w_{\pi} \pmod l\).
\end{enumerate}

La firma prodotta è \(\sigma(\mathfrak{m}) = (c_1, r_1, ..., r_n)\), con immagine della chiave primaria \(\tilde{K}_1\) e immagini ausiliarie \((\tilde{K}_2, ..., \tilde{K}_m)\).


\subsection*{Verifica}

Per la verifica della firma è necessario effettuare i seguenti passaggi:

\begin{enumerate}
    \item Per ogni \(j \in \{1,...,m\}\) controllare \(l \tilde{K}_j \stackrel{?}{=} 0\).\footnote{In Monero si verifica solo \(l*\tilde{K}_1 \stackrel{?}{=} 0\) per l'immagine della chiave primaria. Le chiavi ausiliarie sono memorizzate come \((1/8)*\tilde{K}_j\), e durante la verifica moltiplicate per 8 (vedi Sezione \ref{elliptic_curves_section}), metodo più efficiente. La discrepanza è una scelta implementativa, dato che le immagini di chiavi linkabili sono molto importanti e non devono essere manipolate aggressivamente, mentre l'altro metodo è stato usato nelle versioni precedenti del protocollo.}

    \item Calcolare le chiavi pubbliche aggregate \(W_i\) per \(i \in \{1, ..., n\}\) e l'immagine aggregata \(\tilde{W}\)\vspace{.175cm}
    \begin{align*}
    W_i &= \sum^{m}_{j=1} \mathcal{H}_n(T_j, \mathcal{R}, \tilde{K}_1,...,\tilde{K}_m) * K_{i,j}\\
    \tilde{W} &= \sum^{m}_{j=1} \mathcal{H}_n(T_j, \mathcal{R}, \tilde{K}_1,...,\tilde{K}_m) * \tilde{K}_j
    \end{align*}

	\item Per \(i = 1, ..., n\) calcolare, sostituendo \(n+1 \rightarrow 1\),\vspace{.175cm}
	\[c_{i+1} = \mathcal{H}_n(T_c, \mathcal{R}, \mathfrak{m}, [r_i G + c_i W_i], [r_i \mathcal{H}_p(K_{i,1}) + c_i \tilde{W}])\]

	\item Se \(c_1 = c'_1\) allora la firma è valida.
\end{enumerate}


\subsection*{Perché Funziona}

Il pericolo principale nelle firme concise come questa è l'annullamento delle chiavi, che si verifica quando le immagini delle chiavi riportate non sono legittime, ma sommano comunque a un valore aggregato legittimo. Qui entrano in gioco i coefficienti di aggregazione \(\mathcal{H}_n(T_j, \mathcal{R}, \tilde{K}_1, ..., \tilde{K}_m)\), che fissano ogni chiave al valore atteso. Lasciamo al lettore l'esercizio di seguire le ripercussioni circolari del falsificare un'immagine chiave (magari iniziando con il supporre che quei coefficienti non esistano). Le immagini delle chiavi ausiliarie sono un artefatto della prova della legittimità dell'immagine primaria, dato che la chiave privata aggregata \(w_{\pi}\), che contiene tutte le chiavi private, è applicata al punto base \(\mathcal{H}_p(K_{\pi,1})\).


\subsection*{Collegabilità}

Se una chiave privata \(k_{\pi, 1}\) viene riutilizzata per creare una qualsiasi firma, l'immagine della chiave primaria corrispondente \(\tilde{K}_1\) fornita nella firma lo rivelerà. Le immagini delle chiavi ausiliarie sono ignorate, poiché esistono solo per facilitare la parte `Concisa' del CLSAG.


\subsection*{Requisiti di Memoria}

Sono memorizzati \((1 + n)\) interi, prodotte \(m\) immagini delle chiavi e utilizzate \(m \cdot n\) chiavi pubbliche.

%NOTA: in Monero la prefissazione delle chiavi CLSAG è un po' diversa.
%\[c_{i+1} = \mathcal{H}_n(T_c, indirizzi monouso, impegni in output, impegno pseudo output, \mathfrak{m}, [r_i G + c_i W_i], [r_i \mathcal{H}_p(K_{i,1}) + c_i \tilde{W}])\]