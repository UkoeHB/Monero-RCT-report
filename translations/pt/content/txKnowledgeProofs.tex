\chapter{Provas de conhecimento de transacções}
\label{chapter:tx-knowledge-proofs}
%original draft by Sarang Noether, Ph.D.

\iffalse
https://github.com/monero-project/monero/pull/6329/files

https://monero.stackexchange.com/questions/8122/what-is-the-spendproofv1-or-outproofv1-in-the-details-of-a-sent-transa

https://monero.stackexchange.com/questions/9991/how-does-the-get-reserve-proof-command-work

https://github.com/monero-project/research-lab/issues/68
\fi
Monero é uma cripto-moeda, e como qualquer moeda os seus usos são complexos. 
%Monero is a currency, and like any currency its uses are complex. 
Desde contabilidade empresarial, á presença na bolsa e arbitragem legal, diferentes entidades estão interessadas nas transacções efectuadas. 
%different interested parties may want to know detailed information about transactions made.
Como é possivel determinar que dinheiro recebido veio de uma pessoa específica? Ou como se prova que uma certa transacção foi efectuada para alguêm, apesar de acusações contrárias? Remetentes e destinatários no registro público de Monero são ambiguos. Visto que os montantes em Monero estão escondidos do público, como é possível provar a posse de um montante, sem que as chaves privadas sejam comprometidas? 
%How can you know for sure that money you received came from a specific person? Or prove that you did in fact send a certain output or transaction to someone despite claims to the contrary? Senders and recipients in the Monero public ledger are ambiguous. How can you prove you have a certain amount of money, without compromising your private keys? Amounts in Monero are completely hidden from observers.

São considerados diferentes tipos de asserções sobre transacções, algumas das quais estão implementadas em Monero e disponíveis com ferramentas da carteira. Apresentam-se também estruturas para auditar o saldo de uma pessoa ou organização, o que não requer vazar informação sobre transacções futuras.  

%We consider several types of transaction assertions, a few of which are implemented in Monero and available with built-in wallet tools. We also outline a framework for auditing the full balance owned by a person or organization, that doesn't require leaking information about future transactions they might make.



\section{Provas de transacção em Monero}
\label{sec:proofs-monero-proofs}

As provas de transacção em Monero estão no processo de serem renovadas \cite{sarang-txproofs-updates-issue}. As provas actualmente implementadas são todas `versão 1', e não incluem a separação de domínios. Aqui só irão ser descritas as provas mais avancadas, porque estão implementadas, poderão ser implementadas \cite{sarang-txproofs-v2-update-pr}, ou provas hipotéticas que servem só de teoria (secções \ref{subsec:proofs-owned-output-spent-unspentproof} \cite{unspent-proof-issue-68}, e \ref{subsec:proofs-address-subaddress-correspond-subaddressproof}).

%Monero transaction proofs are in the process of being updated \cite{sarang-txproofs-updates-issue}. The currently implemented proofs are all `version 1', and don't include domain separation. We describe only the most advanced proofs, whether they be currently implemented, slated for implementation in future releases \cite{sarang-txproofs-v2-update-pr}, or hypothetical proofs that may or may not get implemented (Sections \ref{subsec:proofs-owned-output-spent-unspentproof} \cite{unspent-proof-issue-68}, and \ref{subsec:proofs-address-subaddress-correspond-subaddressproof}).


\subsection{Provas de transacção com múltiplas bases}
\label{subsec:proofs-multi-base-monero}

Existem alguns detalhes a ter em conta ao prosseguir. A maioria das provas de transacção em Monero involvem provas com múltiplas bases (secção \ref{sec:proofs-discrete-logarithm-multiple-bases}). Sempre que relevante o separador de domínio é : 
\begin{align*}
T_{txprf2} = \mathcal{H}_n(``\textrm{TXPROOF\_V2}").
\end{align*}
%??? separador de domínio
A mensagem que é assinada é usualmente (salvo indicação em contrário) : 
\begin{align*}
\mathfrak{m} = \mathcal{H}_n(\texttt{tx\_hash, \texttt{message}}).
\end{align*}
Em que {\tt tx\_hash} é a ID de transacção relevante (
%secção \ref{subsec:transaction-id}
) 
e {\tt message} é uma mensagem opcional que os provadores ou entidades terceiras podem fornecer para dar a certeza que a prova foi de facto feita e não roubada \footnote{Bem como na secção \ref{sec:CLSAG}, funções hash deviam ter um separador de domínio, através de um prefixo com tags. As provas de transacção actualmente implementadas em Monero não têm nenhuma separação de domínio. Portanto todos os tags neste capítulo são características ainda {\em não} implementadas.} .  
%There are a few details to be aware of going forward. Most Monero transaction proofs involve multi-base proofs (recall Section \ref{sec:proofs-discrete-logarithm-multiple-bases}). Wherever relevant, the domain separator is $T_{txprf2} = \mathcal{H}_n(``\textrm{TXPROOF\_V2}")$.
%Just like in Section \ref{sec:CLSAG}, hash functions should be domain separated by prefixing them with tags. The current Monero transaction proofs implementation has no domain separation, so all the tags in this chapter are in features {\em not} yet implemented.} 

%The message being signed\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} is usually (unless otherwise specified) $\mathfrak{m} = \mathcal{H}_n(\texttt{tx\_hash, \texttt{message}})$, where {\tt tx\_hash} is the relevant transaction's ID (Section \ref{subsec:transaction-id}), and {\tt message} is an optional message that provers or third parties can provide to make sure the prover actually makes a proof and hasn't stolen it.

As provas estão codificadas em base-58, um esquema de código de binário para texto, primeiro introduzido para Bitcoin \cite{base-58-encoding}. Verificar estas provas envolve sempre primeiro descodificar da base-58 de volta a binário. Note-se que os verificadores também precisam de ter acesso á lista de blocos, para que através da ID de transacção possam extraír informação como endereços ocultos.
\footnote{Os ID's de transacção são usualmente comunicados separadamente das provas.}
%Transaction IDs are usually communicated separately from proofs.}
 
%Proofs are encoded in base-58, a binary-to-text encoding scheme first introduced for Bitcoin \cite{base-58-encoding}. Verifying these proofs always involves first decoding them from base-58 back to binary. Note that verifiers also need access to the blockchain, so they can use transaction ID references to get information like one-time addresses.\footnote{Transaction IDs are usually communicated separately from proofs.}

A estrutura de prefixo de chave em provas está algo torta, em parte por causa de desenvolvimentos acumulados que ainda não reorganizaram isto. Desafios para provas, base-2 `versão 2', são construídas com este formato, em que se `chave 1 base' é $G$ então a sua posição no desafio é preenchida com 32 bytes de zero.  

%The structure of key prefixing in proofs is somewhat lopsided, due in part to accumulating updates that haven't reorganized it. Challenges for 2-base `version 2' proofs are assembled with this format, where if `base key 1' is $G$ then its position in the challenge is filled with 32 zero bytes,
\vspace{.175cm}
\begin{align*}
c = \mathcal{H}_n(\mathfrak{m}\textrm{, chave pública 2, prova parte 1, prova parte 2, $T_{txprf2}$,}\\ \textrm{chave pública 1, chave base 2, chave base 1}) .
\end{align*}

%\[c = \mathcal{H}_n(\mathfrak{m}\textrm{, chave pública 2, prova parte 1, prova parte 2, $T_{txprf2}$, chave pública 1, chave base 2, chave base 1})\]


\subsection{Provar a criação de uma entrada de transacção ({\tt SpendProofV1})}
\label{subsec:proofs-input-creation-spendproof}

Seja que um remetente fez uma transacção, e agora precisa de o provar. Claramente, ao refazer a assinatura á entrada de transacção numa outra mensagem, qualquer verificador teria de concluír que o remetente também fez a assinatura original. Ao refazer {\em todas} as assinaturas para cada entrada de uma transacção significa que o remetente tem de ter feito a transacção inteira.
\newline Alguêm que fez uma assinatura a uma entrada, não implica que tenha assinado todas as entradas (capítulo \ref{chapter:txtangle}). 
%??? or at the very least fully funded it. Não é o mesmo?  

%Suppose we made a transaction, and want to prove it. Clearly, by remaking a transaction input's signature on a new message, any verifier would have no choice but to conclude we made the original. Remaking {\em all} of a transaction's inputs' signatures means we must have made the entire transaction (recall Section \ref{full-signature}), or at the very least fully funded it.
\footnote{Como veremos no capítulo \ref{chapter:txtangle}, alguêm ter assinado uma entrada não implica que tenha assinado todas as entradas.} 
%As we will see in Chapter \ref{chapter:txtangle}, someone who made one input signature didn't necessarily make all input signatures.}

Uma assim chamada `SpendProof' (do inglés : {\em prova de gasto}) \marginnote{src/wallet/ wallet2.cpp {\tt get\_spend\_ proof()}} contêm novas assinaturas para cada entrada de transacção. Importante é que a prova de gasto re-utiliza os membros de anel originais para evitar a identificação do verdadeiro signatário através da intersecção de aneis.

%A so-called `SpendProof'\marginnote{src/wallet/ wallet2.cpp {\tt get\_spend\_ proof()}} contains remade signatures for all of a transaction's inputs. Importantly, SpendProof ring signatures re-use the original ring members to avoid identifying the true signer via ring intersections.

Provas de gasto são implementadas em Monero, o provador concatena o prefixo ``{\tt SpendProofV1}" com a lista de assinaturas. Note-se que este prefixo está em texto claro e não encriptado visto que o seu propósito é de ser lido por uma pessoa.
 
%SpendProofs are implemented in Monero, and to encode one for transmission to verifiers, the prover concatenates the prefix string ``{\tt SpendProofV1}" with the list of signatures. Note that the prefix string is not in base-58 and doesn't need to be encoded/decoded, since its purpose is human readability.%what about the message signed?

\subsubsection*{Prova de gasto}

Provas de gasto inesperadamente não utilizam MLSAG, mas o esquema original de assinaturas em anel que foi utilizado no primeiro protocolo de transacção (pre-RingCT) \cite{cryptoNoteWhitePaper}. 

%SpendProofs unexpectedly don't use MLSAGs, but rather Monero's original ring signature scheme \marginnote{src/crypto/ crypto.cpp {\tt generate\_ ring\_signa- ture()}} that was used in the very first transaction protocol (pre-RingCT) \cite{cryptoNoteWhitePaper}.

\begin{enumerate}
	\item Calcule a imagem de chave \(\tilde{K} = k^o_\pi \mathcal{H}_p(K^o_\pi)\).

	\item Gera-se o número aleatório \(\alpha \in_R \mathbb{Z}_l\) e  \(c_i, r_i \in_R \mathbb{Z}_l\) para cada \(i \in \{1, 2, ..., n\}\) mas excluíndo \(i = \pi\).

	\item Computa-se
	\[c_{tot} = \mathcal{H}_n(\mathfrak{m},[r_1 G + c_1 K^o_1],[r_1 \mathcal{H}_p(K^o_1) + c_1 \tilde{K}],...,[\alpha G],[\alpha \mathcal{H}_p(K^o_{\pi})],...,\textrm{etc.})\]

	\item Define-se o desafio verdadeiro
	\[c_{\pi} = c_{tot} - \sum^{n}_{i=1,i\neq \pi} c_i\]

	\item Define-se \(r_{\pi} = \alpha - c_{\pi}*k^o_{\pi} \pmod l\).
\end{enumerate}

A assinatura é :
\begin{align*}
\sigma = (c_1, r_1,c_2,r_2,...,c_n,r_n).
\end{align*}

\subsubsection*{Verificação}

Para verificar \marginnote{src/wallet/ wallet2.cpp {\tt check\_spe- nd\_proof()}} uma prova de gasto de uma dada transacção, o verificador confirma que todas as assinaturas em anel são válidas usando informação encontrada na transacção original em questão (imagens de chave, offsets de saída etc)

%To verify\marginnote{src/wallet/ wallet2.cpp {\tt check\_spe- nd\_proof()}} a SpendProof on a given transaction, the verifier confirms that all ring signatures are valid using information found in the relevant reference transaction (e.g. key images, and output offsets for getting one-time addresses from other transactions).

\begin{enumerate}
	\item Compute-se
	\[c_{tot} = \mathcal{H}_n(\mathfrak{m},[r_1 G + c_1 K^o_1],[r_1 \mathcal{H}_p(K^o_1) + c_1 \tilde{K}],...,[r_n G + c_n K^o_n],[r_n \mathcal{H}_p(K^o_n) + c_n \tilde{K}])\]

	\item Verifica-se que 
	\[c_{tot} \stackrel{?}{=} \sum^{n}_{i=1} c_i\]
\end{enumerate}

\subsubsection*{Funciona porque}

Note-se como este esquema é o mesmo como o bLSAG (Secção \ref{blsag_note}) quando só existe um membro de anel. Para adicionar um membro desvio, em vez de pôr o desafio $c_{\pi+1}$ dentro de uma nova hash de desafio, o membro é adicionado para a hash original. Como a equação seguinte :
\begin{align*}
c_{s} = c_{tot} - \sum^{n}_{i=1,i\neq s} c_i
\end{align*}
é verdade para cada index $s$, um verificador não terá forma de identificar o desafio verdadeiro. Para mais, sem o conhecimento de $k^o_{\pi}$ o provador não teria conseguido definir $r_{\pi}$ .

%Note how this scheme is the same as bLSAG (Section \ref{blsag_note}) when there is only one ring member. To add a fake member, instead of passing the challenge $c_{\pi+1}$ into a new challenge hash, the member gets added into the original hash. Since the following equation\vspace{.175cm}
%\[c_{s} = c_{tot} - \sum^{n}_{i=1,i\neq s} c_i\]

%trivially holds for any index $s$, a verifier will have no way to identify the real challenge. Moreover, without knowledge of $k^o_{\pi}$ the prover would never have been able to define $r_{\pi}$ properly (except with negligible probability).


\subsection{Provar a criação de uma saída de transacção ({\tt OutProofV2})}
\label{subsec:proofs-output-creator-outproof}

Agora suponha-se que um remetente enviou dinheiro a alguêm (uma saída) e quer prová-lo. 
Saídas de transacção contêm principalmente 3 componentes : o endereço do destinatário, o montante enviado e a chave privada de transacção. Os montantes estão em código, portanto só é necessário o endereço e a chave privada de transacção. Se a chave privada de transacção é perdida será impossivel fazer uma prova de saída.   
%Now suppose we sent someone money (an output) and want to prove it. Transaction outputs contain at heart three components: the recipient's address, the amount sent, and the transaction private key. Amounts are encoded, so we only really need the address and transaction private key to get started. Anyone who deletes or loses their transaction private key will be unable to make an OutProof, so in that sense OutProofs are the least reliable of all Monero transaction proofs.
\footnote{Uma `prova de saída' (OutProof) que mostra que uma saída de transacção, {\em saí} do provador. Uma `prova de entrada' (secção \ref{subsec:proofs-output-ownership-inproof}) mostra que uma saída de transacção, {\em entra} para o endereço do provador.}
%We can think of an `OutProof' as showing an output is `outgoing' from the prover. The corresponding `InProofs' (Section \ref{subsec:proofs-output-ownership-inproof}) show outputs that are `incoming' to the prover's address.}

A tarefa aqui é de mostrar que o endereço oculto foi feito pelo endereço do destinatário, e deixar que verificadores reconstruam o compromisso de saída. Isto é feito começando pelo segredo partilhado entre o remetente e o destinatário : 
\begin{align*}
rK^v .
\end{align*}
Prova-se a criação do mesmo, e que corresponde á chave pública de transacção e ao endereço do destinatário. Isto é conseguido ao fazer uma assinatura com duas bases, nomeadamente $G$ e $K^v$. Os verificadores usam o segredo partilhado para verificar o recipiente \marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}} (secção \ref{sec:one-time-addresses})\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}}, descodificar o montante (secção \ref{sec:pedersen_monero}), e reconstruir o compromisso de saída (secção \ref{sec:pedersen_monero}). São presentados aqui detalhes para endereços normais bem como para sub-endereços.   
%Our task here is to show the one-time address was made from the recipient's address, and allow verifiers to reconstruct the output commitment. We do so by providing the sender-receiver shared secret $rK^v$, then proving we created it and that it corresponds with the transaction public key and recipient's address by signing a 2-base signature (Section \ref{sec:proofs-discrete-logarithm-multiple-bases}) on the base keys $G$ and $K^v$. Verifiers can use the shared secret to check the recipient
%\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}} (Section \ref{sec:one-time-addresses}), decode the amount (Section \ref{sec:pedersen_monero}), and reconstruct the output commitment (Section \ref{sec:pedersen_monero}). We provide details for both normal addresses and subaddresses.

\subsubsection*{Prova de saída ({\tt OutProof}) }

Para gerar uma prova de saída \marginnote{src/crypto/ crypto.cpp {\tt generate\_ tx\_proof()}}dirigida a um endereço 
\begin{align*}
(K^{s}, K^{v})
\end{align*}
ou a um sub-endereço
\begin{align*}
(K^{s,i}, K^{v,i})
\end{align*}
com uma chave privada de transacção $r$ em que o segredo partilhado entre o remetente e o destinatário é $rK^v$. Note-se que uma chave pública de transacção guardada nos dados de transacção é $rG$ para um endereço normal ou então $rK^{s,i}$ para um sub-endereço.

%To generate\marginnote{src/crypto/ crypto.cpp {\tt generate\_ tx\_proof()}} a proof for an output directed to an address $(K^{v},K^{s})$ or subaddress $(K^{v,i},K^{s,i})$, with transaction private key $r$, where the sender-receiver shared secret is $rK^v$, recall that the transaction public key stored in transaction data is either $rG$ or $rK^{s,i}$ depending on whether or not the recipient is a subaddress (Section \ref{sec:subaddresses}).

\begin{enumerate}
	\item Gera-se um número aleatório $\alpha \in_R \mathbb{Z}_l$, e calcula-se
	\begin{enumerate}
	    \item {\em Endereço normal}: $\alpha G$ e $\alpha K^v$
	    \item {\em Sub-endereço}: $\alpha K^{s,i}$ e $\alpha K^{v,i}$
	\end{enumerate}{}
	\item Calcula-se o desafio
	\begin{enumerate}
	    \item {\em Endereço normal}:\footnote{Aqui o valor `0' são 32 bytes a zero.}
	    \[c = \mathcal{H}_n(\mathfrak{m},[rK^v], [\alpha G], [\alpha K^v], [T_{txprf2}], [rG], [K^v], [0])\]
	    \item {\em Sub-endereço}:
	    \[c = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [\alpha K^{s,i}], [\alpha K^{v,i}], [T_{txprf2}], [rK^{s,i}], [K^{v,i}], [K^{s,i}])\]
	\end{enumerate}{}
	\item Define-se a resposta\footnote{Due to the limited number of available symbols, we unfortunately used $r$ for both responses and the transaction private key. Superscript `resp' for `response' will be used to differentiate the two when necessary.} $r^{resp} = \alpha - c*r$.
	\item A assinatura é : $\sigma^{outproof} = (c, r^{resp})$.
\end{enumerate}{}

Um provador \marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} gera várias {\em OutProofs}, e envia estas para o verificador. Ele concatena o string prefixo ``{\tt OutProofV2}" com a lista de provas, em que cada item (codificado na base-58) consiste no segredo partilhado entre o remetente e o destinatário $r K^v$ (ou $r K^{v,i}$ para um sub-endereço), e o correspondente $\sigma^{outproof}$. Assume-se que o verificador sabe o endereço respectivo para cada prova.
%A prover\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} can generate a bunch of OutProofs, and send them all together to a verifier. He concatenates prefix string ``{\tt OutProofV2}" with a list of proofs, where each item (encoded in base-58) consists of the sender-receiver shared secret $r K^v$ (or $r K^{v,i}$ for a subaddress), and its corresponding $\sigma^{outproof}$. We assume the verifier knows the appropriate address for each proof.

\subsubsection*{Verificação}

\begin{enumerate}
    \item Calcula-se o desafio\marginnote{src/crypto/ crypto.cpp {\tt check\_tx\_ proof()}}
    \begin{enumerate}
        \item {\em Endereço normal}:\vspace{.145cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^v], [r^{resp} G + c*r G], [r^{resp} K^v + c*r K^v], [T_{txprf2}], [rG], [K^v], [0])\]
	    \item {\em Sub-endereço}:\vspace{.16cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [r^{resp} K^{s,i} + c*r K^{s,i}], [r^{resp} K^{v,i} + c*r K^{v,i}], [T_{txprf2}], [rK^{s,i}], [K^{v,i}], [K^{s,i}])\]
    \end{enumerate}{}
    \item Se $c = c'$ então o provador sabe $r$, e $rK^v$ é um segredo partilhado legítimo entre $r G$ e $K^v$ (enp).    
%then the prover knows $r$, and $rK^v$ is legitimately a shared secret between $r G$ and $K^v$ (except with negligible probability).
    \item O verificador devia verificar que o dado endereço do destinatário pode ser usado para criar um endereço oculto a partir da transacção relevante (trata-se da mesma computação para endereços normais bem como para sub-endereços)   
%The\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ key\_hel- per()}} verifier should check the recipient's address provided can be used to make a one-time address from the relevant transaction (it's the same computation for normal addresses and subaddresses)
    \[K^s \stackrel{?}{=} K^o_t - \mathcal{H}_n(r K^v,t)\]
    \item Eles também deviam descodificar o montante $b_t$, calcular a máscara $y_t$, e tentar reconstruir o compromisso de saída correspondente. 
%They should also decode the output amount $b_t$, compute the output mask $y_t$, and try to reconstruct the corresponding output commitment
\footnote{Uma prova de saída válida não significa necessáriamente que o destinatário considerado, é o destinatário verdadeiro. Um provador malicioso podia gerar uma chave de ver aleatória $K'^v$, calcular $K'^s = K^o - \mathcal{H}_n(rK'^v,t)*G$, e oferecer $(K'^s, K'^v)$ como o recipiente nominal. Ao recalcular o compromisso de saída, os verificadores podem ter mais confiança que o endereço de destinatário em questão é legítimo. Contudo, um provador e um destinatário podiam colaborar para codificar o compromisso de saída usando $K'^v$, enquanto que o endereço oculto usa $(K^s, K^v)$. Desde que o destinatário teria de saber a chave privada $k'^v$ (assumindo que o montante na saída ainda é suposto de ser gasto), é questionável o qual a utilidade para esse tipo de decepção. Porque que o destinatário não usaria simplesmente $(K'^s, K'^v)$ (ou outro endereço) para a saída inteira? Desde que a computação de $C^b_t$ está relacionada com o recipiente, considera-se o processo de verificação {\em OutProof} adequado. Por outras palavras, neste processo, o provador não pode enganar os verificadores sem uma coordinação com o destinatário.}\vspace{.175cm}
%A valid OutProof signature doesn't necessarily mean the recipient considered is the real recipient. A malicious prover could generate a random view key $K'^v$, compute $K'^s = K^o - \mathcal{H}_n(rK'^v,t)*G$, and provide $(K'^v,K'^s)$ as the nominal recipient. By recalculating the output commitment, verifiers can be more confident the recipient address in question is legitimate. However, a prover and recipient could collaborate to encode the output commitment using $K'^v$, while the one-time address uses $(K^v,K^s)$. Since the recipient would need to know the private key $k'^v$ (assuming the output amount is still meant to be spendable), there is questionable utility to that level of deception. Why wouldn't the recipient just use $(K'^v,K'^s)$ (or some other single-use address) for the entire output? Since the computation of $C^b_t$ is related to the recipient, we consider the described OutProof verification process adequate. In other words, the prover can't use it to deceive verifiers without coordinating with the recipient.}\vspace{.175cm}
    \[C^b_t \stackrel{?}{=} y_t G + b_t H\]
\end{enumerate}{}


\subsection{Provar a posse de uma saída ({\tt InProofV2})}
\label{subsec:proofs-output-ownership-inproof}

Uma prova de saída ({\em OutProof}) mostra que o provador enviou uma saída para um endereço, enquanto que uma prova de entrada ({\em InProof}) mostra que uma saída foi recebida por um certo endereço. É essencialmente o outro `lado' do segredo partilhado entre o remetente e o destinatário, $r K^v$. Desta vez o provador prova conhecimento de $k^v$ em $K^v$, e que em combinação com a chave pública $r G$, apareçe o segredo partilhado, $k^v*r G$. 
%An OutProof shows the prover sent an output to an address, while an InProof shows an output was received to a certain address. It is essentially the other `side' of the sender-receiver shared secret $r K^v$. This time the prover proves knowledge of $k^v$ in $K^v$, and that in combination with the transaction public key $r G$ the shared secret $k^v*r G$ appears.

Uma vez que o verificador tem $r K^v$, ele verifica se o endereço oculto correspondente é possuído pelo endereço do provador através de : 
\begin{align*}
K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s .
\end{align*}
Ao fazer uma prova de entrada para cada chave pública de transacção na lista de blocos, o provador revela todas as saídas que possui.%Once a verifier has $r K^v$, they can check if the corresponding one-time address is owned by the prover's address with\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}} $K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s$ (Section \ref{sec:multi_out_transactions}). By making an InProof for all transaction public keys on the blockchain, a prover will reveal all his owned outputs.
Dar a chave de ver directamente ao verificador têm o mesmo efeito, mas com a diferença de que o verificador seria também capaz de identificar a posse de saídas criadas no futuro. Com as provas de entrada o provador retêm o controlo das suas chaves privadas, ao custo do tempo que leva a provar e verificar se cada saída lhe pertence ou não.
%Giving the view key directly to a verifier would have the same effect, but once they have that key the verifier would be able to identify ownership of outputs to be created in the future. With InProofs the prover is able to retain control of his private keys, at the cost of the time it takes to prove (and then verify) each output is owned or unowned.

\subsubsection*{A prova de entrada ({\tt InProof})}

Uma prova de entrada, é construída da mesma forma que uma prova de saída, excepto que as chaves base agora são : 
\begin{align*}
\mathcal{J} = \{G, r G\} ,
\end{align*}
as chaves públicas são :
\begin{align*}
\mathcal{K} = \{K^v, r K^{v}\} ,
\end{align*}
e a chave signatária é : $k^v$ (em vez de ser $r$). Mostra-se só o passo de verificação para clarificar o que isto significa. Note-se que a ordem do prefixo de chave muda, $r G$ e $K^v$ trocam de posições para coincidir com a função que têm.%An InProof is constructed the same way as an OutProof\marginnote{src/crypto/ crypto.cpp {\tt generate\_ tx\_proof()}}, except the base keys are now $\mathcal{J} = \{G, r G\}$, the public keys are $\mathcal{K} = \{K^v, r K^{v}\}$, and the signing key is $k^v$ instead of $r$. We will show just the verification step to clarify our meaning. Note that the order of key prefixing changes ($r G$ and $K^v$ swap places) to coincide with the different role each key has.
É possivel enviar uma multitude de provas de entrada ao verificador, estas são respectivas a várias saídas possuídas pelo mesmo endereço.\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} Estas provas tem o prefixo ``{\tt InProofV2}", e cada uma delas (codificada na base-58) contêm o segredo partilhado entre o destinatário e o remetente $r K^v$ (ou $r K^{v,i}$), e a prova de entrada $\sigma^{inproof}$.     
%A multitude of InProofs, related to many outputs owned by the same address, can be sent together to the verifier.\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} They are prefixed with the string ``{\tt InProofV2}", and each item (encoded in base-58) contains the sender-receiver shared secret $r K^v$ (or $r K^{v,i}$), and its corresponding $\sigma^{inproof}$.
\subsubsection*{Verificação}

\begin{enumerate}
    \item Calcula-se o desafio\marginnote{src/crypto/ crypto.cpp {\tt check\_tx\_ proof()}}
    \begin{enumerate}
        \item {\em Endereço normal}:\vspace{.145cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^v], [r^{resp} G + c*K^v], [r^{resp}*r G + c*k^v*r G], [T_{txprf2}], [K^v], [rG], [0])\]
	    \item {\em Sub-endereço}:\vspace{.16cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [r^{resp} K^{s,i} + c*K^{v,i}], [r^{resp}*r K^{s,i} + c*k^v*r K^{s,i}], [T_{txprf2}], [K^{v,i}], [r K^{s,i}], [K^{s,i}])\]
    \end{enumerate}{}
    \item Se $c = c'$ então o provador sabe que $k^v$ e $k^v*r G$ é um segredo partilhado entre $K^v$ e $r G$ (enp). 
%then the prover knows $k^v$, and $k^v*r G$ is legitimately a shared secret between $K^v$ and $r G$ (except with negligible probability).
\end{enumerate}{}

\subsubsection*{Provar a posse de uma saída através do endereço oculto}

Enquanto que uma prova de entrada mostra que um endereço oculto foi construído por um endereço específico, isso não quer dizer que o provador possa {\em gastar} essa saída. Só quem pode gastar uma saída realmente a possuí.  

%While an InProof shows a one-time address was constructed with a specific address (except with negligible probability), it doesn't necessarily mean the prover can {\em spend} that output. Only those who can spend an output actually own it.

Provar a posse de uma saída, uma vez que a prova de entrada está completa, é tão simples como assinar uma mensagem com a {\em chave de gasto}.

%Proving ownership, once an InProof is complete, is as simple as signing a message with the spend key.
\footnote{A possibilidade de oferecer tal assinatura directamente não existe em Monero. Mas como veremos isto está incluido na prova de reserva {\em ReserveProofs} (secção \ref{subsec:proofs-minimum-balance-reserveproof}).}   
%The ability to provide such a signature directly does not seem to be available in Monero, although as we will see ReserveProofs (Section \ref{subsec:proofs-minimum-balance-reserveproof}) do include them.}

\subsection{Prova de não-gasto de uma saída numa transacção}
\label{subsec:proofs-owned-output-spent-unspentproof}

Para provar que uma saída está gasta ou não gasta pode-se recriar a imagem de chave com uma prova de múltiplas bases em :
\begin{align*}
\mathcal{J} = \{G,\mathcal{H}_p(K^o)\}
\end{align*}
e :
\begin{align*}
\mathcal{K} = \{K^o,\tilde{K}\}.
\end{align*}
Enquanto que isto funciona, os verificadores têm de descobrir a {\em imagem de chave}, o que também revela quando uma saída não gasta irá ser gasta no futuro.

%It would seem like proving an output is spent or unspent is as simple as recreating its key image with a multi-base proof on $\mathcal{J} = \{G,\mathcal{H}_p(K^o)\}$ and $\mathcal{K} = \{K^o,\tilde{K}\}$. While this does obviously work, verifiers must learn the key image, which also reveals when an unspent output is spent {\em in the future}.
Acontece que pode-se provar que uma saída não foi gasta numa transacção específica sem revelar a imagem chave. Para além disso pode-se provar que a saída actualmente não está gasta, ao extender esta prova de não-gasto \cite{unspent-proof-issue-68} a `todas as transacções em que esta saída foi incluída como membro de anel'.

%It turns out we can prove an output wasn't spent in a specific transaction without revealing the key image. Moreover, we can prove it is currently unspent {\em full stop}, by extending this UnspentProof \cite{unspent-proof-issue-68} to `all the transactions where it was included as a ring member'.
\footnote{Provas de não-gasto não estão implementadas em Monero}

Mais específicamente, as provas de não-gasto revelam que uma dada imagem de chave de uma transacção na lista de blocos corresponde ou não a um endereço oculto específico do seu anel correspondente. 

%More specifically, our UnspentProof says that a given key image from a transaction on the blockchain does, or does not, correspond with a specific one-time address from its corresponding ring. Incidentally, as we will see, UnspentProofs go hand-in-hand with InProofs.

\subsubsection*{Construir uma prova de não-gasto ({\tt UnspentProof})}

O verificador de uma prova de não-gasto tem de saber $r K^v$, o segredo partilhado entre remetente e destinatário de uma dada saída com o endereço oculto $K^o$ e a chave pública de transacção $r G$. Ele sabe a chave de ver $k^v$, que lhe permitiu calcular :
\begin{align*}
k^v*r G
\end{align*}
e verificar :
\begin{align*}
K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s
\end{align*}
e desta forma ele sabe que a saída em questão pertence ao provador (secção \ref{sec:one-time-addresses}).

Ou o provador forneceu $r K^v$. É aqui que as provas de entradas são usadas, pois com uma prova de entrada o verificador pode estar assegurado que $r K^v$ veio da chave de ver do provador. E que corresponde com uma saída lhe pertencente sem que a chave privada de ver tenha sido fornecida.

%The verifier of an UnspentProof must know $r K^v$, the sender-receiver shared secret for a given owned output with one-time address $K^o$ and transaction public key $r G$. He either knows the view key $k^v$, which allowed him to calculate $k^v*r G$ and check $K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s$ so he knows the output being tested belongs to the prover (recall Section \ref{sec:one-time-addresses}), or the prover provided $r K^v$. This is where InProofs come in, since with an InProof the verifier can be assured $r K^v$ legitimately came from the prover's view key, and corresponds with an owned output, without learning the private view key.
Antes de mais, um verificador irá descobrir a imagem de chave a ser testada $\tilde{K}_?$, e verifica que o anel correspondente inclui um endereço oculto $K^o$, que possui uma saída pertencente ao provador. Ele depois calcula a imagem parcial de {\em gasto} $\tilde{K}^s_?$.
\begin{align*}
\tilde{K}^s_? = \tilde{K}_? - \mathcal{H}_n(r K^v,t)*\mathcal{H}_p(K^o)
\end{align*}
%Before verifying an UnspentProof, the verifier will learn the key image to be tested $\tilde{K}_?$, and checks that its corresponding ring includes the prover's owned output's one-time address $K^o$. He then calculates the partial `spend' image $\tilde{K}^s_?$.\vspace{.175cm}
%\[\tilde{K}^s_? = \tilde{K}_? - \mathcal{H}_n(r K^v,t)*\mathcal{H}_p(K^o)\]

Se a imagem de chave em questão foi criada com $K^o$ então o ponto resultante irá ser :
\begin{align*}
\tilde{K}^s_? = k^s*\mathcal{H}_p(K^o).
\end{align*}

%If the tested key image was created from $K^o$ then the resultant point will be $\tilde{K}^s_? = k^s*\mathcal{H}_p(K^o)$.

%\subsubsection*{}

O provador cria duas provas de múltipla-base (secção \ref{sec:proofs-discrete-logarithm-multiple-bases}). O seu endereço, que possui a saída em questão é $(K^v, K^s)$ or $(K^{v,i}, K^{s,i})$. Provas de não-gasto são feitas da mesma forma para endereços normais como para sub-endereços. A chave de gasto do sub-endereço é necessária, ou seja : 
\begin{align*}
k^{s,i} = k^s + \mathcal{H}_n(k^v,i) \ref{sec:subaddresses}
\end{align*}

%Our prover creates two multi-base proofs (recall Section \ref{sec:proofs-discrete-logarithm-multiple-bases}). His address, which owns the output in question, is $(K^v, K^s)$ or $(K^{v,i}, K^{s,i})$.\footnote{UnspentProofs are made the same way for subaddresses and normal addresses. The full spend key of a subaddress is required, e.g. $k^{s,i} = k^s + \mathcal{H}_n(k^v,i)$ (Section \ref{sec:subaddresses}).}
\iffalse
\begin{enumerate}
    \item Uma prova com 3 bases, em que a chave signatária é $k^s$, e\vspace{.175cm}  
    \begin{align*}
        \mathcal{J}^{\textrm{nãogasto}}_3 &= \{[G], [K^s], [\tilde{K}^s_?]\}\\
        \mathcal{K}^{\textrm{nãogasto}}_3 &= \{[K^s], [k^s*K^s], [k^s*\tilde{K}^s_?]\}
    \end{align*}{}
    \item Uma prova com 2 bases, em que a chave signatária é $k^s*k^s$, e\vspace{.175cm}
    \begin{align*}
        \mathcal{J}^{\textrm{nãogasto}}_2 &= \{[G], [\mathcal{H}_p(K^o)]\}\\
        \mathcal{K}^{\textrm{nãogasto}}_2 &= \{[k^s*K^s], [k^s*k^s*\mathcal{H}_p(K^o)]\}
    \end{align*}{}
\end{enumerate}{}
\fi
Juntamente com as provas $\sigma^{unspent}_3$ e $\sigma^{unspent}_2$, o provador também fornece as chaves públicas $k^s*K^s$, $k^s*\tilde{K}^s_?$ e $k^s*k^s*\mathcal{H}_p(K^o)$.

%Along with proofs $\sigma^{unspent}_3$ and $\sigma^{unspent}_2$, the prover makes sure to communicate the public keys $k^s*K^s$, $k^s*\tilde{K}^s_?$, and $k^s*k^s*\mathcal{H}_p(K^o)$.

\subsubsection*{Verificação}

\begin{enumerate}
    \item Confirmar que as provas $\sigma^{\textrm{nãogasto}}_3$ e $\sigma^{\textrm{nãogasto}}_2$ são legitimas.
    \item Ter a certeza de que a mesma chave pública $k^s*K^s$ foi utilizada em ambas as provas. 
    \item Verificar se $k^s*\tilde{K}^s_?$ e $k^s*k^s*\mathcal{H}_p(K^o)$ são iguais. Se são então a saída está gasta, e se não então a saída não está gasta (enp).

%Check whether $k^s*\tilde{K}^s_?$ and $k^s*k^s*\mathcal{H}_p(K^o)$ are the same. If they are, the output is spent, and if not it is unspent (except with negligible probability).
\end{enumerate}{}

\subsubsection*{Funciona porque}

Este meio previne que o verificador discubra $k^s*H_p(K^o)$ para uma saída não gasta, que ele poderia utilizar em combinação com $r K^v$ para calcular a imagem de chave verdadeira.
Enquanto que ele está confiante que a imagem de chave testada não corresponde a essa saída.
%??? ?
%This seemingly roundabout approach prevents the verifier from learning $k^s*H_p(K^o)$ for an unspent output, which he could use in combination with $r K^v$ to compute its real key image, while leaving him confident the tested key image doesn't correspond to that output.

A prova $\sigma^{unspent}_2$ pode ser reutilizada para qualquer número de provas de não-gasto que involvam a mesma saída. Se essa saída foi de facto gasta então  

%Proof $\sigma^{unspent}_2$ can be reused for any number of UnspentProofs involving the same output, although if it actually was spent then only one is really necessary (i.e. UnspentProofs can also be used to demonstrate an output is spent). Performing UnspentProofs on all ring signatures where a given unspent output was referenced should not be computationally expensive. An output is only likely, over time, to be included as decoys in on the order of 11 (current ring size) different rings.
%??? ?

\subsection{Provar que um endereço tem um saldo mínimo não gasto ({\tt ReserveProofV2})}
\label{subsec:proofs-minimum-balance-reserveproof}

Apesar da fuga de privacidade, ao revelar a imagem de chave de uma saída quando esta ainda não foi gasta, isto ainda é um método algo útil e foi implementado em Monero \cite{reserveproofs-pull-request-3027} antes das provas de não-gasto terem sido inventadas \cite{unspent-proof-issue-68}. A prova de `reserva' é utilizada para provar que um endereço possui um montante mínimo ao criar imagens de chave para algumas saídas de transacção. 
%Despite the privacy leak of revealing an output's key image when it isn't spent yet, it's still a somewhat useful method and was implemented in Monero \cite{reserveproofs-pull-request-3027} before UnspentProofs were invented \cite{unspent-proof-issue-68}. Monero's so-called `ReserveProof'\marginnote{src/wallet/ wallet2.cpp {\tt get\_rese- rve\_proof()}} is used to prove an address owns a minimum amount of money by creating key images for some unspent outputs.
Mais especificamente, dado um saldo mínimo, o provador encontra suficientes saídas não gastas que o cubra, e demonstra a posse destas com provas de entrada. Depois cria imagens de chave para estas saídas, e prova que são legítimas, para com essas saídas com provas de duas bases (com um formato de prefixo de chave diferente). Depois prova o conhecimento das chaves privadas de gasto usadas, com assinaturas normais tipo Schnorr (pode haver mais de uma se algumas saídas são possuídas por sub-endereços distintos). Um verificador verifica que as imagens de chave não apareceram na lista de blocos, e assim essas saídas têm de ser não gastas. 
    
%More specifically, given a minimum balance, the prover finds enough unspent outputs to cover it, demonstrates ownership with InProofs, makes key images for them and proves they are legitimately based on those outputs with 2-base proofs (using a different key prefixing format), and then proves knowledge of the private spend keys used with normal Schnorr signatures (there may be more than one if some outputs are owned by different subaddresses). A verifier can check that the key images have not appeared on the blockchain, and hence their outputs must be unspent.

\subsubsection*{A prova de reserva}
%The ReserveProof}%get_reserve_proof() wallet2.cpp

Todas as sub-provas dentro de uma prova de reserva {\em ReserveProof} assinam uma mensagem diferente do que os outros tipos de provas (e.g. OutProofs, InProofs, or SpendProofs). Desta vez é :
\begin{align*}
\mathfrak{m} = \mathcal{H}_n(\texttt{message}, \texttt{address}, \tilde{K}^o_1, ... \tilde{K}^o_n) ,
\end{align*}
em que {\tt address} é o endereço normal $(K^s, K^v)$, de forma codificada (veja-se \cite{luigi-address}). E as imagens de chave correspondem a saídas não gastas a serem incluídas na prova. 

%All the sub-proofs within a ReserveProof sign a different message than other proofs (e.g. OutProofs, InProofs, or SpendProofs). This time it is $\mathfrak{m} = \mathcal{H}_n(\texttt{message}, \texttt{address}, \tilde{K}^o_1, ..., \tilde{K}^o_n)$, where {\tt address} is the encoded form (see \cite{luigi-address}) of the prover's normal address $(K^v, K^s)$, and the key images correspond with unspent outputs to be included in the proof.

\begin{enumerate}
    \item Cada saída tem uma prova de entrada, o que mostra que o endereço do provador (ou um dos seus sub-endereços) possui essa saída. 
%Each output has an InProof, which shows the prover's address (or one of his subaddresses) owns the output.
    \item Cada imagem de chave de uma saída é assinada com uma prova de duas bases, em que o desafio está formatado da seguinte forma : 
%Each output's key image is signed with a 2-base proof\marginnote{src/crypto/ crypto.cpp {\tt generate\_ ring\_signa- ture()}}, where the challenge is formatted like this%generate_ring_signature()
    \[c = \mathcal{H}_n(\mathfrak{m}, [r G + c*K^o], [r \mathcal{H}_p(K^o) + c*\tilde{K}])\]
    \item Cada \marginnote{src/crypto/ crypto.cpp {\tt generate\_ signature()}}endereço (e sub-endereço) que possui pelo menos uma saída tem uma assinatura normal tipo Schnorr (secção \ref{sec:signing-messages}), e o desafio (que é igual para endereços normais e sub-endereços) é : 
\begin{align*}
c = \mathcal{H}_n(\mathfrak{m}, K^{s,i}, [r G + c*K^{s,i}]) ,
\end{align*}

%Each address (and subaddress) that owns at least one output has a normal Schnorr signature (Section \ref{sec:signing-messages}), and the challenge looks like (it's the same for normal addresses and subaddresses)\marginnote{src/crypto/ crypto.cpp {\tt generate\_ signature()}}
%\[c = \mathcal{H}_n(\mathfrak{m}, K^{s,i}, [r G + c*K^{s,i}])\]
\end{enumerate}{}
Para enviar uma prova de reserva a alguêm\marginnote{src/wallet/ wallet2.cpp {\tt get\_rese- rve\_proof()}}[.3cm], o provador concatena o string de prefixo ``{\tt ReserveProofV2}" com duas listas codificadas em base-58 (e.g. ``{\tt ReserveProofV2}, list 1, list 2"). Cada item na lista 1 está relacionada a uma saída específica e contêm o seu hash de transacção (secção \ref{subsec:transaction-id}), o index de saída dentro dessa transacção (secção \ref{sec:multi_out_transactions}), o segredo partilhado relevante $r K^v$, a sua imagem de chave, a sua prova de entrada ($\sigma^{inproof}$), e a sua prova de imagem de chave. A lista 2 contêm items que são os endereços que possuem essas saídas juntamente com as suas assinaturas tipo Schnorr.
%To send a ReserveProof to someone else\marginnote{src/wallet/ wallet2.cpp {\tt get\_rese- rve\_proof()}}[.3cm], the prover concatenates prefix string ``{\tt ReserveProofV2}" with two lists encoded in base-58 (e.g. ``{\tt ReserveProofV2}, list 1, list 2"). Each item in list 1 is related to a specific output and contains its transaction hash (Section \ref{subsec:transaction-id}), output index in that transaction (Section \ref{sec:multi_out_transactions}), the relevant shared secret $r K^v$, its key image, its InProof $\sigma^{inproof}$, and its key image proof. List 2 items are the addresses that own those outputs along with their Schnorr signatures.

%in encoded data there are two lists of items, first list is per output [tx_hash, owned output's index, the shared secret r K^v, its key image, a \sigma^{inproof}, and a key image proof], second list is [subaddress, subaddress proof]
%key image proof uses generate_ring_signature() on message m (InProof also uses this message, different from otherwise), basically a 1-member ring sig
%subaddress proofs (basic schnorr signatures) includes a proof for main spend key if necessary! so ReserveProof not only reveals an unspent balance, but also means the prover fully owns them; however, this does not prove the subaddresses correspond with the original address

\subsubsection*{Verificação}

\begin{enumerate}
    \item Verifica-se se as imagens de chave das provas de reserva não apareceram na lista de blocos.\marginnote{src/wallet/ wallet2.cpp {\tt check\_rese- rve\_proof()}}
%Check the ReserveProof key images have not appeared in the blockchain.\marginnote{src/wallet/ wallet2.cpp {\tt check\_rese- rve\_proof()}}
    \item Verifica-se a prova de entrada para cada saída, e que um dos endereços dados possui uma saída.
%???and that one of the provided addresses owns each one. or one to one ?   
%Verify the InProof for each output, and that one of the provided addresses owns each one.
    \item Verificam-se as assinaturas (de duas bases), das imagens de chave.   
%Verify the 2-base key image signatures.
    \item Usam-se os segredos partilhados entre remetente e destinatário para descodificar os montantes nas saídas (secção \ref{sec:pedersen_monero}).  
%Use the sender-receiver shared secrets to decode the output amounts (Section \ref{sec:pedersen_monero}).
    \item Verifica-se a assinatura de cada endereço.
%Check each address's signature.
\end{enumerate}{}

Se tudo é legítimo, então o provador tem de possuir pelo menos o montante total contido nas saídas da prova de reserva (enp). 
%If everything is legitimate, then the prover must own, unspent, at least the total amount contained in the ReserveProof's outputs (except with negligible probability).
\footnote{Uma prova de reserva, enquanto que demonstra a posse de fundos, não inclui a prova de que dados sub-endereços pertencem a um endereço normal.}  
%ReserveProofs, while demonstrating full ownership of funds, do not include proofs that given subaddresses actually correspond with the prover's normal address.}

\section{Estrutura de auditoria}
\label{sec:proofs-monero-audit-framework}

Nos estados unidos da america a maioria das empresas são sujeitas a auditorias financeiras \cite{investopedia-audits}. Isto incluí a declaração de rendimentos, de cash flow e de saldo. Os primeiros dois involvem em larga parte a contabilidade interna de uma empresa enquanto que o saldo involve cada transacção, que afecta quanto dinheiro é que uma empresa actualmente possui. Cripto-moedas são como cash, portanto qualquer auditoria ao cash-flow de um utilizador de uma cripto-moeda, está relacionada com as transacções na lista de blocos.       
%In the USA most companies undergo yearly audits of their financial statements \cite{investopedia-audits}, which include the income statement, balance sheet, and cash flow statement. Of these the former two involve in large part a company's internal record-keeping, while the last involves every transaction that affects how much money the company currently has. Cryptocurrencies are digital cash, so any audit of a cryptocurrency user's cash flow statement must relate to transactions stored on the blockchain.

A primeira tarefa ao auditar uma pessoa, é de identificar todas as saídas que esta possui (gastas e não gastas). Isto pode ser feito com provas de entrada usando todos os endereços em causa. Uma grande empresa pode ter uma multitude de sub-endereços, especialmente vendedores que operem em mercados online (ver capítulo 
\ref{chapter:escrowed-market}). Criar provas de entrada para todas as transacções para cada sub-endereço pode resultar em requisitos computacionais e de espaço enormes para ambos o provador e o verificador.

%The first task of an audited person is to identify all the outputs they currently own (spent and unspent). This can be one with InProofs using all of their addresses. A large business may have a multitude of subaddresses, especially retailers operating in online marketplaces (see Chapter 
%\ref{chapter:escrowed-market}). Creating InProofs on all transactions for every single subaddress may result in enormous computational and storage requirements for both provers and verifiers.

Em vez disso, pode-se fazer uma prova de entrada só para o endereço normal do provador para todas as transacções. O auditor usa o segredo partilhado entre o remetente e o destinatário para verificar se alguma saída é possuída pelo endereço principal do provador ou pelos sub-endereços respectivos. Note-se que a {\em chave de ver} é suficiente para identificar todas as saídas possuídas pelos sub-endereços de um endereço.

%Instead, we can make InProofs for just the prover's normal addresses (on all transactions). The auditor uses those sender-receiver shared secrets to check if any outputs are owned by the prover's main address or its related subaddresses. Recalling Section \ref{sec:subaddresses}, a user's view key is enough to identify all outputs owned by an address's subaddresses.

Para garantir que um provador não está a tentar enganar um auditor, ao esconder um endereço normal para alguns dos seus sub-endereços, ele tem de provar também que todos os sub-endereços dados correspondem com um endereço normal. 

%To ensure the prover is not hoodwinking an auditor by hiding the normal address for some of his subaddresses, he also must prove all subaddresses correspond with one of his known normal addresses.


\subsection{Provar que um sub-endereço corresponde a um endereço}
\label{subsec:proofs-address-subaddress-correspond-subaddressproof}

É possivel mostrar com este tipo de prova que a chave de ver de um endereço normal pode ser utilizada para identificar saídas possuídas por um dado sub-endereço \footnote{Este tipo de prova ainda não foi implementado em Monero.}.
%SubaddressProofs show that a normal address's view key can be used to identify outputs owned by a given subaddress.

\subsubsection*{Prova de sub-endereço}
%subaddress proof: base keys [G, K^{s,i}] public keys [K^v, K^{v,i}] signing key [k^v]
As provas de sub-endereço podem ser feitas á semelhança de provas de saída ou de entrada. Aqui as chaves base são :
\begin{align*}
\mathcal{J} = \{G, K^{s,i}\}
\end{align*}
as chaves públicas são :
\begin{align*}
\mathcal{K} = \{K^v, K^{v,i}\}
\end{align*}
e a chave que assina é $k^v$.

%SubaddressProofs can be made in much the same way as OutProofs and InProofs. Here the base keys are $\mathcal{J} = \{G, K^{s,i}\}$, public keys are $\mathcal{K} = \{K^v, K^{v,i}\}$, and signing key is $k^v$. Again, we show just the verification step to clarify our meaning.

\subsubsection*{Verificação}

Um verificador sabe o endereço do provador $(K^v, K^s)$, o sub-endereço $(K^{v,i}, K^{s,i})$ e tem a prova de sub-endereço $\sigma^{subproof} = (c,r)$.

%A verifier knows the prover's address $(K^v, K^s)$, subaddress $(K^{v,i}, K^{s,i})$, and has the SubaddressProof $\sigma^{subproof} = (c,r)$.

\begin{enumerate}
    \item Calcula-se o desafio\vspace{.175cm}
	\[c' = \mathcal{H}_n(\mathfrak{m},[K^{v,i}], [r G + c*K^v], [r K^{s,i} + c*K^{v,i}], [T_{txprf2}], [K^v], [K^{s,i}], [0])\]
    \item Se $c = c'$ então o provador sabe $k^v$ para $K^v$, e $K^{s,i}$ em combinação com essa chave de ver faz $K^{v,i}$ (enp).
\end{enumerate}{}


\subsection{a estrutura de auditoria}
\label{subsec:audit-framework}

Agora é possível aprender o máximo possível sobre a história de transacção de uma pessoa.
%Now we are prepared to learn as much as possible about a person's transaction history.
\footnote{
Esta estrutura de auditoria não está completamente disponível em Monero. Provas de sub-endereço e provas de não-gasto não estão implementadas. Provas de entrada não estão preparadas para a optimização relacionada com sub-endereços. E não existe um verdadeira estrutura para facilmente obter e organizar todas as informações para os provadores e verificadores.}

\begin{enumerate}
    \item O provador junta uma lista de todas as suas contas, em que cada conta consiste de um endereço normal e vários sub-endereços. Ele faz uma prova de sub-endereços a todos os seus sub-endereços. Depois faz uma assinatura com a chave de gasto de cada endereço e sub-endereço, demonstrando que possui o direito de gastar de todas as saídas pertencentes a esses endereços. 
    \item O provador gera, para cada um dos seus endereços normais, provas de entrada para cada transacção na lista de blocos. Isto revela ao auditor todas as saídas possuídas pelo endereço do provador. Pois é possível verificar todos os endereços ocultos com o segredo partilhado entre o remetente e o destinatário. Há a certeza que as saídas pertencentes a sub-endereços irão ser identificadas por causa das provas de sub-endereço.\footnote{Este passo também pode ser completado com as chaves privadas de ver, o que implica certas fugas de privacidade.}
%This step can also be completed by providing the private view keys, although it has obvious privacy implications.} 
%??? todas as tx ou só as suas ?

%The prover generates, for each of his normal addresses, InProofs on all transactions (e.g. all transaction public keys) in the blockchain. This reveals to the auditor all outputs owned by the prover's addresses since they can check all one-time addresses with the sender-receiver shared secrets. They can be sure outputs owned by subaddresses will be identified, because of the SubaddressProofs.\footnote{This step can also be completed by providing the private view keys, although it has obvious privacy implications.}
    \item O provador gera, para cada uma das saídas que possui, provas de não-gasto para todas as entradas de transacção em que estas saídas sejam membros de anel. Agora o auditor saberá o saldo do provador e pode passar a investigar saídas gastas. \footnote{Alternativamente, ele podia fazer provas de reserva para todas as saídas que possui. Mas revelar as imagens de chave das saídas não gastas, implica fugas de privacidade.}
%Alternatively, he could make ReserveProofs for all owned outputs. Again, revealing the key images of unspent outputs has obvious privacy implications.}
%??? saídas sejam membros de anel ou entradas? 
%The prover generates, for each of his owned outputs, UnspentProofs on all transaction inputs where they appear as ring members. Now the auditor will know the prover's balance, and can further investigate spent outputs.\footnote{Alternatively, he could make ReserveProofs for all owned outputs. Again, revealing the key images of unspent outputs has obvious privacy implications.}
    \item {\em Opcional}: O provador gera, para cada transacção em que ele gastou uma saída, uma prova de saída para mostrar ao auditor o destinatário e o montante. Este passo só é possível para transacções em que o provador salvaguardou as chaves privadas de transacção.
%The prover generates, for each transaction where he spent an output, an OutProof to show the auditor the recipient and amount. This step is only possible for transactions where the prover saved the transaction private key(s).
\end{enumerate}{}
Note-se que um provador não tem maneira de mostrar as origens de fundos directamente. O seu único recurso é requisitar um conjunto de provas de pessoas que lhe enviam dinheiro.
%Importantly, a prover has no way to show the origin of funds directly. His only recourse is to request a set of proofs from people sending him money.

\begin{enumerate}
    \item Para uma transacção que envia dinheiro para o provador, o seu autor faz uma prova de gasto o que demonstra que o dinheiro foi de facto enviado. 
%For a transaction sending money to the prover, its author makes a SpendProof demonstrating they actually sent it.
    \item Quem envia dinheiro ao provador também faz uma assinatura com uma chave pública identificável, por exemplo a chave de gasto do endereço normal. A prova de gasto e esta assinatura assina uma mensagem que contêm essa chave pública identificável. Assim garante-se que a prova de gasto não foi roubada ou de facto feita por outra pessoa.
%The prover's funder also makes a signature with an identifying public key, for example the spend key of their normal address. Both the SpendProof and this signature should sign a message containing that identifying public key, to ensure the SpendProof wasn't stolen or in fact made by someone else. 
%??? Both the SpendProof and this signature should sign a message?
\end{enumerate}{}
