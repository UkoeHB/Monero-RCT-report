\chapter{Сокрытие суммы Monero}
\label{chapter:pedersen-commitments}

В случае с большинством криптовалют, таких как Bitcoin, в примечаниях выходов транзак\-ций, дающих право на то, чтобы потратить какую-либо «сумму» денег, такая сумма указыва\-ется простым текстом. Это позволяет наблюдателям без труда проверить соответствие суммы, которая тратится, отправляемой сумме.

В Monero используются {\em обязательства}, которые скрывают суммы в выходах от всех осталь\-ных, кроме отправителя и получателя. При этом наблюдатели сохраняют уверенность в том, что сумма транзакции более или менее равна тому, что действительно тратится. Как можно будет увидеть, обязательства по сумме также должны иметь соответствующие «доказатель\-ства диапазона», которые доказывают, что скрытая сумма находится в пределах некоего легитимного диапазона.



\section{Обязательства}
\label{sec:commitments}

В общих чертах криптографическая {\em схема обязательства} является способом предоставления доказательства суммы без раскрытия самой суммы. После того как вы дадите обязательство, вам будет необходимо придерживаться его.

Например, в игре с подбрасыванием монеты Элис может конфиденциально дать обязательство по одному результату (то есть «назвать его»), опубликовав значение, хешированное с использо\-ванием секретных данных, по которому она даёт обязательство. После того как Боб подбросит монету, Элис может объявить, какой результат она получила, и доказать его, раскрыв секрет\-ные данные. После этого Боб может проверить её заявление.

Другими словами, предположим, что у Элис есть секретный ряд $blah$, а значение, по которому она хочет дать обязательство, — $heads$. Она хеширует $h = \mathcal{H}(blah, heads)$ и передаёт Бобу $h$. Боб подбрасывает монету, после чего Элис сообщает ему секретный ряд $blah$ и говорит, что дала обязательство по $heads$. После этого Боб вычисляет $h’ = \mathcal{H}(blah, heads)$. И если $h' = h$, то он знает, что Элис указала $heads$ до броска монеты.

Элис использует так называемую «соль», $blah$, поэтому Боб не может просто угадать $\mathcal{H}(heads)$ и $\mathcal{H}(tails)$ до того, как подбросит монету, и выяснить, что она дала обязательство по $heads$.\footnote{Если значение, по которому было дано обязательство, очень трудно угадать и проверить, например, если оно является случайной точкой на эллиптической кривой, то в использовании «соли» в обязательстве нет никакой необходимости.}



\section{Обязательства Педерсена}
\label{pedersen_section}

{\em Обязательства Педерсена} \cite{Pedersen1992} обладают свойством {\em аддитивной гомоморфности}. Если \(C(a)\) и \(C(b)\) являются обозначением обязательств по \(a\) и \(b\), соответственно, то \(C(a + b) = C(a) + C(b)\).\footnote{Аддитивная гомоморфность в данном случае означает сохранение добавления при преобразовании скалярных величин в точки EC, применяя (для скалярной величины $x$, $x \rightarrow x G$.} Это свойство полезно при доказательстве сумм транзакций, так как любой может доказать, например, что входы равны выходам, не раскрывая имеющейся у него суммы.
\\

К счастью, обязательства Педерсена легко реализовать, используя криптографию на основе эллиптических кривых, так как следующее правило сохраняется: \[a G + b G = (a + b) G\]

Очевидно, определяя обязательство просто как \(C(a) = a G\), мы бы смогли создать обманные таблицы обязательств, которые помогли бы нам распознать общие значения $a$.

Для обеспечения информационно-теоретической приватности необходимо ввести секретный {\em скрывающий фактор} и ещё один генератор \(H\), которые не позволят узнать, для какого значе\-ния \(\gamma\) будет действительным следующее равенство: \(H = \gamma G\). Сложность решения задачи дискретного логарифма гарантирует, что вычисление $\gamma$ на основе $H$ просто невозможно.\footnote{В случае Monero\marginnote{src/ringct/ rctTypes.h}, $H = 8*to\_point(\mathcal{H}_n(G))$. Это отличается от хеш-функции $\mathcal{H}_p$ тем, что выход $\mathcal{H}_n(G)$ интерпретируется напрямую как координата сжатой точки, а не производится математического вычисления точки на кривой (см. \cite{hashtopoint-writeup}). Исторические причины такого расхождения\marginnote{tests/unit\_ tests/ ringct.cpp {\tt TEST(ringct, HPow2)}} нам не известны, и, по сути, это единственный случай, когда $\mathcal{H}_p$ не используется (Bulletproofs также используют $\mathcal{H}_p$). Следует отметить наличие операции $*8$, которая гарантирует, что полученная точка будет находиться в нашей подгруппе $l$ ($\mathcal{H}_p$ также гарантирует это).}

%In the case of Monero\marginnote{src/ringct/ rctTypes.h}, $H = \mathcal{H}_p(G)$.\footnote{\label{hashtopoint_note}Monero's unique hash to point function\marginnote{src/ringct/ rctOps.cpp {\tt hash\_to\_p3()}} (see \cite{hashtopoint-writeup}) is used in practice to turn the normal hash of one curve point directly into another curve point. For commitments, $H = hash\_to\_point(\mathit{Keccak}(G))$. }%see rctTypes.h

Следовательно, мы можем определить обязательство по \(a\) как \(C(x, a) = x G + a H\), где \(x\) является скрывающим фактором (также известным как «маска»), который не даёт наблюда\-телям раскрыть $a$.

Обязательство $C(x, a)$ является информационно-теоретически приватным, так как существует множество возможных комбинаций $x$ и $a$, которые будут иметь своим результатом $C$.\footnote{В основном существует такое множество $x’$ и $a’$, что $x’+a’ \gamma = x+a \gamma$. Лицу, публикующему обязательства, известна комбинация, но злоумышленник не может угадать, какая именно. Это свойство также известно как «идеальное сокрытие» \cite{adam-zero-to-bulletproofs}. Кроме того, даже лицо, публикующее обязательства, не сможет найти другой комбинации, не решив DLP для $\gamma$. Это свойство известно как «вычислительное связывание» \cite{adam-zero-to-bulletproofs}.} Если значение $x$ действительно будет случайным, у злоумышленника буквально не будет способа найти $a$ \cite{maxwell-ct, SCOZZAFAVA1993313}.%{https://people.xiph.org/~greg/confidential_values.txt}



\section{Обязательства по сумме}
\label{sec:pedersen_monero}

В случае Monero суммы, содержащиеся в выходах, сохраняются в транзакциях в виде обяза\-тельств Педерсена. Мы определяем обязательство по сумме выхода $b$ следующим образом:\vspace{.175cm}
\[C(y,b) = y G + b H\marginnote{src/ringct/ rctOps.cpp {\tt addKeys2()}}\]

У получателей должна быть возможность узнавать, сколько денег находится в каждом выхо\-де, имеющемся у них, а также они должны быть способны восстановить обязательство, чтобы они могли использовать эти выходы в качестве входов в новых транзакциях. Это означает, что скрывающий фактор $y$ и сумма $b$ должны быть сообщены получателю.

Нами применяется решение в виде общего секрета Диффи-Хеллмана $r K_B^v$, использующего «публичный ключ транзакции» (см. подпункт \ref{sec:multi_out_transactions}). В случае с каждой отдельно взятой транзакцией в блокчейне у каждого из её выходов $t \in \{0, ..., p-1\}$ имеется маска $y_t$ которую могут приватно вычислить как отправители, так и получатели, а также {\em сумма}, которая сохраняется в данных транзакции. В то время как $y_t$ является скалярной величиной эллипти\-ческой кривой и занимает 32 байта, размер $b$ будет ограничен 8 байтами при помощи доказа\-тельства диапазона, поэтому требуется сохранить значение, составляющее 8 байтов.\footnote{Как\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key()} и в случае {\tt generate\_ output\_ ephemeral\_ keys()}} с одноразовым адресом $K^o$, о котором говорилось в подпункте \ref{sec:one-time-addresses}, перед хешированием к общему секрету прикрепляется индекс выхода $t$. Это гарантирует, что выходы, направляемые по одному адресу, не будут иметь одинаковой маски и {\em суммы}, за исключением ничтожной вероятности. Так же как и ранее, член $r K^v_B$ умножается на 8, поэтому, по сути, является $8rK^v_B.$}\footnote{Это решение (реализованное в версии v10 протокола) заменило собой метод, который использовался ранее и требовал большего объёма данных, в результате чего тип транзакций изменился с версии v3 ({\tt RCTTypeBulletproof}) на версию v4 ({\tt RCTTypeBulletproof2}). Метод, который использовался раньше, рассматривался в предыдущей редакции настоящего отчёта \cite{ztm-1}.}\marginnote{src/ringct/ rctOps.cpp {\tt ecdh- Encode()}}[.725cm]\vspace{.175cm}%Under construct_tx_with_tx_key, key_amounts is created with the shared secret r K_B^v concatenated with the index by calling generate_output_ephemeral_keys() which then uses derivation_to_scalar(), then ecdhEncode builds the mask and amount when key_amounts is passed to it with the unmasked mask & amount. After update, ecdhHash and xor8 also play a role.
\begin{align*}
  y_t &= \mathcal{H}_n(``commitment\_mask",\mathcal{H}_n(r K_B^v, t)) \\
  \mathit{amount}_t &= b_t \oplus_8 \mathcal{H}_n(``amount”, \mathcal{H}_n(r K_B^v, t))
\end{align*}

В данном случае $\oplus_8$ означает операцию XOR (см. подпункт \ref{sec:XOR_section}), выполняемую между первыми 8 байтами операнда ($b_t$, размер которого уже составляет 8 байт, и $\mathcal{H}_n(...)$размер которого равен 32 байтам). Получатели могут применить ту же операцию XOR к $\mathit{amount}_t$, чтобы раскрыть $b_t$.

Получатель Боб сможет вычислить скрывающий фактор $y_t$ и сумму $b_t$, воспользовавшись публичным ключом транзакции $r G$ и своим ключом просмотра $k_B^v$, также он может проверить соответствие обязательства $C(y_t, b_t)$, полученного с данными транзакции и обозначенного как $C_t^b$, имеющейся у него сумме.\\

В более общем плане любая третья сторона, обладающая доступом к ключу просмотра Боба, может расшифровать суммы в его выходах и убедиться в их соответствии связанным с ними обязательствам.



\section{Введение в RingCT}
\label{sec:ringct-introduction}

Транзакция должна содержать ссылки на выходы других транзакций (которые скажут наблю\-дателям, какие из старых выходов можно потратить). Содержимое выхода включает в себя одноразовый адрес (указывающий на принадлежность выхода) и обязательство по выходу, скрывающее сумму (а также зашифрованную сумму выхода, о которой говорилось в подпунк\-те \ref{sec:pedersen_monero}).

Несмотря на то, что верификаторам транзакций не известно, сколько денег содержится в каждом входе и каждом выходе, им всё же необходимо знать, что сумма во входах равна сумме в выходах. Для этого Monero использует технологию под названием RingCT \cite{MRL-0005-ringct}, которая была впервые внедрена в январе 2017 (версия v4 протокола).

Если у нас есть транзакция с $m$ выходов, содержащих \(a_1, ..., a_m\) и $p$ выходов, содержащих \(b_0, ..., b_{p-1}\), наблюдатель обоснованно может предположить, что:\footnote{Если общая заданная сумма входов не равна любой комбинации имеющихся выходов, авторы транзакции могут добавить выход «сдачи», отправив дополнительные деньги самим себе. По аналогии с наличными деньгами, если у вас есть банкнота достоинством 20\$ и вы тратите 15\$, кассир вернёт вам 5\$.}\vspace{.175cm}
\[\sum_j a_j - \sum_t b_t = 0\]

Поскольку обязательства являются аддитивными и нам не известно значение $\gamma$, мы можем с лёгкостью доказать наблюдателям, что наши входы равны выходам, сделав сумму обяза\-тельств по входам и выходам равным нулю (то есть задав сумму скрывающих факторов выходов как равную сумме скрывающих факторов старых входов):\footnote{Как указано в подпункте \ref{elliptic_curves_section}, мы можем выделить точку, инвертировав её координаты, а не добавляя её. Если $P = (x, y)$, $-P = (-x, y)$. Также можно вспомнить, что согласование элементов поля вычисляется $\pmod q$, поэтому $(–x \pmod q)$.}\vspace{.175cm}
\[\sum_{j}{C_{j, in}} - \sum_{t}{C_{t, out}} = 0\]

Чтобы избежать идентификации отправителя, мы используем несколько иной подход. Суммы, которые тратятся, соответствуют выходам предыдущих транзакций, по которым имеются обязательства\vspace{.175cm}
\[C^a_{j} = x_j G + a_j H\]

Отправитель может создать новые обязательства по тем же суммам, но используя разницу между двумя обязательствами:
\[C'^a_{j} = x'_j G + a_j H\]

Очевидно, что отправителю будет известен приватный ключ к разнице между двумя обяза\-тельствами: \vspace{.175cm}
\[C^a_{j} - C'^a_{j} = (x_j - x'_j) G\]\\
Следовательно, отправитель сможет использовать это значение как {\em обязательство по нулю}, так как он способен создать подпись с приватным ключом $(x_j - x'_j) = z_j$ и доказать отсутствие компонента $H$ в сумме (при этом подразумевается, что значение $\gamma$ не известно). Другими словами, доказать, что $C^a_{j} - C'^a_{j} = z_j G + 0H$, что будет нами сделано в Главе \ref{chapter:transactions}, когда мы будем рассматривать структуру транзакций RingCT.

Назовём $C'^a_j$ a {\em псевдообязательством по выходу}. Псевдообязательства по выходам включают\-ся в данные транзакции, и берётся по одному такому обязательству для каждого входа.

Перед передачей транзакции в блокчейн сеть захочет верифицировать сбалансированность сумм. Скрывающие факторы псевдообязательств по выходам выбираются так, чтобы\vspace{.175cm}
\[\sum_j x'_j  - \sum_t y_t = 0\]

Это\marginnote{src/ringct/ rctSigs.cpp verRct- Semantics- Simple()} позволяет нам доказать, что суммы в выходах равны суммам во входах:\vspace{.175cm}
\[(\sum_j C'^a_{j} - \sum_t C^b_{t}) = 0\]

К счастью, выбрать такие скрывающие факторы просто. В текущей версии Monero все скрывающие факторы являются случайными для псевдообязательства $m$\nth, где $x'_m$ является просто\marginnote{genRct- Simple()}
\[x'_m = \sum_t y_t - \sum_{j=1}^{m-1} x'_j\]



\section{Доказательства диапазона}
\label{sec:range_proofs}

Проблема с аддитивными обязательствами состоит в том, что если у нас есть обязательства $C(a_1)$, $C(a_2)$, $C(b_1)$ и $C(b_2)$ и мы собираемся использовать их для доказательства того, что $(a_1 + a_2) - (b_1 + b_2) = 0$, то эти обязательства будут по-прежнему применимы, если одно из значений в уравнении будет «отрицательным».

Например, у нас может быть $a_1 = 6$, $a_2 = 5$, $b_1 = 21$ и $b_2 = -10$.\vspace{.175cm}
\begin{flalign*}
    && (6 + 5) - (&21 + -10) = 0&\\
     \intertext{\quad \quad \quad \quad \quad где} && 21G + -10G = 21G + (&l-10)G = (l + 11)G = 11G&
\end{flalign*}

Так как $-10 = l-10$, мы, по сути, создали на $l$ больше Monero (более 7.2x10$^{74}$!), чем вложили.

%Bulletproofs start here
У этой проблемы Monero есть решение, которое заключается в доказательстве того, что сумма каждого выхода находится в определённом диапазоне (от 0 до $2^{64}-1$), при помощи схемы доказательства Bulletproofs, впервые описанной Бенедиктом Бюнцем {\em и др.} в работе \cite{Bulletproofs_paper} (а также рассматриваемой в работах \cite{adam-zero-to-bulletproofs,dalek-bulletproofs-notes}).\footnote{Понятно, что при наличии нескольких выходов в легитимном диапазоне сумма содержащихся в них сумм сможет превысить допустимое значение, что вызовет появление проблемы. Тем не менее, если максимальный выход гораздо меньше, чем $l$, для того чтобы проблема возникла, требуется просто огромное количество выходов. Например, если допустимый диапазон составляет от 0 до 5, а $l$ = 99, значит, чтобы подделать деньги, используя 2 выхода, нам понадобится $5 + 5 + …. + 5 + 1 = 101 \equiv 2 \pmod{99}$ для 21 выхода. В Monero $l$ примерно в 2\^{}189 больше доступного диапазона, а это означает, что для подделки денег потребуется невероятное количество выходов, равное 2\^{}189.} Учитывая сложную и запутанную природу алгоритма Bulletproofs, мы не рассматриваем его в этом документе. Кроме того, мы считаем, что документы, на которые мы ссылаемся, в достаточной мере освещают соответствующие концепции.\footnote{До перехода к версии v8 протокола доказательства диапазона дополнялись подписями Борромео, которые мы рассмотрели в первой редакции «От нуля к Monero» \cite{ztm-1}.}

Алгоритм доказательства Bulletproof\marginnote{src/ringct/ rctSigs.cpp {\tt proveRange- Bullet- proof()}} в качестве входа берёт суммы выходов $b_t$ и маски обяза\-тельств $y_t$ и выводит все $C^b_t$ , а также состоящее из $n$ элементов агрегированное доказательство $\Pi_{BP} = (A, S, T_1, T_2, \tau_x, \mu, \mathbb{L}, \mathbb{R}, a, b, t)$\footnote{Каждый из векторов $\mathbb{L}$ и $\mathbb{R}$ содержит $\lceil \textrm{log}_2(64 \cdot p) \rceil$ элементов. $\lceil$ $\rceil$ означает, что логарифмическая функция округляется. Из-за своей структуры некоторые Bulletproofs используют «фиктивные выходы» для заполнения, а также чтобы гарантировать, что $p$ плюс определённое количество фиктивных выходов будет иметь степень 2. Такие фиктивные выходы могут быть сгенерированы во время верификации, и они не сохраняются с данными доказательства.}\footnote{Переменные, используемые в доказательстве Bulletproof, никак не связаны с другими переменными, о которых говорится в данном документе. Любое совпадение символов является совершенно случайным. Следует отметить, что групповые элементы $A, S, T_1, T_2, \mathbb{L},$ и $\mathbb{R}$ перед сохранением умножаются на 1/8, а затем, во время верификации, умножаются на 8. Это гарантирует, что все они будут входить в подгруппу $l$ (см. подпункт \ref{elliptic_curves_section}).}. Это единственное доказательство используется для того, чтобы доказать, что все суммы выходов одновременно находятся в одном диапазоне, а их накопление значительно снижает требование к занимаемому месту (вместе с тем увеличивая время верификации).\footnote{Получается, что множество отдельных доказательств Bulletproofs может быть объединено\marginnote{rct/ringct/ bulletproofs.cc {\tt bulletproof\_ VERIFY()}} в группы. А это значит, что их можно будет верифицировать одновременно. Это улучшает время их верификации, и сейчас доказательства Bulletproofs Monero объединяются в группу поблочно. При этом нет никакого теоретического ограничения в отношении количества доказательств, которые можно объединить вместе. Каждая транзакция может иметь только одно доказательство Bulletproof.} В качестве входа алгоритм верификации берёт все $C^b_t$ и $\Pi_{BP}$ и выводит {\tt true}, если все суммы, по которым были предоставлены обязательства, находятся в диапазоне от 0 до $2^{64} - 1$.

$\Pi_{BP}$, состоящее из $n$ элементов, занимает $(2 \cdot \lceil \textrm{log}_2(64 \cdot p) \rceil + 9) \cdot 32$ байт.