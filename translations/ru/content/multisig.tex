\chapter{Мультиподписи в Monero}
\label{chapter:multisignatures}

Криптовалютные транзакции необратимы. Если кому-нибудь удастся украсть ваши приват\-ные ключи или каким-то другим образом обмануть вас, деньги могут быть потеряны навсегда. Распределение полномочий, связанных с подписанием транзакций, между людьми может снизить потенциальный риск такого обмана.

Допустим, вы кладёте деньги на общий счёт с компанией, занимающейся вопросами безопас\-ности и отслеживающей подозрительную деятельность, связанную с вашим счётом. Транзак\-ции могут быть подписаны только в том случае, если вы сделаете это вместе с компанией. Если кто-нибудь украдёт ваши ключи, вы сможете сообщить компании о проблеме, и компа\-ния остановит процесс подписания транзакций для вашего счёта. Обычно это называют «эскроу» сервисом.\footnote{Мультиподписи имеют множество применений, начиная с корпоративных счетов и заканчивая подписками на рассылку информации торговыми онлайн площадками.}\\

В случае с криптовалютами технология «мультиподписей» используется с целью совместного подписания транзакций при помощи так называемой схемы multisig «M из N». В рамках данной схемы N пользователей объединяется для создания общего ключа, и только M пользо\-вателей (M $\leq$ N) требуется подписаться с использованием этого ключа. Мы начнём эту главу с объяснения базовых принципов схемы multisig «N из N», перейдём к схеме multisig «N из N» Monero, обобщим её до схемы multisig «M из N», а затем разъясним, как вложить одни multisig-ключи в другие.\\

В данной главе мы {\em фокусируем} внимание на том, как нам видится работа механизма multisig, исходя из рекомендаций, изложенных в работе \cite{MRL-0009-multisig}, а также данных различных исследований, касающихся вариантов эффективной реализации. В сносках мы попытались указать, чем текущая версия реализации отличается от того, что мы описываем.\footnote{На момент написания этого отчёта нам были известны три варианта реализации схемы multisig. Первая схема предполагает базовый, «ручной» процесс с использованием CLI (командной строки) \cite{cli-22multisig-instructions}. Вторая схема представляет собой действительно превосходную систему MMS (Multisig Messaging System), позволяющую безопасно и в практически полностью автоматизированном режиме использовать схему multisig через CLI \cite{mms-manual, mms-project-proposal}. Третья версия используется коммерчески доступным кошельком Exa Wallet, код начальной версии которого выложен в репозитории GitHub: \url{https://github.com/exantech} (это не актуально для текущей версии). Все три варианта основаны на одной и той же фундаментальной версии кодовой базы, что означает существование, по сути, только одного варианта реализации.} Наши контрибьюторы подробно изучили схему multisig «M из N» и новый подход к вложению multisig-ключей.



\section{Обмен данными с другими подписантами}
\label{sec:communicating}

Создание общих ключей и общих транзакций требует передачи секретной информации между людьми, которые могут находиться в любой точке земного шара. Чтобы защитить эту информацию от наблюдателей, участвующим подписантам необходимо шифровать сообщения, которыми они обмениваются.

Алгоритм обмена Диффи-Хеллмана (ECDH) представляет собой довольно простой способ шифрования сообщений при помощи криптографии на эллиптических кривых. Мы уже упоминали об этом в подпункте \ref{sec:pedersen_monero}, где суммы в выходах Monero сообщаются получателям с использованием общего секрета $r K^v$. Это выглядит вот так:\vspace{.175cm}
\begin{align*}
  \mathit{amount}_t = b_t \oplus_8 \mathcal{H}_n(``amount”, \mathcal{H}_n(r K_B^v, t))
\end{align*}

Мы с лёгкостью могли бы распространить это на любое сообщение. Сначала сообщение шифруется как последовательность разрядов, а затем разбивается на части, равные по разме\-ру выходу $\mathcal{H}_n$. После этого генерируется случайное число $r \in \mathbb{Z}_l$ и для всех фрагментов сообщения производится обмен Диффи-Хеллмана. При этом используется публичный ключ получателя $K$. Эти зашифрованные фрагменты отправляются вместе с публичным ключом $r G$ предполагаемому получателю, который затем сможет расшифровать сообщение с помощью общего секрета $k r G$. Отправители сообщений также должны создать подпись для своего зашифрованного сообщения (или, для простоты, просто хеш зашифрованного сообщения), чтобы получатели могли подтвердить, что сообщения не были подделаны (подпись будет верифицирована только в случае наличия правильного сообщения $\mathfrak{m}$).

Поскольку шифрование\marginnote{src/wallet/ wallet2.cpp {\tt export\_ multisig()}} не является важным аспектом работы такой криптовалюты, как Monero, мы не считаем необходимым вдаваться в подробности. Любопытные читатели могут ознакомиться с отличным концептуальным обзором \cite{tutorialspoint-cryptography} или же с техническим описанием популярной схемы шифрования AES, которое приводится в работе \cite{AES-encryption}. Кроме того, доктором Бернштейном была разработана схема шифрования, известная как ChaCha \cite{Bernstein_chacha,chacha-irtf}, которая используется в основном варианте реализации Monero для шифрования определенной чув\-ствительной информации\marginnote{src/wallet/ ringdb.cpp}, связанной с кошельками пользователей (например, образов ключей имеющихся выходов).



\section{Агрегирование ключей для адресов}
\label{sec:key-aggregation}

\subsection{Простейший подход}
\label{sec:naive-key-aggregation}

Допустим, N человек хотят создать групповой адрес с мультиподписью, который мы обозна\-чим $(K^{v,grp},K^{s,grp})$. Средства могут быть направлены по этому адресу точно так же, как и по любому обычному адресу, но, как мы увидим позже, чтобы потратить эти средства всем людям из N будет необходимо сотрудничать, чтобы подписать транзакции.

Так как все участники из N должны иметь возможность видеть средства, полученные на адрес группы, мы можем сообщить всем групповой ключ просмотра $k^{v,grp}$ (см. подпункты \ref{sec:user-keys} и \ref{sec:one-time-addresses}). Чтобы у всех участников были равные права, ключ просмотра может являться суммой компонентов ключа просмотра, которыми смогут безопасно обмениваться все участники. Для участника $e \in \{1,...,N\}$ его компонентом базового ключа просмотра будет $k^{v,base}_e \in_R \mathbb{Z}_l$, и все участники смогут вычислить групповой приватный ключ просмотра\marginnote{src/multi- sig/multi- sig.cpp {\tt generate\_ multisig\_ view\_sec- ret\_key()}}
\[k^{v,grp} = \sum^{N}_{e=1} k^{v,base}_e\]

Аналогичным образом групповой ключ траты $K^{s,grp} = k^{s,grp} G$ может являться суммой основ\-ных компонентов приватного ключа траты. Однако если кому-то станут известны все компо\-ненты приватного ключа траты, то ему будет известен и общий приватный ключ траты. Добавьте к этому приватный ключ просмотра, и он сможет подписывать транзакции само\-стоятельно. Это уже не будет мультиподписью. Это будет простая старая подпись.

Вместо этого\marginnote{src/multi- sig/multi- sig.cpp {\tt generate\_ multisig\_ N\_N()}} мы достигаем того же эффекта, если групповой ключ траты представляет собой сумму публичных ключей траты. Допустим, у участников есть базовые публичные ключи траты $K^{s,base}_e$, которыми они безопасно обмениваются. Теперь пусть каждый из них вычислит
\[K^{s,grp} = \sum_e K^{s,base}_e\]

Очевидно, что это то же самое, что и
\[K^{s,grp} = (\sum_e k^{s,base}_e)*G\]


\subsection{Недостатки простейшего подхода}
\label{subsec:drawbacks-naive-aggregation-cancellation}

Использование суммы публичных ключей траты интуитивно понятно и кажется простым, но ведёт к появлению нескольких проблем.

\subsubsection*{Проверка на агрегирование ключей}
Внешний злоумышленник, которому известны все базовые публичные ключи траты $K^{s,base}_e$, может легко проверить имеющийся публичный адрес $(K^v,K^s)$ на предмет агрегирования ключей, вычислив $K^{s,grp} = \sum_e K^{s,base}_e$ и проверив $K^s \stackrel{?}{=} K^{s,grp}$. А это уже связано с более широким требованием, согласно которому агрегированные ключи должны быть неотличимы от обычных ключей, чтобы наблюдатели не могли ничего узнать о действиях пользователей на основе типа публикуемого адреса.\footnote{Если хотя бы один честный участник использует компоненты, выбранные случайным образом из равномерно распределённых компонентов, то ключи, агрегированные путём простого суммирования, будут неотличимы \cite{SCOZZAFAVA1993313} от обычных ключей.}%cite multisig paper

Мы можем решить задачу, создав новые базовые ключи траты для каждого адреса с мульти\-подписью или замаскировав старые ключи. Первый вариант прост, но может быть связан с определёнными неудобствами.

Второй вариант реализуется следующим образом: при наличии пары старых ключей участ\-ника $e$ $(K^v_e,K^s_e)$ с приватными ключами $(k^v_e,k^s_e)$ и случайными масками $\mu^v_e,\mu^s_e$ \footnote{Случайные маски легко вывести на основе пароля. Например, $\mu^s = \mathcal{H}_n(password)$ и $\mu^v = \mathcal{H}_n(\mu^s)$. Или, как это реализовано в случае Monero, маскируем ключи траты и ключи просмотра строкой\marginnote{src/multisig/ multisig.cpp {\tt get\_multi- sig\_blind- ed\_secret \_key()}}, например, $\mu^s,\mu^v =$ ``Multisig". Это означает, что Monero поддерживает только один базовый multisig-ключ траты на обычный адрес, хотя на самом деле создание multisig-кошелька приводит к потере доступа пользователем к оригинальному кошельку \cite{cli-22multisig-instructions}. Это означает, что Monero поддерживает только один базовый multisig-ключ траты на обычный адрес, хотя на самом деле создание multisig-кошелька приводит к потере доступа пользователем к оригинальному кошельку.}, компоненты его нового базового приватного ключа группового адреса будут следующими:
\begin{align*}
    k^{v,base}_e &= \mathcal{H}_n(k^v_e,\mu^v_e)\\
    k^{s,base}_e &= \mathcal{H}_n(k^s_e,\mu^s_e)
\end{align*}

Если участники не хотят, чтобы внешние наблюдатели собирали новые ключи и проверяли их на предмет агрегирования, им придётся безопасно обмениваться своими новыми компонента\-ми ключей.\footnote{Как будет указано в подпункте \ref{sec:smaller-thresholds}, агрегация ключей не работает в случае со схемой multisig «M из N», если M $<$ N, из-за наличия общих секретов.}

Если проверка на агрегирование ключей не является для них проблемой, то они могут публи\-ковать свои базовые компоненты $(K^{v,base}_e,K^{s,base}_e)$ публичного ключа multisig как обычные адреса. И любая третья сторона на основе этих отдельных адресов сможет вычислить группо\-вой адрес и отправить на него средства, не взаимодействуя с кем-либо из объединившихся получателей \cite{maxwell2018simple-musig}.

\subsubsection*{Аннулирование ключей}

Если групповой ключ траты представляет собой сумму публичных ключей, недобросовестный участник, который заранее узнает базовые компоненты базового ключа траты остальных участников, сможет аннулировать их.

Например, Элис и Боб хотят создать групповой адрес. Элис добросовестно сообщает Бобу свои компоненты ключа $(k^{v,base}_A,K^{s,base}_A)$. Боб приватно создаёт свои компоненты ключа $(k^{v,base}_B,K^{s,base}_B)$, но не сообщает их Элис сразу. Вместо этого он вычисляет $K'^{s,base}_B = K^{s,base}_B - K^{s,base}_A$ и сообщает Элис $(k^{v,base}_B,K'^{s,base}_B)$. Групповой адрес будет следующим:\vspace{.175cm}
\begin{align*}
    K^{v,grp} &= (k^{v,base}_A + k^{v,base}_B) G \\
             &= k^{v,grp} G\\
    K^{s,grp} &= K^{s,base}_A + K'^{s,base}_B \\
             &= K^{s,base}_A + (K^{s,base}_B - K^{s,base}_A)\\
             &= K^{s,base}_B
\end{align*}

В результате получаем групповой адрес $(k^{v,grp} G,K^{s,base}_B)$, где Элис известен групповой приват\-ный ключ просмотра, а Бобу известны как приватный ключ просмотра, так и приватный ключ траты! Боб может подписывать транзакции самостоятельно, обманывая тем самым Элис, которая будет уверена в том, что средства, отправленные на адрес, могут быть потрачены только с её разрешения.

Эту проблему можно было бы решить, потребовав перед объединением ключей от каждого из участников создать подпись, подтверждающую, что им известен приватный ключ для их компонента ключа траты \cite{old-multisig-mrl-note}.\footnote{Текущая (и первая) итерация схемы multisig, используемая Monero и реализованная в апреле 2018 года \cite{lithiumluna-v7} (с интеграцией схемы «M-из-N», реализованной в октябре 2018 года \cite{berylliumbullet-v8}), предполагает этот простой вариант агрегации ключей и требует от пользователей предоставления\marginnote{src/wallet/ wallet2.cpp {\tt get\_multi- sig\_info()}} их компонентов ключа траты.} Но это неудобно и предполагает наличие уязвимости с точки зрения ошибок реализации. К счастью, в данном случае имеется надёжная альтернатива.%by required did I mean, they must do it on their own time; not part of multisig workflow to automatically happen


\subsection{Устойчивая агрегация ключей}
\label{sec:robust-key-aggregation}

Простой способ решения проблемы аннулирования ключей состоит во внесении небольших изменений в процесс агрегации ключей (при этом процесс агрегации ключей просмотра оста\-ётся прежним). Допустим, набор из компонентов базовых ключей траты N подписантов $\mathbb{S}^{base} = \{K^{s,base}_1,...,K^{s,base}_N\}$ упорядочен в соответствии с некоторым соглашением (например, от наименьшего к наибольшему в численном порядке, то есть лексикографически).\footnote{$\mathbb{S}^{base}$ необходимо последовательно упорядочить, чтобы участники могли быть уверены в том, что все они хешируют одно и то же.} Надёж\-ный агрегированный ключ траты будет следующим \cite{MRL-0009-multisig}\footnote{В подпункте \ref{sec:CLSAG} сказано, что хеш-функции должны быть разделены по доменам путём добавления к ним префиксов при помощи тегов, например $T_{agg} =$ ``Multisig\_Aggregation". Мы оставляем теги для примеров, таких как подписи Шнорра, которые приводятся в следующем разделе.}\footnote{Важно включать $\mathbb{S}^{base}$ в агрегированные хеши, так как это позволит избежать атак с аннулированием ключей, включающих обобщенное решение Вагнера для «парадокса дней рождения» \cite{generalized-birthday-wagner}. \cite{adam-wagnerian-tragedies} \cite{maxwell2018simple-musig}}\vspace{.175cm}
\[K^{s,grp} = \sum_e \mathcal{H}_n(T_{agg},\mathbb{S}^{base},K^{s,base}_e)K^{s,base}_e\]

Теперь, если Боб попытается аннулировать ключ траты Элис, он столкнется с очень сложной проблемой.\vspace{.175cm}
\begin{align*}
    K^{s,grp} &= \mathcal{H}_n(T_{agg},\mathbb{S},K^{s}_A)K^{s}_A + \mathcal{H}_n(T_{agg},\mathbb{S},K'^{s}_B)K'^{s}_B \\
             &= \mathcal{H}_n(T_{agg},\mathbb{S},K^{s}_A)K^{s}_A + \mathcal{H}_n(T_{agg},\mathbb{S},K'^{s}_B)K^{s}_B - \mathcal{H}_n(T_{agg},\mathbb{S},K'^{s}_B)K^{s}_A \\
             &= [\mathcal{H}_n(T_{agg},\mathbb{S},K^{s}_A) - \mathcal{H}_n(T_{agg},\mathbb{S},K'^{s}_B)]K^{s}_A + \mathcal{H}_n(T_{agg},\mathbb{S},K'^{s}_B)K^{s}_B
\end{align*}

Мы предлагаем читателю самому представить всю степень разочарования Боба.

Как и в случае с простейшим подходом, любая третья сторона, которой будет известен $\mathbb{S}^{base}$ и соответствующие публичные ключи просмотра, сможет вычислить групповой адрес.

Поскольку участникам не нужно доказывать, что им известны их приватные ключи траты, или взаимодействовать друг с другом, прежде чем подписать транзакцию, наш способ надёж\-ной агрегации ключей соответствует так называемой модели простого публичного ключа, где единственное требование состоит в том, чтобы у каждого потенциального подписанта имелся публичный ключ \cite{maxwell2018simple-musig}.\footnote{Как будет указано далее, агрегирование ключей соответствует только простой модели публичного ключа для схем multisig «N из N» и «1 из N».}

\subsubsection*{Функции {\tt premerge} и {\tt merge}}

Более формально и для ясности в будущем мы обозначим, что существует операция {\tt premerge (предварительного слияния)}, которая берёт набор базовых ключей $\mathbb{S}^{base}$ и выдаёт набор агрегированных ключей $\mathbb{K}^{agg}$ равного размера, где элемент\footnote{Примечание: $\mathbb{K}^{agg}[e]$ iявляется членом $e$-нного множества.}
\[\mathbb{K}^{agg}[e] = \mathcal{H}_n(T_{agg},\mathbb{S}^{base},K^{s,base}_e)K^{s,base}_e\]

Агрегированные приватные ключи $k^{agg}_e$ используются в групповых подписях.\footnote{Надёжный вариант агрегации ключей ещё не реализован в Monero, но поскольку участники могут хранить и использовать приватный ключ $k^{agg}_e$ (для простейшего варианта агрегации ключей, $k^{agg}_e = k^{base}_e$), обновление Monero с целью использования надёжного варианта агрегации ключей изменит только процесс выполнения операции premerge.}

Существует ещё одна операция, которая называется {\tt merge (слияние)}. При её выполнении берутся агрегированные ключи, полученные после выполнения операции {\tt premerge}, и создаёт\-ся групповой подписывающий ключ (например, в случае Monero это будет ключ траты).\vspace{.175cm}
\[K^{grp} = \sum_e \mathbb{K}^{agg}[e]\]

Мы обобщаем эти функции для схем «(N-1) из N» и «M из N» в подпункте \ref{sec:n-1-of-n} и далее обобщаем их для вложенных мультиподписей в подпункте \ref{subsec:nesting-multisig-keys}.



\section{Пороговые подписи, подобные подписям Шнорра}
\label{sec:threshold-schnorr}

Чтобы мультиподпись работала, требуется определённое количество подписывающих лиц, поэтому существует определённое «пороговое значение» для количества подписывающих лиц, ниже которого подпись не может быть создана. Мультиподпись, создаваемая N участниками, то есть требующая наличия подписи всех N участников и обычно называемая {\em мультипод\-писью «N из N»}, будет иметь пороговое значение N. Позже это можно расширить до схемы «M из N» (при M $\leq$ N), где N участников создают групповой адрес, но для создания подписи требуется только M человек.

Давайте немного отойдём от Monero. Все схемы подписей в этом документе основаны на общем доказательстве знания с нулевым разглашением Маурера \cite{simple-zk-proof-maurer}, поэтому мы можем продемонстрировать определяющую форму пороговых подписей, используя простую подпись, подобную подписи Шнорра (см. подпункт \ref{sec:signing-messages}) \cite{old-multisig-mrl-note}.


\subsection*{Подпись}

Допустим, есть N пользователей, каждый из которых имеет публичный ключ в наборе $\mathbb{K}^{agg}$, где каждому пользователю $e \in \{1,...,N\}$ известен приватный ключ $k^{agg}_e$. Их групповым публичным ключом «N из N», который они будут использовать для подписи сообщений, будет $K^{grp}$. Предположим, они хотят вместе подписать сообщение $\mathfrak{m}$. Они могли бы вместе создать базовую подпись, подобную подписи Шнорра, следующим образом
\begin{enumerate}
    \item Каждый участник $e \in \{1,...,N\}$ делает следующее:
    \begin{enumerate}
        \item выбирает случайный компонент $\alpha_e \in_R \mathbb{Z}_l$,
        \item вычисляет $\alpha_e G$
        \item создаёт для него обязательство при помощи $C^{\alpha}_e = \mathcal{H}_n(T_{com},\alpha_e G)$,
        \item безопасным образом отправляет $C^{\alpha}_e$ другим участникам.
    \end{enumerate}
    \item Как только все обязательства $C^{\alpha}_e$ будут собраны, каждый из участников безопасным образом отправляет свои $\alpha_e G$ другим участникам. Они должны верифицировать $C^{\alpha}_e \stackrel{?}{=} \mathcal{H}_n(T_{com},\alpha_e G)$ для всех остальных участников.
    \item Каждый участник вычисляет
    \[ \alpha G = \sum_e \alpha_e G \]
    \item Каждый участник $e \in \{1,...,N\}$ делает следующее:\footnote{Как сказано в подпункте \ref{sec:schnorr-fiat-shamir}, важно не использовать повторно $\alpha_e$ для решения различных запросов $c$. Это означает, что для перезапуска процесса создания мультиподписи, когда ответы уже были отправлены, необходимо начать всё заново с новых значений $\alpha_e$.}
    \begin{enumerate}
        \item вычисляет запрос $c = \mathcal{H}_n(\mathfrak{m},[\alpha G])$,
        \item определяет компонент запроса $r_e = \alpha_e - c* k^{agg}_e \pmod l$,
        \item безопасным образом отправляет re другим участникам.
    \end{enumerate}
    \item Каждый участник вычисляет 
    \[ r = \sum_e r_e\]
    \item Любой участник может опубликовать подпись $\sigma(\mathfrak{m}) = (c,r)$.
\end{enumerate}


\subsection*{Верификация}

При наличии $K^{grp}$ $\mathfrak{m}$ и $\sigma(\mathfrak{m}) = (c,r)$ выполняем следующее:
\begin{enumerate}
    \item Вычисляем запрос $c' = \mathcal{H}_n(\mathfrak{m},[r G + c*K^{grp}])$.
    \item Если $c = c'$, подпись является легитимной, за исключением незначительной вероятности.
\end{enumerate}

Мы включили надстрочный индекс $grp$ для ясности, но на самом деле верификатор не будет знать, является ли $K^{grp}$ объединённым ключом, если участник не скажет ему об этом или пока он не узнает компоненты базового или агрегированного ключа.


\subsection*{Почему это работает}

Ответ $r$ является основой этой подписи. Участнику $e$ известны два секрета в $r_e$ ($\alpha_e$ и $k^{agg}_e$), поэтому его приватный ключ $k^{agg}_e$ информационно-теоретически защищён от других участников (при условии, что $\alpha_e$ никогда не будет использован повторно). Более того, вери\-фикаторы используют групповой публичный ключ $K^{grp}$, поэтому для построения подписи требуются все ключевые компоненты.
\begin{align*}
    r G &= (\sum_e r_e) G \\
      &= (\sum_e (\alpha_e - c*k^{agg}_e)) G \\
      &= (\sum_e \alpha_e) G - c*(\sum_e k^{agg}_e) G \\
      &= \alpha G - c*K^{grp} \\
    \alpha G &= r G + c*K^{grp} \\
    \mathcal{H}_n(\mathfrak{m},[\alpha G]) &= \mathcal{H}_n(\mathfrak{m},[r G + c*K^{grp}]) \\
    c &= c'
\end{align*}


\subsection*{Дополнительный этап обязательства и раскрытия}

Читателя может заинтересовать, откуда взялся этот Этап 2. Без этапа обязательства и раскрытия \cite{MRL-0009-multisig} недобросовестный участник подписания может узнать все $\alpha_e G$ {\em до того}, как будет вычислен запрос. Это позволит ему в некоторой степени контролировать создаваемый запрос путём изменения собственного $\alpha_e G$ перед отправкой. Он может использовать компо\-ненты ответа, собранные из нескольких контролируемых подписей, для выведения приватных ключей $k^{agg}_e$ других подписантов за субэкспоненциальное время \cite{cryptoeprint:2018:417}, что представляет собой серьёзную угрозу с точки зрения безопасности. В основе данной угрозы лежит обобщение Вагнера \cite{generalized-birthday-wagner} (см. также работу \cite{adam-wagnerian-tragedies}, содержащую более содержательное объяснение) пара\-докса дней рождения \cite{birthday-problem}.\footnote{Этап обязательства и раскрытия не используется в текущем варианте реализации мультиподписи Monero, хотя его введение и возможно в будущих версиях. \cite{multisig-research-issue-67}}



\section{Кольцевые конфиденциальные подписи MLSTAG в Monero}
\label{sec:MLSTAG-RingCT}

Транзакции Monero, использующие пороговые конфиденциальные кольцевые подписи, пред\-полагают наличие некоторой сложности, поскольку подписывающие ключи MLSTAG (поро\-говой подписи MLSAG) являются одноразовыми адресами и обязательствами по нулевой сумме (для сумм во входах).

Как говорилось в подпункте \ref{sec:multi_out_transactions}, одноразовый адрес, определяющий принадлежность $t$-ного выхода транзакции тому, у кого есть публичный адрес $(K^v_t,K^s_t)$, выглядит следующим образом:\vspace{.175cm}
\begin{align*}
  K_t^o &= \mathcal{H}_n(r K_t^v, t)G + K_t^s = (\mathcal{H}_n(r K_t^v, t) + k_t^s)G  \\ 
  k_t^o &= \mathcal{H}_n(r K_t^v, t) + k_t^s
\end{align*} 

Мы можем обновить наше обозначение выходов, полученных по групповому адресу\linebreak $(K^{v,grp}_t,K^{s,grp}_t)$:\vspace{.175cm}
\begin{align*}
  K^{o,grp}_t &= \mathcal{H}_n(r K^{v,grp}_t, t)G + K^{s,grp}_t  \\ 
  k^{o,grp}_t &= \mathcal{H}_n(r K^{v,grp}_t, t) + k^{s,grp}_t
\end{align*}

Как и раньше, любой, у кого есть $k^{v,grp}_t$ и $K^{s,grp}_t$, может обнаружить, что $K^{o,grp}_t$ является выходом, принадлежащим его адресу, и расшифровать элемент алгоритма Диффи-Хеллмана для суммы выхода, после чего восстановить соответствующую маску обязательства (см. под\-пункт \ref{sec:pedersen_monero}). 

Это также означает возможность использования подадресов с мультиподписями (см. под\-пункт \ref{sec:subaddresses}). Создание multisig-транзакций, использующих средства, полученные на подадрес, требует внесения некоторых простых изменений в алгоритмы, которые упоминаются в снос\-ках.\footnote{Подадреса multisig поддерживаются в Monero.}


\subsection{Транзакции {\tt RCTTypeBulletproof2}, построенные по схеме multisig \linebreak «N из N»}
\label{sec:rcttypebulletproof2-multisig}

Большинство составляющих multisig-транзакции может быть выполнено тем, кто ее иниции\-ровал. И только подписи MLSTAG требуют сотрудничества. Чтобы подготовиться к транзак\-ции типа {\tt RCTTypeBulletproof2}, инициатор должен сделать следующее (см. подпункт \ref{sec:RCTTypeBulletproof2}):
\begin{enumerate}
    \item Сгенерировать приватный ключ транзакции $r \in_R \mathbb{Z}_l$ (см. подпункт \ref{sec:one-time-addresses}) и вычислить соответствующий публичный ключ $r G$ (или несколько таких ключей, если получатель использует подадреса; см. подпункт \ref{sec:subaddresses}).
    \item Определить, какие входы будут потрачены ($j \in \{1,...,m\}$ собственные выходы с однора\-зовыми адресами $K^{o,grp}_j$ и суммами $a_1,...,a_m$), и получателей, которые получат средства ($t \in \{0,...,p-1\}$ из новых выходов с суммами $b_0,...,b_{p-1}$ и одноразовые адреса $K^{o}_t$). Сюда входит комиссия $f$, получаемая майнером, и его обязательство $f H$. Затем определить набор ложных участников кольца для каждого входа.
    \item Зашифровать сумму каждого $\mathit{amount}_t$ (см. подпункт \ref{sec:pedersen_monero}) и вычислить обязательства по выходу $C^b_t$.
    \item Выбрать для каждого входа $j \in \{1,...,m-1\}$ компоненты маски обязательства по псевдо-выходу $x'_{j} \in_R \mathbb{Z}_l$ и вычислить $m$-ную маску следующим образом (см. подпункт \ref{sec:ringct-introduction})
    \[x'_m = \sum_t y_t - \sum_{j=1}^{m-1} x'_j\]
    Вычислить обязательства по псевдо-выходу $C'^a_{j}$.
    \item Создать агрегированное доказательство диапазона Bulletproof для всех выходов. См. подпункт \ref{sec:range_proofs}.
    \item Подготовиться к созданию подписей MLSTAG, сгенерировав начальные компоненты $\alpha^z_{j} \in_R \mathbb{Z}_l$ для обязательств по нулевой сумме и вычислив $\alpha^z_{j} G$.\footnote{Здесь нет никакой необходимости в этапе обязательства и раскрытия, поскольку обязательства по нулевой сумме известны всем подписантам.}
\end{enumerate}

После этого инициатор безопасным образом отправляет всю эту информацию другим участ\-никам. Теперь группа подписантов готова к созданию подписей входов при помощи своих приватных ключей $k^{s,agg}_e$ и обязательств по нулевой сумме $C^a_{\pi,j} - C'^a_{\pi,j} = z_j G$.

\subsubsection*{MLSTAG RingCT}

Сначала\marginnote{src/wallet/ wallet2.cpp {\tt sign\_multi- sig\_tx()}} создаются образы групповых ключей для всех входов $j \in \{1,...,m\}$ с одноразовыми адресами $K^{o,grp}_{\pi,j}$.\footnote{Если $K^{o,grp}_{\pi,j}$ построена на основе multisig-подадреса с индексом $i$, то (см. подпункт \ref{sec:subaddresses}) приватный ключ будет составным:
\[k^{o,grp}_{\pi,j} = \mathcal{H}_n(k^{v,grp} r_{u_j} K^{s,grp,i}, u_j) + \sum_e k^{s,agg}_e + \mathcal{H}_n(k^{v,grp},i)\]}
\begin{enumerate}
    \item Для каждого входа $j$ каждый участник $e$ выполняет следующее:
    \begin{enumerate}
        \item вычисляет частичный образ ключа $\tilde{K}^{o}_{j,e} = k^{s,agg}_e \mathcal{H}_p(K^{o,grp}_{\pi,j})$,
        \item безопасным образом отправляет $\tilde{K}^{o}_{j,e}$ другим участникам.
    \end{enumerate}
    \item Теперь каждый участник, используя $u_j$ в качестве индекса выход транзакции, может вычислить, куда именно $K^{o,grp}_{\pi,j}$ был отправлен на multisig-адрес,\footnote{Если одноразовый адрес соответствует multisig-подадресу с индексом $i$, следует добавить\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt generate\_key\_ image\_helper\_ precomp()}}
    \[\tilde{K}^{o,grp}_j = ... + \mathcal{H}_n(k^{v,grp},i) \mathcal{H}_p(K^{o,grp}_{\pi,j})\]}
    \[\tilde{K}^{o,grp}_j = \mathcal{H}_n(k^{v,grp} r G, u_j) \mathcal{H}_p(K^{o,grp}_{\pi,j}) + \sum_e \tilde{K}^{o}_{j,e}\]
\end{enumerate}

Затем для каждого входа $j$ создаётся подпись MLSTAG.
\begin{enumerate}
    \item Каждый участник $e$ делает следующее:
    \begin{enumerate}
        \item генерирует\marginnote{src/wallet/ wallet2.cpp {\tt get\_multi- sig\_kLRki()}} начальные компоненты $\alpha_{j,e} \in_R \mathbb{Z}_l$ и вычисляет $\alpha_{j,e} G$  $\alpha_{j,e} \mathcal{H}_p(K^{o,grp}_{\pi,j})$,
        \item генерирует случайные компоненты $r_{i,j,e}$ и $i \in \{1,...,v+1\}$ для $r^z_{i,j,e}$, за исключением случаев, когда $i = \pi$
        \item вычисляет обязательство
        \[C^{\alpha}_{j,e} = \mathcal{H}_n(T_{com},\alpha_{j,e} G, \alpha_{j,e} \mathcal{H}_p(K^{o,grp}_{\pi,j}),r_{1,j,e},...,r_{v+1,j,e},r^z_{1,j,e},...,r^z_{v+1,j,e})\]
        \item безопасным образом отправляет $C^{\alpha}_{j,e}$ другим участникам.
    \end{enumerate}
    \item После получения всех $C^{\alpha}_{j,e}$ от других участников отправляется все $\alpha_{j,e} G$, $\alpha_{j,e} \mathcal{H}_p(K^{o,grp}_{\pi,j})$, $r_{i,j,e}$, и $r^z_{i,j,e}$ и проверяет легитимность исходных обязательств каждого участника.
    \item Каждый участник может вычислить все
    \begin{align*}
        \alpha_{j} G &= \sum_e \alpha_{j,e} G\\
        \alpha_{j} \mathcal{H}_p(K^{o,grp}_{\pi,j}) &= \sum_e \alpha_{j,e} \mathcal{H}_p(K^{o,grp}_{\pi,j})\\
        r_{i,j} &= \sum_e r_{i,j,e}\\
        r^{z}_{i,j} &= \sum_e r^z_{i,j,e}
    \end{align*}{}
    \item Каждый участник может построить цикл подписи (см. подпункт \ref{sec:MLSAG}).
    \item Чтобы завершить подпись, каждый участник $e$ делает следующее:
    \begin{enumerate}
        \item определяет $r_{\pi,j,e} = \alpha_{j,e} - c_{\pi} k^{s,agg}_e \pmod l$,
        \item безопасным образом отправляет $r_{\pi,j,e}$ другим участникам.
    \end{enumerate}
    \item Каждый\marginnote{src/ringct/ rctSigs.cpp {\tt signMulti- sig()}} может вычислить (учитывая, что $\alpha^z_{j,e}$ была создана инициатором транзакции)\footnote{Если одноразовый адрес $K^{o,grp}_{\pi,j}$ соответствует multisig-подадресу с индексом $i$, следует добавить\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt generate\_key\_ image\_helper\_ precomp()}}
    \[r_{\pi,j} = ... - c_{\pi}*\mathcal{H}_n(k^{v,grp},i)\]}\vspace{.175cm}
    \[r_{\pi,j} = \sum_e r_{\pi,j,e} - c_{\pi}*\mathcal{H}_n(k^{v,grp} r G, u_j)\]
    \[r^{z}_{\pi,j} = \alpha^z_{j,e} - c_{\pi} z_j \pmod l\]
\end{enumerate}

Подпись для входа $j$ будет $\sigma_j(\mathfrak{m}) = (c_1,r_{1,j},r^{z}_{1,j},...,r_{v+1,j},r^{z}_{v+1,j})$ с $\tilde{K}^{o,grp}_j$.

Поскольку в случае с Monero сообщение $\mathfrak{m}$ и запрос $c_{\pi}$ зависят от всех других частей транзак\-ции, любой участник, который попытается обмануть остальных участников, отправив им неправильное значение в какой-либо момент реализации процесса, сделает так, что подпись просто будет недействительной. Ответ $r_{\pi,j}$ полезен только для $\mathfrak{m}$ и $c_{\pi}$, для которых он и определён.


\subsection{Упрощённый вариант обмена данными}
\label{sec:simplified-communication}

Для создания транзакции Monero с мультиподписью требуется пройти множество этапов. Мы можем реорганизовать и упростить некоторые из них, чтобы взаимодействие подписантов происходило в два этапа в совокупности всего за пять раундов.
\begin{enumerate}
    \item {\it Агрегация ключей для публичного nultisig-адреса}: любой, у кого имеется набор публич\-ных адресов, может выполнить с ними операцию {\tt premerge}, а затем объединить их (операция {\tt merge}) в адрес «N из N», но ни один из участников не будет знать групповой ключ просмотра до тех пор, пока не узнает все компоненты. Поэтому создание группы начинается с безопасного обмена $k^{v}_e$ и $K^{s,base}_e$ между участниками\marginnote{src/wallet/ wallet2.cpp {\tt pack\_multi- signature\_ keys()}}. Любой участник может выполнить операции {\tt premerge} и {\tt merge} и опубликовать $(K^{v,grp},K^{s,grp})$, что позво\-лит группе получать средства на групповой адрес. Агрегирование по схеме «M из N» требует прохождения дополнительных этапов, описанных в подпункте \ref{sec:smaller-thresholds}.
    \item {\it Транзакции}:
    \begin{enumerate}
        \item Какой-то участник или подгруппа участников (инициатор)\marginnote{src/wallet/ wallet2.cpp {\tt transfer\_ selected\_ rct()}} решает создать транзак\-цию. Он выбирает $m$ входов с одноразовыми адресами $K^{o,grp}_{j}$ и обязательствами по сумме $C^a_j$, $m$ наборов из $v$ дополнительных одноразовых адресов и обязательства, которые будут использоваться в кольце в качестве ложных, выбирает $p$ получателей выходов с публичными адресами $(K^v_t,K^s_t)$ и суммами $b_t$, которые будут им отправ\-лены, определяет размер комиссии $f$ за транзакцию, выбирает приватный ключ транзакции $r$,\footnote{Или же приватные ключи транзакции $r_{t}$ при отправке хотя бы на один подадрес.} генерирует маски обязательств по псевдовыходам $x'_{j}$, где $j \neq m$, создаёт элемент ECDH $\mathit{amount}_t$ для каждого выхода, создаёт агрегированное доказательство диапазона и генерирует средства для открытия подписи $\alpha^z_j$ для всех обязательств по нулевой сумме входов и случайные скалярные величины $r_{i,j}$ и $r^z_{i,j}$ с $i \neq \pi_j$.\footnote{Следует отметить, что мы упрощаем процесс подписания, допуская, что инициатор будет генерировать случайные скалярные величины $r_{i,j}$ и $r^z_{i,j}$ вместо того, чтобы каждый из подписантов генерировал компоненты, которые в конечном счёте будут суммироваться.} Также он подготавливается к участию в следующем раунде обмена данными.\\

        Инициатор\marginnote{src/wallet/ wallet2.cpp {\tt save\_multi- sig\_tx()}} безопасным образом отправляет всю эту информацию другим участ\-никам.\footnote{От него не требуется отправлять суммы в выходах $b_t$ напрямую, так как они могут быть вычислены на основе $\mathit{amount}_t$. Monero использует разумный подход к созданию частичной транзакции, заполненной информацией, выбранной инициатором, и к её отправке другим подписантам вместе со списком соответствующей информации, такой как приватные ключи транзакции, адреса назначения, реальные входы и т. д.} Другие участники могут сообщить ему о своём согласии, отправив свою часть данных для следующего раунда, или же могут согласовывать изменения.
        \item Каждый участник выбирает свои открывающие подпись (подписи) MLSTAG компо\-ненты, даёт по ним обязательства, вычисляет частичные образы ключей и безопас\-ным образом отправляет эти обязательства и частичные образы другим участникам.\\

        Подпись (подписи) MLSTAG: образ ключа $\tilde{K}^{o}_{j,e}$, степень случайности подписи $\alpha_{j,e} G$ и $\alpha_{j,e} \mathcal{H}_p(K^{o,grp}_{\pi,j})$. Частичные образы ключей необязательно должны присутствовать в данных, по которым даются обязательства, поскольку их нельзя использовать для извлечения приватных ключей подписантов. Они также позволяют посмотреть, какие из имеющихся выходов были потрачены. Поэтому в целях сохранения мо\-дульной структуры их следует обрабатывать отдельно.% In line with that modularity, since participants could provide fake partial images in order to fool other participants (e.g. non-signing ones) into thinking an owned output is unspent, it is necessary to create a proof of legitimacy for all partial key images using the method from Section \ref{dualbase proof}.
        \item После получения всех обязательств подписи каждый участник безопасным образом отправляет информацию, по которой были даны обязательства, другим участникам.
        \item EКаждый участник закрывает свою часть подписи (подписей) MLSTAG, безопас\-ным образом отправляя все $r_{{\pi_j},j,e}$ другим участникам.\footnote{Крайне важно, чтобы при каждой попытке подписания со стороны подписанта использовались уникальные $\alpha_{j,e}$, так как это позволяет избежать раскрытия приватного ключа траты этой стороны другим подписантам (см. подпункт \ref{sec:schnorr-fiat-shamir}) \cite{MRL-0009-multisig}. Кошельки должны строго соблюдать это правило и удалять\marginnote{src/wallet/ wallet2.cpp {\tt save\_multi- sig\_tx()}} $\alpha_{j,e}$ всякий раз, когда ответ, в котором используется этот компонент, передаётся куда-либо за пределы кошелька.}
    \end{enumerate}
\end{enumerate}

Если процесс был реализован успешно, все участники могут закончить создание транзакции и транслировать её самостоятельно. Транзакции, созданные участниками, использующими схему multisig, неотличимы от транзакций, созданных отдельными пользователями.



\section{Пересчёт образов ключей}
\label{sec:recalculating-key-images-multisig}

Если кто-то потеряет свои записи и захочет вычислить баланс на своём адресе (полученные средства минус потраченные средства), ему будет необходимо свериться с данными блокчейна. Ключи просмотра позволяют узнать только то, сколько было получено. Поэтому пользовате\-лям необходимо вычислить образы ключей всех принадлежащих им выходов и сравнить их с образами ключей, которые хранятся в блокчейне, чтобы узнать, были ли они потрачены. Поскольку участники группового адреса не имеют возможности вычислить образы ключей самостоятельно, им требуется заручиться поддержкой других участников.

Вычисление образов ключей на основе простой суммы компонентов может быть безуспешным, если недобросовестные участники передадут ложные ключи.\footnote{В настоящее время Monero\marginnote{src/wallet/ wallet2.cpp {\tt export\_multi- sig()}} использует простую сумму.} При наличии полученного выхода с одноразовым адресом $K^{o,grp}$ группа может создать простое «связываемое» доказа\-тельство, подобное доказательству Шнорра (в основном bLSTAG с одним ключом, см. под\-пункты \ref{sec:proofs-discrete-logarithm-multiple-bases} и \ref{blsag_note}), чтобы доказать, что образ $\tilde{K}^{o,grp}$ ключа является легитимным, не раскрывая при этом приватных компонентов ключа траты и без необходимости в каком-либо доверии друг к другу.


\subsection*{Доказательство}

\begin{enumerate}
    \item Каждый участник $e$ делает следующее:
    \begin{enumerate}
        \item вычисляет $\tilde{K}^{o}_{e} = k^{s,agg}_e \mathcal{H}_p(K^{o,grp})$,
        \item генерирует начальный компонент $\alpha_e \in_R \mathbb{Z}_l$ и вычисляет $\alpha_e G$ и $\alpha_e \mathcal{H}_p(K^{o,grp})$,
        \item даёт обязательства по данным, используя $C^{\alpha}_{e} = \mathcal{H}_n(T_{com}, \alpha_e G, \alpha_e \mathcal{H}_p(K^{o,grp}))$,
        \item безопасным образом отправляет $C^{\alpha}_{e}$ и $\tilde{K}^{o}_{e}$ другим участникам.
    \end{enumerate}
    \item После получения всех $C^{\alpha}_{e}$ каждый участник отправляет информацию, по которой были даны обязательства, и проверяет, являются ли обязательства других участников леги\-тимными.
    \item Каждый участник может вычислить:\footnote{Если одноразовый адрес соответствует multisig-подадресу с индексом $i$, следует добавить
    \[\tilde{K}^{o,grp} = ... + \mathcal{H}_n(k^{v,grp},i) \mathcal{H}_p(K^{o,grp})\]}\vspace{.175cm}
    \[\tilde{K}^{o,grp} = \mathcal{H}_n(k^{v,grp} r G, u) \mathcal{H}_p(K^{o,grp}) + \sum_e \tilde{K}^{o}_{e}\]
    \[\alpha G = \sum_e \alpha_{e} G\]
    \[\alpha \mathcal{H}_p(K^{o,grp}) = \sum_e \alpha_{e} \mathcal{H}_p(K^{o,grp})\]
    \item Каждый участник вычисляет запрос\footnote{Данное доказательство должно использовать разделение по доменам и добавление префикса к ключам, которые мы опускаем для краткости.}\vspace{.175cm}
    \[c = \mathcal{H}_n([\alpha G],[\alpha \mathcal{H}_p(K^{o,grp})])\]
    \item Каждый участник делает следующее:
    \begin{enumerate}
        \item определяет $r_e = \alpha_e - c*k^{s,agg}_e \pmod l$,
        \item безопасным образом отправляет $r_e$ другим участникам.
    \end{enumerate}
    \item Каждый участник может вычислить\footnote{Если одноразовый адрес $K^{o,grp}$ соответствует multisig-подадресу с индексом $i$, следует добавить
    \[r^{resp} = ... - c*\mathcal{H}_n(k^{v,grp},i)\]}\vspace{.175cm}
    \[r^{resp} = \sum_e r_e - c*\mathcal{H}_n(k^{v,grp} r G, u)\]
\end{enumerate}

Доказательство $(c,r^{resp})$ with $\tilde{K}^{o,grp}$.


\subsection*{Верификация}

\begin{enumerate}
    \item Проверить $l \tilde{K}^{o,grp} \stackrel{?}{=} 0$.
    \item Вычислить $c' = \mathcal{H}_n([r^{resp} G + c*K^{o,grp}],[r^{resp} \mathcal{H}_p(K^{o,grp}) + c*\tilde{K}^{o,grp}])$.
    \item Если $c = c'$, то образ ключа $\tilde{K}^{o,grp}$ соответствует одноразовому адресу $K^{o,grp}$ (за исклю\-чением ничтожной вероятности).
\end{enumerate}


    
\section{Меньшие пороговые значения}
\label{sec:smaller-thresholds}

В начале этой главы говорилось об эскроу-сервисах, использующих схему multisig «2 из 2» для разделения полномочий по созданию подписи между пользователем и компанией, отвечающей за обеспечение безопасности. Такая схема не идеальна, потому что, если компания подверг\-нется взлому или откажется от сотрудничества, ваши средства могут «зависнуть».

Такого варианта развития событий можно избежать, если использовать multisig-адрес по схеме «2 из 3», которая предполагает наличие трёх участников, но для подписания транзакций при этом нужны только двое из них. Эскроу-сервис предоставляет один ключ, а пользователи - два ключа. Пользователь может хранить один ключ в безопасном месте (например, в сейфе), а другой использовать для повседневных покупок. Если с эскроу-сервисом что-либо произойдёт, пользователь сможет использовать ключ безопасности и ключ для повседневного использования для вывода своих средств.

Мультиподписи с пороговым значением ниже N имеют широкий спектр применения.


\subsection{Агрегирование ключей по схеме «1 из N»}
\label{sec:1-of-n}

 Предположим, группа людей хочет создать multisig-ключ $K^{grp}$, который могли бы использо\-вать для подписания все участники. Решение тривиально: пусть всем будет известен приват\-ный ключ $k^{grp}$. Это можно сделать тремя способами.
\begin{enumerate}
    \item Один участник или подгруппа участников выбирает ключ и безопасным образом отправ\-ляет его всем остальным.
    \item Все участники вычисляют компоненты приватного ключа и безопасным образом отправ\-ляют их, используя простую сумму в качестве объединённого ключа.\footnote{Обратите внимание, что аннулирование ключа в данном случае довольно бессмысленно, потому что каждому участнику известен полный приватный ключ.}
    \item Участники расширяют мультиподпись «M из N» до «1 из N». Это поможет, если злоумышленник имеет доступ к сообщениям группы.
\end{enumerate}

В этом случае при использовании Monero все будут знать приватные ключи\linebreak $(k^{v,grp,{1\textrm{xN}}},k^{s,grp,{1\textrm{xN}}})$. До этого раздела все групповые ключи использовали схему «N из N», но теперь мы используем верхний индекс 1xN для обозначения ключей, связанных с подписью «1 из N»


\subsection{Агрегирование ключей по схеме «(N-1) из N»}
\label{sec:n-1-of-n}

В случае с групповым ключом, созданным по схеме «(N-1) из N», таким как «2 из 3» или «4 из 5», любая группа, состоящая из (N-1) участников, может подписать транзакцию. Мы достигаем этого при помощи общих секретов Диффи-Хеллмана. Допустим, есть участники $e \in \{1,...,N\}$ с базовыми публичными ключами $K^{base}_e$, которые известны им всем.

Каждый участник\marginnote{src/multi- sig/multi- sig.cpp {\tt generate\_ multisig\_ N1\_N()}} $e$ вычисляет $w \in \{1,...,N\}$, но $w \neq e$\vspace{.175cm}
\[k^{sh,\textrm{(N-1)xN}}_{e,w} = \mathcal{H}_n(k^{base}_e K^{base}_w)\]

Затем он вычисляет все $K^{sh,\textrm{(N-1)xN}}_{e,w} = k^{sh,\textrm{(N-1)xN}}_{e,w} G$ и безопасным образом отправляет результат другим участникам. Теперь мы используем верхний индекс $sh$ для обозначения ключей, являющихся общими для подгруппы участников.

У каждого участника будет в наличии (N-1) общих компонентов приватного ключа, соответ\-ствующих каждому компоненту других участников, что составит N*(N-1) ключей в совокуп\-ности между всеми. В соответствии с алгоритмом Диффи-Хеллмана все ключи используются двумя сторонами-участниками, поэтому на самом деле в наличии будет [N*(N-1)]/2 уникаль\-ных ключей. Эти уникальные ключи составляют набор $\mathbb{S}^{\textrm{(N-1)xN}}$.

\subsubsection*{Обобщение функций {\tt premerge} и {\tt merge}}

Здесь мы обновляем определение {\tt premerge} из подпункта \ref{sec:robust-key-aggregation}. В данном случае входом будет набор $\mathbb{S}^{\textrm{MxN}}$, где $M$ является «пороговым значением», для которого были подготовлены ключи из набора. Если $M = N$, $\mathbb{S}^{\textrm{NxN}} = \mathbb{S}^{base}$, а если $M < N$, значит, набор содержит общие ключи. Выходом является $\mathbb{K}^{agg,\textrm{MxN}}$.

Компоненты ключей [N*(N-1)]/2 в $\mathbb{K}^{agg,\textrm{(N-1)xN}}$ можно отправить для слияния (проведения операции {\tt merge}), и получить в результате $K^{grp,\textrm{(N-1)xN}}$. Важно отметить, что все компоненты приватного ключа [N*(N-1)]/2 могут быть собраны только при наличии (N-1) участников, поскольку каждый участник использует один общий секрет Диффи-Хеллмана с $N$-ым участ\-ником.

\subsubsection*{Пример схемы «2 из 3»}

Предположим, есть три человека, у которых есть публичные ключи $\{K^{base}_1,K^{base}_2,K^{base}_3\}$, и каждому из них известен приватный ключ. При этом они хотят создать multisig-ключ по схеме «2 из 3». После выполнения алгоритма Диффи-Хеллмана и обмена публичными ключами каждому из них будет известно следующее:
\begin{enumerate}
    \item Участник 1: $k^{sh,\textrm{2x3}}_{1,2}$, $k^{sh,\textrm{2x3}}_{1,3}$, $K^{sh,\textrm{2x3}}_{2,3}$
    \item Участник 2: $k^{sh,\textrm{2x3}}_{2,1}$, $k^{sh,\textrm{2x3}}_{2,3}$, $K^{sh,\textrm{2x3}}_{1,3}$
    \item Участник 3: $k^{sh,\textrm{2x3}}_{3,1}$, $k^{sh,\textrm{2x3}}_{3,2}$, $K^{sh,\textrm{2x3}}_{1,2}$
\end{enumerate}

Где $k^{sh,\textrm{2x3}}_{1,2} = k^{sh,\textrm{2x3}}_{2,1}$, и так далее. Набор $\mathbb{S}^{\textrm{2x3}} = \{ K^{sh,\textrm{2x3}}_{1,2}, K^{sh,\textrm{2x3}}_{1,3}, K^{sh,\textrm{2x3}}_{2,3}\}$.

В результате выполнения операций {\tt premerge} и {\tt merge} создаётся групповой ключ:\footnote{Поскольку объединённый ключ состоит из общих секретов, наблюдатель, которому известны только исходные базовые публичные ключи, не сможет объединить их (см. подпункт \ref{subsec:drawbacks-naive-aggregation-cancellation}) и идентифицировать участников, создавших объединённый ключ.}\vspace{.175cm}
\begin{align*}
    K^{grp,\textrm{2x3}} = &\mathcal{H}_n(T_{agg},\mathbb{S}^{\textrm{2x3}},K^{sh,\textrm{2x3}}_{1,2}) K^{sh,\textrm{2x3}}_{1,2} + \\
                           &\mathcal{H}_n(T_{agg},\mathbb{S}^{\textrm{2x3}},K^{sh,\textrm{2x3}}_{1,3}) K^{sh,\textrm{2x3}}_{1,3} + \\
                           &\mathcal{H}_n(T_{agg},\mathbb{S}^{\textrm{2x3}},K^{sh,\textrm{2x3}}_{2,3}) K^{sh,\textrm{2x3}}_{2,3}
\end{align*}

Теперь предположим, что участники 1 и 2 хотят подписать сообщение $\mathfrak{m}$. Для демонстрации мы будем использовать базовую подпись, подобную подписи Шнорра.
\begin{enumerate}
    \item Каждый участник $e \in \{1,2\}$ делает следующее:
    \begin{enumerate}
        \item выбирает случайный компонент $\alpha_e \in_R \mathbb{Z}_l$,
        \item вычисляет $\alpha_e G$,
        \item создаёт обязательство при помощи $C^{\alpha}_{e} = \mathcal{H}_n(T_{com},\alpha_e G)$,
        \item безопасным образом отправляет $C^{\alpha}_{e}$ другим участникам.
    \end{enumerate}
    \item После получения всех $C^{\alpha}_{e}$ каждый участник отправляет $\alpha_e G$ и проверяет, являются ли другие обязательства легитимными.
    \item Каждый участник вычисляет
    \[\alpha G = \sum_e \alpha_e G\]
    \[c = \mathcal{H}_n(\mathfrak{m},[\alpha G])\]
    \item Участник 1 делает следующее:
    \begin{enumerate}
        \item вычисляет $r_1 = \alpha_1 - c*[k^{agg,\textrm{2x3}}_{1,3} + k^{agg,\textrm{2x3}}_{1,2}]$,
        \item безопасным образом отправляет $r_1$ участнику 2.
    \end{enumerate}
    \item Участник 2 делает следующее:
    \begin{enumerate}
        \item вычисляет $r_2 = \alpha_2 - c*k^{agg,\textrm{2x3}}_{2,3}$,
        \item безопасным образом отправляет $r_2$ участнику 1.
    \end{enumerate}
    \item Каждый участник вычисляет 
    \[r = \sum_e r_e\]
    \item Любой из участников может опубликовать подпись $\sigma(\mathfrak{m}) = (c,r)$.
\end{enumerate}

Единственным изменением в случае с пороговыми подписями с пороговым значением ниже N является то, как путём определения $r_{\pi,e}$ «замыкается цикл» (в случае использования кольцевых подписей с секретным индексом $\pi$). Каждый участник должен включить свой общий секрет, соответствующий «отсутствующему участнику», но, поскольку все другие общие секреты дублируются, здесь есть уловка. При наличии набора исходных ключей всех участников $\mathbb{S}^{base}$ только {\em первый участник}, указываемый в $\mathbb{S}^{base}$ по индексу, вместе с копией общего секрета использует его для вычисления своего $r_{\pi,e}$.\footnote{На\marginnote{src/wallet/ wallet2.cpp {\tt transfer\_ selected\_ rct()}} практике это означает, что инициатор должен определить, какой поднабор из M подписантов будет подписывать данное сообщение. Если выяснится, что O подписантов желает подписать его при O $\geq$ M, инициатор сможет организовать множество одновременных попыток подписания поднабором из M участников в пределах O, что повысить шансы на успех. Monero использует этот подход. Также (что известно посвящённым) {\em исходный} список адресов, по которым будут направлены выходы, созданный инициатором, перетасовывается случайным образом, а затем этот «случайный» список используется при всех одновременных попытках подписания всеми остальными подписантами (это связано с флагом сокрытия {\tt shuffle\_outs}).}\footnote{В настоящее время Monero использует метод кругового подписания\marginnote{src/wallet/ wallet2.cpp {\tt sign\_multi- sig\_tx()}}, когда инициатор подписывает транзакцию, используя все свои приватные ключи, передаёт частично подписанную транзакцию другому подписанту, который также подписывает {\em её} всеми своими приватными ключами (которые ещё не использовались для подписания), который тоже передаёт её другому подписанту, и так далее до тех пор, пока последний подписант либо не опубликует транзакцию, либо не отправит её другим подписантам, чтобы те её опубликовали.}

В предыдущем примере участник 1 вычисляет\vspace{.175cm}
\[r_1 = \alpha_1 - c*[k^{agg,\textrm{2x3}}_{1,3} + k^{agg,\textrm{2x3}}_{1,2}]\] 

в то время как участник 2 вычисляет только
\[r_2 = \alpha_2 - c*k^{agg,\textrm{2x3}}_{2,3}\]

Тот же принцип применяется к вычислению образа группового ключа в multisig-транзакциях Monero с пороговым значением ниже N.


\subsection{Агрегирование ключей по схеме «M из N»}
\label{sec:m-of-n}

Схему «M из N» можно понять, немного изменив наше представление о схеме «(N-1) из N». В случае со схемой «(N-1) из N» каждый общий секрет между двумя публичными ключами, такой как $K^{base}_1$ и $K^{base}_2$, содержит два приватных ключа, $k^{base}_1 k^{base}_2 G$. Это секрет, поскольку только участник 1 может вычислить $k^{base}_1 K^{base}_2$, и только участник 2 может вычислить\linebreak $k^{base}_2 K^{base}_1$.

А что, если бы существовал третий участник $K^{base}_3$, общие секреты $k^{base}_1 k^{base}_2 G$, $k^{base}_1 k^{base}_3 G$ и $k^{base}_2 k^{base}_3 G$, а участники обменивались бы публичными ключами между собой (что более не делало бы их секретом)? Каждый из участников добавил приватный ключ к двум публичным ключам. Теперь, скажем, они создают общий секрет с использованием третьего публичного ключа.

Участник 1\marginnote{src/multi- sig/multi- sig.cpp {\tt generate\_ multisig\_ deriv- ations()}} вычисляет общий секрет $k^{base}_1*(k^{base}_2 k^{base}_3 G)$, участник 2 вычисляет общий секрет $k^{base}_2*(k^{base}_1 k^{base}_3 G)$, а участник 3 вычисляет $k^{base}_3*(k^{base}_1 k^{base}_2 G)$. Теперь всем им известен $k^{base}_1 k^{base}_2 k^{base}_3 G$, что является трёхсторонним общим секретом (при условии, что никто не опубликует его).

Группа могла бы использовать $k^{sh,\textrm{1x3}} = \mathcal{H}_n(k^{base}_1 k^{base}_2 k^{base}_3 G)$ в качестве общего приватного ключа и опубликовать\vspace{.155cm} \[K^{grp,\textrm{1x3}} = \mathcal{H}_n(T_{agg},\mathbb{S}^{\textrm{1x3}},K^{sh,\textrm{1x3}}) K^{sh,\textrm{1x3}}\] как multisig-адрес, построенный по схеме «1 из 3».

В случае со схемой multisig «3 из 3» у каждого участника имеется секрет, в мультиподписи, построенной по схеме «2 из 3», каждая группа, состоящая из 2 участников, имеет общий секрет, а в случае со схемой «1 из 3» общий секрет имеется у каждой группы из трёх участников.

Теперь мы можем обобщить схему «M из N»: у каждой возможной группы, состоящей из (N-M + 1) участников, будет иметься общий секрет \cite{old-multisig-mrl-note}. В случае отсутствия (N-M) участников все их общие секреты принадлежат, по крайней мере, одному из M оставшихся участников, которые могут совместно подписать транзакцию при помощи группового ключа.

\subsubsection*{Алгоритм построения мультиподписи по схеме «M из N»}

При наличии участников $e \in \{1,...,N\}$ с исходными приватными ключами $k^{base}_1,...,k^{base}_N$, желающими создать объединённый ключ по схеме «M $\leq$ N» (где M $\geq$ 1 и N $\geq$ 2), мы можем использовать\marginnote{src/wallet/ wallet2.cpp {\tt exchange\_ multisig\_ keys()}} интерактивный алгоритм.

Для обозначения всех {\em уникальных} публичных ключей на этапе $\mathbb{S}_s$ используем $s \in \{0,...,(N-M)\}$. Окончательный набор $\mathbb{S}_{N-M}$ упорядочивается в соответствии с соглашением о распреде\-лении (например, от наименьшего к большему численно, то есть лексикографически). Данные обозначения используются для удобства, а $\mathbb{S}_s$ означает то же, что обозначало $\mathbb{S}^{\textrm{(N-s)xN}}$ в предыдущих подпунктах.

Для обозначения набора публичных ключей, созданных каждым участником на этапе $s$ алгоритма, используем $\mathbb{S}^K_{s,e}$. В начале $\mathbb{S}^K_{0,e} = \{K^{base}_e\}$.

В конце набор $\mathbb{S}^{k}_{e}$ будет содержать приватные ключи агрегации каждого участника.
\begin{enumerate}
    \item Каждый участник $e$ безопасным образом отправляет свой исходный набор публичных ключей $\mathbb{S}^K_{0,e} = \{K^{base}_e\}$ другим участникам.
    \item Каждый участник строит $\mathbb{S}_{0}$, собирая все $\mathbb{S}^K_{0,e}$ и удаляя дубликаты.
    \item На этапе $s \in \{1,...,(N-M)\}$ (пропускаем, если M = N)
    \begin{enumerate}
        \item Каждый участник $e$ делает следующее:
        \begin{enumerate}
            \item Для каждого элемента $g_{s-1}$ $\mathbb{S}_{s-1} \notin \mathbb{S}^K_{s-1,e}$ вычисляет новый общий секрет \[k^{base}_e*\mathbb{S}_{s-1}[g_{s-1}]\]
            \item Использует все новые общие секреты в $\mathbb{S}^K_{s,e}$.
            \item Если $s = (N-M)$, вычисляет общий приватный ключ для каждого элемента $x$ в $\mathbb{S}^K_{N-M,e}$
            \[\mathbb{S}^{k}_{e}[x] = \mathcal{H}_n(\mathbb{S}^K_{N-M,e}[x])\]

           и переписывает публичный ключ, задав $\mathbb{S}^K_{N-M,e}[x] = \mathbb{S}^{k}_{e}[x]*G$.
            \item Отправляет $\mathbb{S}^K_{s,e}$ остальным участникам.
        \end{enumerate}
        \item Каждый участник строит $\mathbb{S}_{s}$ путём сбора всех $\mathbb{S}^K_{s,e}$ и удаления дубликатов.\footnote{Участники должны отслеживать, какие будут ключи и у кого они окажутся на последнем этапе ($s = N-M$), что облегчит совместное подписание, так как только первый участник в $\mathbb{S}_0$ с определённым приватным ключом использует его для подписи. См. подпункт \ref{sec:n-1-of-n}.}
    \end{enumerate}
    \item Каждый участник распределяет $\mathbb{S}_{N-M}$ в соответствии с соглашением.
    \item Функция {\tt premerge} использует $\mathbb{S}_{(N-M)}$ в качестве вводных данных и каждый ключ агрегации для \(g \in \{1,...,(\textrm{size of }\mathbb{S}_{N-M})\}\),\vspace{.175cm}
    \[\mathbb{K}^{agg,\textrm{MxN}}[g] = \mathcal{H}_n(T_{agg},\mathbb{S}_{(N-M)},\mathbb{S}_{(N-M)}[g])*\mathbb{S}_{(N-M)}[g]\]
    \item Функция {\tt merge} использует $\mathbb{K}^{agg,\textrm{MxN}}$ в качестве вводных данных, а групповой ключ будет следующим\vspace{.175cm}
    \[K^{grp,\textrm{MxN}} = \sum^{\textrm{size of }\mathbb{S}_{N-M}}_{g = 1} \mathbb{K}^{agg,\textrm{MxN}}[g]\]
    \item Каждый участник $e$ переписывает каждый элемент $x$ в $\mathbb{S}^k_{e}$ при помощи своего приватного ключа агрегации.\vspace{.175cm}
    \[ \mathbb{S}^k_{e}[x] = \mathcal{H}_n(T_{agg},\mathbb{S}_{(N-M)},\mathbb{S}^k_{e}[x] G)*\mathbb{S}^k_{e}[x] \]
\end{enumerate}

Примечание: если пользователи хотят иметь неравные полномочия при создании мультипод\-писи, например 2 «голоса» при использовании схемы «3 из 4», им следует использовать несколько компонентов стартового ключа, а не повторно использовать один и тот же.



\section{Семейства ключей}
\label{sec:general-key-families}

До этого момента мы рассматривали ключ агрегации простой группы подписантов. Например, Элис, Боб и Кэрол выдают компоненты ключа для multisig-адреса, создаваемого по схеме «2 из 3». 

Теперь представьте, что Элис хочет подписать все транзакции с этого адреса, но не хочет, чтобы Боб и Кэрол подписывались без её участия. Другими словами, вариант (Элис + Боб) или (Элис + Кэрол) приемлем, но не вариант (Боб + Кэрол). 

Мы можем реализовать этот сценарий, используя два уровня агрегирования ключей. На первом уровне происходит агрегирование по схеме multisig «1 из 2» $\mathbb{K}^{agg,{1\textrm{x}2}}_{BC}$ между Бобом и Кэрол, а затем по схеме «2 из 2» строится групповой ключ $K^{grp,{2\textrm{x}2}}$ между Элис и $\mathbb{K}^{agg,{1\textrm{x}2}}_{BC}$. Как правило, это multisig-адрес, построенный по схеме «(2 из ([1 из 1] и [1 из 2]))».

Это означает, что структуры предоставления доступа к праву подписи могут быть довольно открытыми.

\subsection{Деревья семейств}

Мы можем представить диаграмму multisig-адреса, построенного по схеме «(2 из ([1 из 1] и [1 из 2]))», следующим образом:
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {edge = {<-, > = triangle 60}
                    ,fork sep = 4.5 mm,
                    ,l sep = 8 mm
                    ,circle, draw
                    },
        where n children=0{tier=terminus}{},
        [$K^{grp,{2\textrm{x}2}}$
            [$K^{base}_A$]
            [$\mathbb{K}^{agg,{1\textrm{x}2}}_{BC}$
                [$K^{base}_B$]
                [$K^{base}_C$]
            ]
        ]
    \end{forest}    
\end{center}

Ключи $K^{base}_A,K^{base}_B,K^{base}_C$ считаются {\em родительскими (корнями)}, а $\mathbb{K}^{agg,{1\textrm{x}2}}_{BC}$ {\em дочерними ветвя\-ми} {\em parents} $K^{base}_B$ и $K^{base}_C$. У родителей может быть более одной дочерней ветви, хотя для ясности мы рассматриваем каждую копию родителя как отдельную. Это означает, что может быть несколько корней с одним и тем же ключом.

Например, в этих схемах «2 из 3» и «1 из 2», объединённых в «2 из 2», ключ Кэрол $K^{base}_C$ используется дважды и отображается дважды:
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {edge = {<-, > = triangle 60}
                    ,fork sep = 4.5 mm,
                    ,l sep = 8 mm
                    ,circle, draw
                    },
        where n children=0{tier=terminus}{},
        [$K^{grp,{2\textrm{x}2}}$
            [$\mathbb{K}^{agg,{2\textrm{x}3}}_{ABC}$
                [$K^{base}_A$]
                [$K^{base}_B$]
                [$K^{base}_C$]
            ]
            [$\mathbb{K}^{agg,{1\textrm{x}2}}_{CD}$
                [$K^{base}_C$]
                [$K^{base}_D$]
            ]
        ]
    \end{forest}    
\end{center}

Для каждого подобъединения с мультиподписью определены отдельные наборы $\mathbb{S}$. В преды\-дущем примере есть три предварительно объединённых набора:\linebreak $\mathbb{S}^{\textrm{2x3}}_{ABC} = \{K^{sh,\textrm{2x3}}_{AB},K^{sh,\textrm{2x3}}_{BC},K^{sh,\textrm{2x3}}_{AC}\}$, $\mathbb{S}^{\textrm{1x2}}_{CD} = \{K^{sh,\textrm{1x2}}_{CD}\}$, and $\mathbb{S}^{\textrm{2x3}}_{final} = \{\mathbb{K}^{agg,{2\textrm{x}3}}_{ABC},\mathbb{K}^{agg,{1\textrm{x}2}}_{CD}\}$.


\subsection{Вложение multisig-ключей}
\label{subsec:nesting-multisig-keys}

Предположим, у нас есть следующее семейство ключей
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {edge = {<-, > = triangle 60}
                    ,fork sep = 4.5 mm,
                    ,l sep = 8 mm
                    ,circle, draw
                    },
        where n children=0{tier=terminus}{},
        [$K^{grp,{2\textrm{x}3}}$
            [$K^{grp,{2\textrm{x}3}}_{ABC}$
                [$K^{base}_A$]
                [$K^{base}_B$]
                [$K^{base}_C$]
            ]
            [$K^{base}_D$]
            [$K^{base}_E$]
        ]
    \end{forest}    
\end{center}

Если мы объединим ключи в $\mathbb{S}^{\textrm{2x3}}_{ABC}$, соответствующие первой схеме «2 из 3», мы столкнёмся с проблемой на следующем уровне. Давайте возьмем только один общий секрет между $K^{grp,\textrm{2x3}}_{ABC}$ и $K^{base}_D$, чтобы проиллюстрировать это:\vspace{.175cm}
\[k_{ABC,D} = \mathcal{H}_n(k^{grp,\textrm{2x3}}_{ABC} K^{base}_D)\]

Теперь два участника из набора ABC легко могут внести компоненты ключей агрегирования, чтобы подобъединение могло вычислить
\[k^{grp,\textrm{2x3}}_{ABC} K^{base}_D = \sum k^{agg,\textrm{2x3}}_{ABC} K^{base}_D\]

Проблема состоит в том, что каждый участник из набора ABC может вычислить $k^{sh,\textrm{2x3}}_{ABC,D} = \mathcal{H}_n(k^{grp,\textrm{2x3}}_{ABC} K^{base}_D)$! Если каждому из участников нижнего уровня будут известны все приват\-ные ключи для создания мультиподписи более высокого уровня, то схемой multisig нижнего уровня также может быть «1 из N».

Эта проблема решается путём неполного объединения ключей до последнего дочернего ключа. Вместо этого мы просто применяем операцию {\tt premerge} ко всем ключам, выводимым из нижнего уровня.

\subsubsection*{Решение для вложения}

Чтобы использовать $\mathbb{K}^{agg,\textrm{MxN}}$ в новой мультиподписи, мы передаем его так же, как и обычный ключ, но с одним изменением. Для операций, связанных с $\mathbb{K}^{agg,\textrm{MxN}}$, используется каждый из ключей-участников вместо объединённого ключа группы. Например, публичный «ключ» общего секрета между $\mathbb{K}^{agg,\textrm{2x3}}_x$ and $K^{base}_A$\vspace{.175cm}
\[\mathbb{K}^{sh,\textrm{1x2}}_{x,A} = \{ [\mathcal{H}_n(k^{base}_A \mathbb{K}^{agg,\textrm{2x3}}_x[1])*G], [\mathcal{H}_n(k^{base}_A \mathbb{K}^{agg,\textrm{2x3}}_x[2])*G], ...\}\]

Таким образом, все участники $\mathbb{K}^{agg,\textrm{2x3}}_x$ знают только общие секреты, соответствующие их приватным ключам мультиподписи, построенной по схеме «2 из 3» нижнего уровня. Операция между набором ключей размером в два ${}^{2}\mathbb{K}_A$ и набором ключей размером в три ${}^{3}\mathbb{K}_B$ даёт набор ключей размером шесть ${}^{6}\mathbb{K}_{AB}$. Мы можем обобщить все ключи в семействе ключей как наборы ключей, где отдельные ключи обозначаются как ${}^{1}\mathbb{K}$. Элементы набора ключей упорядочиваются в соответствии с некоторым соглашением (то есть от наименьшего к наи\-большему численно), а наборы, содержащие наборы ключей (например, наборы $\mathbb{S}$) упорядо\-чиваются по первому элементу в каждом наборе ключей в соответствии с некоторым соглаше\-нием.\\

Мы допускаем распространение наборов ключей по структуре семейства, при этом каждая вложенная multisig-группа отправляет свой агрегированный набор до {\tt слияния (merge)} в качестве «базового ключа» для следующего уровня,\footnote{Следует отметить, что предварительное {\tt слияние (merge)} необходимо выполнить для выходов {\em всех} вложенных мультиподписей, даже если мультиподписи, подстроенные по схеме «N' из N'», вложены в схему «N из N», потому что набор $\mathbb{S}$ изменится.} пока не появится последний дочерний агрегированный набор, после чего наконец используется функция {\tt слияния (merge)}.\\

Пользователи должны хранить свои базовые приватные ключи, агрегированные приватные ключи для всех уровней структуры multisig-семейства и публичные ключи для всех уровней. Это облегчает создание новых структур, {\tt merging (объединение)} вложенных мультиподписей и взаимодействие с другими подписантами для восстановления структуры в случае возник\-новения какой-либо проблемы.


\subsection{Значение для Monero}

Каждое подобъединение, вносящее свой вклад в создание окончательного ключа, должно вносить компоненты в транзакции Monero (например, начальные значения $\alpha G$) и поэтому каждое под-подобъединение также должно вносить свой вклад в своё дочернее подобъедине\-ние.

Это означает, что каждый родитель, даже если в структуре семейства имеется несколько копий одного и того же ключа, должен вносить один корневой компонент в свой дочерний элемент, а каждый дочерний элемент — один компонент уже в свой дочерний элемент, и так далее. Мы используем простые суммы на каждом уровне.

Например, возьмём это семейство
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {edge = {<-, > = triangle 60}
                    ,fork sep = 4.5 mm,
                    ,l sep = 8 mm
                    ,circle, draw
                    },
        where n children=0{tier=terminus}{},
        [${}^{1}\mathbb{K}^{grp,{2\textrm{x}2}}$
            [${}^{1}\mathbb{K}^{base}_A$]
            [${}^{2}\mathbb{K}^{agg,{2\textrm{x}2}}_{AB}$
                [${}^{1}\mathbb{K}^{base}_A$]
                [${}^{1}\mathbb{K}^{base}_B$]
            ]
        ]
    \end{forest}    
\end{center}

Скажем, им нужно вычислить некоторое групповое значение $x$ для подписи. Родители вносят свой вклад: $x_{A,1}$, $x_{A,2}$, $x_B$. Сумма будет следующей: $x = x_{A,1} + x_{A,2} + x_B$.

Схема вложенной подписи в настоящее время не реализована в Monero.