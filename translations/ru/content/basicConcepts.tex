\chapter{Базовые концепции}
\label{chapter:basicConcepts}



%----------NOTATION
\section{Несколько слов о системе обозначений}

Одна из центральных задач настоящего отчёта состояла в сборе, рассмотрении, корректировке и упорядочивании всей существующей информации, касающейся внутренних принципов рабо\-ты криптовалюты Monero. И в то же самое время мы попытались указать все подробности, необходимые для конструктивного и последовательного представления материала.

Для выполнения этой задачи было необходимо установить ряд соответствующих обозначений. Среди прочего нами были использованы:

\begin{itemize}
\item символы нижнего регистра для обозначения простых значений, целых чисел, последова\-тельностей, двоичных представлений и так далее;
\item символы верхнего регистра для обозначения точек кривых и сложных структур.
\end{itemize}

В случае с символами с особым значением мы старались использовать одни и те же обозначе\-ния во всём документе. Например, генератор кривых всегда обозначался нами как \(G\), его порядок как \(l\), приватные/публичные ключи по возможности обозначались как \(k/K\), соответ\-ственно, и т.д.
\\

Помимо этого, мы старались придать {\em концептуальности} нашему представлению алгоритмов и схем. Читатель, обладающий знаниями в области компьютерной науки, может почувство\-вать, что нами были опущены некоторые вопросы, например, связанные с двоичным представ\-лением элементов или же в некоторых случаях касающиеся способов реализации проведения конкретных операций. Более того, студенты-математики могут обратить внимание на то, что мы пренебрегли объяснениями, связанными с абстрактной алгеброй.

Тем не мене мы не считаем это упущением. Простые объекты, такие как целое число или последовательность, всегда могут быть представлены строкой бит. Такая вещь, как порядок байтов (endianness), встречается довольно редко и в большинстве случаев обозначается так, как это делается в наших алгоритмах.\footnote{В компьютерной памяти каждый байт сохраняется по собственному адресу (адрес сродни пронумерованному слоту, в котором может быть сохранён байт). Определённое «слово» или переменную можно найти по самому младшему адресу, имеющемуся в их байтах. Если переменная $x$ занимает 4 байта, сохранённые по адресам 10-13, то для нахождения $x$ используется адрес 10. То, как организованы байты $x$ в наборе адресов, зависит от {\em порядка байтов (endianness)}, даже несмотря на то, что каждый отдельно взятый байт всегда и везде сохраняется одинаково по своему адресу. Но с какого конца $x$ сохраняется по указанному адресу? $x$ может сохраняться {\em в прямом порядке}, с начала, или {\em в обратном порядке}, то есть с конца. Допустим $x = $ 0x12345678 (шестнадцатеричное представление, где 2 шестнадцатеричные цифры занимают 1 байт, например, 8 двоичных цифр, также известных, как биты), а массивом адресов является \{10, 11, 12, 13\}. При прямом порядке $x$ будет находиться по адресам \{12, 34, 56, 78\}, а при обратном порядке - \{78, 56, 34, 12\}. \cite{endianness}}

Точки эллиптической кривой обычно обозначаются как пара \((x, y)\) и, следовательно, могут быть представлены двумя целыми числами. Тем не мене в мире криптографии практикуются методы {\em сжатия точек (point compression)}, позволяющие представить точку, используя про\-странство только по одной координате. В случае с нашим концептуальным подходом исполь\-зование или неиспользование методов сжатия точек часто имеет второстепенное значение. Тем не менее по большей части нами косвенно подразумевается их использование.\\

Нами\marginnote{src/crypto/ {\tt keccak.c}} также были свободно использованы хеш-функции безотносительно каких-либо конкрет\-ных алгоритмов. В случае с Monero это обычно вариант \(\mathit{Keccak}\)\footnote{\label{kekkak_note}Алгоритм хеширования Keccak лежит в основе стандарта Национального института стандартов и технологий США (NIST) {\em SHA-3} \cite{nist-sha3}.}, однако если такая информа\-ция не указывается, значит, это не так важно с точки зрения теории.

Криптографическая хеш-функция (в дальнейшем именуемая просто «хеш-функцией» или «хешем») берёт некоторое сообщение $\mathfrak{m}$ произвольной длины и возвращает хеш $h$ (или «про\-филь сообщения») фиксированной длины, где каждый возможный выход равновероятно будет соответствовать определённому входу. Криптографические хеш-функции трудно обратить, так как они обладают интересным свойством, известным как {\em большой лавинный эффект (large avalanche effect)}, в силу которого очень схожие сообщения могут производить совершенно непохожие хеши, и поэтому довольно сложно найти два сообщения с одинаковым профилем.

Хеш-функции применимы к целым числам, последовательностям, точкам кривой или различ\-ным комбинациям этих объектов. Такие случаи следует рассматривать как хеши двоичных представлений или как совокупность таких представлений. В зависимости от контекста результат хеширования будет численным, будет представлен строкой бит или даже точкой кривой. Более подробно этот вопрос будет рассмотрен далее по мере необходимости.



%----------MODULAR ARITHMETIC
\section{Модульная арифметика}
\label{sec:modular-arithmetic}

Современная криптография по большей части начинается с модульной арифметики, которая, в свою очередь, начинается с операции по модулю (обозначаемой как `mod'). Нас интересует только положительный модуль, который всегда возвращает положительное целое число.

Положительный модуль аналогичен «остатку» после деления двух чисел, например, $c$ являет\-ся «остатком» $a/b$. Представим числовую ось. Чтобы вычислить $c = a \pmod b$ нам необходи\-мо встать на точку $a$, а затем двигаться в направлении нуля, и каждый шаг должен быть равен $\text{step} = b$ , и так до тех пор, пока мы не достигнем целого числа $\geq{0}$ и $<b$. То есть $c$. Например, $4$ (modulo 3) $= 1$, $-5 \pmod 4 = 3$ и так далее.

Формально в данном случае модуль $c = a \pmod b$ определяется как $a=bx+c$, где $0\leq{c}<{b}$, а $x$ является целым числом со знаком, которое отбрасывается ($b$ является положительным целым числом не равным нулю).

Следует отметить, что если $a \leq n$, $-a \pmod n$ будет тем же, что и $n - a$.


\subsection{Сложение и умножение по модулю}
\label{subsec:modular-addition-multiplication}

В случае с компьютерной наукой важно избегать больших чисел при использовании модульной арифметики. Например, если у нас есть $29+87 \pmod{99}$ и мы не можем использовать переменные с тремя или большим количеством цифр (такие как $116 = 29+87$), то мы не можем вычислить $116 \pmod{99} = 17$ напрямую.

Чтобы выполнить действие $c = a+b \pmod n$, где оба значения $a$ и $b$ меньше модуля $n$, можно сделать следующее:
\begin{itemize}
	\item вычислить $x = n-a$. Если $x > b$, значит $c = a+b$, в противном случае $c = b - x$.
\end{itemize}

Сложение по модулю можно использовать для получения умножения по модулю \linebreak ($a*b \pmod n = c$) при помощи алгоритма под названием `double-and-add'. Рассмотрим пример. Допустим, мы хотим выполнить действие $7*8 \pmod 9 = 2$. Это то же самое, что и
\[7*8 = 8+8+8+8+8+8+8 \pmod 9\]

Теперь разобьём это на группы по две: 
\[(8+8) + (8+8) + (8+8) + 8\]

И ещё раз в группы по две:
\[[(8+8) + (8+8)] + (8+8) + 8\]

Общее количество операций сложения ($+$) точек сокращается с 6 до 4, поскольку найти сумму $(8+8)$ нам нужно лишь единожды.\footnote{Эффект применения алгоритма double-and-add становится очевидным при работе с большими числами. Например, при умножении $2^{15} * 2^{30}$ прямое сложение потребует примерно $2^{15}$ $+$ операций сложения, в то время как при использовании алгоритма количество операций сокращается всего до 15!}\\

Алгоритм реализуется путём преобразования первого числа («множителя» $a$) в двоичную форму (например, 7 $\rightarrow$ [0111]) с последующим проходом через двоичный массив и выполнени\-ем операций удваивания и сложения. 

Создадим массив $A = [0111]$ и пронумеруем его как 3,2,1,0.\footnote{Эта операция известна как нумерация `LSB 0', так как наименьший значащий бит имеет значение 0. Мы используем `LSB 0' во всех остальных случаях, рассмотренных в данной главе, для ясности, а не для точности обозначения.} A[0] = 1 является первым элементом A и наименьшим значащим битом. Изначально задаём полученную переменную как $r = 0$ и переменную сумму как $s = 8$ (в более общем смысле мы начинаем с $s = b$). Далее следуем алгоритму:
\begin{enumerate}
	\item Выполняем итерацию: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item Если A[i] == 1, значит, $r = r + s \pmod n$.
		\item Вычисляем $s = s + s \pmod n$.
	\end{enumerate}
	\item Используем полученное $r$: $c = r$.
\end{enumerate}

В нашем примере $7*8 \pmod 9$ появляется эта последовательность:
\begin{enumerate}
	\item $i = 0$
	\begin{enumerate}
		\item A[0] = 1, таким образом, $r = 0 + 8 \pmod 9$ = 8
		\item $s = 8 + 8 \pmod 9$ = 7
	\end{enumerate}
	\item $i = 1$
	\begin{enumerate}
		\item A[1] = 1, таким образом, $r = 8 + 7 \pmod 9$ = 6
		\item $s = 7 + 7 \pmod 9$ = 5
	\end{enumerate}
	\item $i = 2$
	\begin{enumerate}
		\item A[2] = 1, таким образом, $r = 6 + 5 \pmod 9$ = 2
		\item $s = 5 + 5 \pmod 9$ = 1
	\end{enumerate}
	\item $i = 3$
	\begin{enumerate}
		\item A[3] = 0, таким образом, $r$ остаётся тем же
		\item $s = 1 + 1 \pmod 9$ = 2
	\end{enumerate}
	\item Получаем $r = 2$
\end{enumerate}


\subsection{Возведение в степень по модулю}

Очевидно, $8^7 \pmod 9 = 8*8*8*8*8*8*8 \pmod 9$. Подобно тому как это делается в случае с алгоритмом double-and-add, мы можем произвести возведение в квадрат и умножение (square-and-double). Для $a^e \pmod{n}$:
\begin{enumerate}
	\item Определяем $e_{scalar} \rightarrow e_{binary}$; $A = [e_{binary}]$; $r = 1$; $m = a$
	\item Выполняем итерацию: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item Если A[i] == 1, значит, $r = r * m \pmod n$.
		\item Вычисляем $m = m * m \pmod n$.
	\end{enumerate}
	\item Используем полученное $r$ в качестве результата.
\end{enumerate}


\subsection{Мультипликативная инверсия по модулю}

Иногда нам требуется $1/a \pmod n$ или, другими словами, $a^{-1} \pmod n$. Инверсия чего-либо умноженного сколько-то раз на себя по определению равна 1 (единице). Возьмём $0.25 = 1/4$, а затем $0.25*4 = 1$.\\

В модельной арифметике, в случае $c = a^{-1} \pmod{n}$, $a c \equiv 1 \pmod{n}$ для $0 \leq c < n$ и для $a$ и $n$ будут взаимно-простыми числами.\footnote{В уравнении $a \equiv b \pmod{n}$, $a$ a является  {\em конгруентным} для $b \pmod{n}$, что просто означает, что \(a \pmod{n} = b \pmod{n}\).} «Взаимно простые» означает, что они не будут иметь никаких общих делителей, кроме 1 (фракция $a/n$ не может быть сокращена/упрощена).

Мы можем использовать алгоритм возведения в квадрат и умножения для вычисления муль\-типликативной инверсии по модулю, если $n$ является простым числом в соответствии с {\em малой теоремой Ферма}:\footnote{\label{inverse_rule_note}Мультипликативная инверсия по модулю подчиняется следующему правилу:\\
{\em Если $a c \equiv b \pmod{n}$, где $a$ и $n$ являются взаимно простыми числами, решение такой линейной конгруэнции задаётся выражением \(c = a^{-1} b \pmod{n}\).}\cite{wiki-modular-arithmetic}\\
Это означает, что мы можем выполнить $c = a^{-1} b \pmod n \rightarrow ca \equiv b \pmod n \rightarrow a \equiv c^{-1} b \pmod n$.}\vspace{.175cm}
\begin{align*} 
    a^{n-1} &\equiv 1 \pmod{n} \\
    a*a^{n-2} &\equiv 1 \pmod{n} \\
    c \equiv a^{n-2} &\equiv a^{-1} \pmod{n}
\end{align*}

В более общем смысле (и более кратко) так называемый «расширенный алгоритм Евклида» \cite{extended-euclidean} также позволяет найти инверсии по модулю.


\subsection{Уравнения с модулем}
\label{subsec:modular-equations}

Предположим, у нас есть уравнение $c = 3*4*5 \pmod 9$. Оно вычисляется напрямую. У нас имеется некоторая операция $\circ$ (например, $\circ = *$) между двумя выражениями $A$ и $B$:\vspace{.175cm}
\[(A \circ B)\pmod{n} = {[A\pmod {n}] \circ [B\pmod{n}]}\pmod{n}\]

В нашем примере мы задаём $A = 3*4$, $B = 5$ и $n = 9$:\vspace{.175cm}
\begin{align*}
(3*4 * 5) \pmod{9} &= {[3*4 \pmod {9}] * [5 \pmod{9}]} \pmod{9} \\
				   &= [3]*[5] \pmod 9 \\
				 c &= 6
\end{align*}

Теперь можно выполнить вычитание по модулю:\vspace{.175cm}
\begin{align*}
A - B \pmod n &\rightarrow A + (-B) \pmod n \\
			  &\rightarrow {[A \pmod {n}] + [-B \pmod{n}]} \pmod{n}
\end{align*}\\

Тот же самый принцип применим к выражениям, подобным $x = (a-b*c*d)^{-1} (e*f+g^{h}) \pmod n$.\footnote{Модуль больших чисел не может использовать уравнения с модулем. Получается $254 \pmod {13} \equiv 2*10*10 + 5*10 + 4 \equiv (((2)*10 + 5)*10 + 4) \pmod {13}$. Алгоритм вычисления $a \pmod n$, если $a > n$, будет следующим:
\begin{enumerate}
	\item Определяем $A \rightarrow [a_{decimal}]$; $r = 0$
	\item Для $i = A_{size} - 1,...,0$
	\begin{enumerate}
		\item $r = (r*10 + A[i]) \pmod n$
	\end{enumerate}
	\item Используем полученное $r$ в качестве результата.
\end{enumerate}}



%----------ELLIPTIC CURVE CRYPTOGRAPHY
\section{Криптография на эллиптических кривых}
\label{EllipticCurveCryptography}


\subsection{Что такое эллиптические кривые?}
\label{elliptic_curves_section}

\marginnote{{\tt fe}: элемент поля} Конечное поле \(\mathbb{F}_q\), где \(q\) является простым числом более 3, это поле, сформированное последо\-вательностью \(\{0, 1, 2, ..., q-1\}\). Арифметические действия \((+,  \cdot)\) и унарная операция $(-)$ являются вычисленным\( \pmod q\).

«Вычисленный\( \pmod q\)» означает\( \pmod q\), который производится для каждого вида ариф\-метического действия между двумя элементами поля или для отрицания отдельно взятого элемента поля. Например, при заданном простом поле \(\mathbb{F}_p\), где $p = 29$, $17+20=8$, так как $37 \pmod{29} = 8$. Точно так же $-13 = -13 \pmod{29} = 16$.\\

Обычно эллиптические кривые определяют как набор точек \((x, y)\), соответствующих урав\-нению {\em  Вейерштрасса} для заданной пары $(a,b)$ \cite{Hankerson:2003:GEC:940321}:\footnote{\label{notation1}Примечание: выражение $a \in \mathbb{F}$ означает, что $a$ является некоторым элементом в поле $\mathbb{F}$.}\vspace{.175cm}
\[y^2 = x^3 + a x + b \quad \textrm{где} \quad a, b, x, y \in \mathbb{F}_q\]

Криптовалюта Monero использует специальную кривую, принадлежащую к категории так называемых {\em скрученных кривых Эдвардса (Twisted Edwards curves)} \cite{Bernstein2008}, которые обычно пред\-ставлены следующим выражением (для заданной пары $(a,d)$):\vspace{.175cm}
\[a x^2 + y^2 = 1 + d x^2 y^2 \quad \textrm{где} \quad a, d, x, y \in \mathbb{F}_q \]


Из чего следует, что нам лучше использовать вторую форму. Её преимуществом, помимо использования уже упомянутого уравнения Вейерштрасса, является то, что её криптогра\-фические примитивы требуют меньшего количества арифметических действий, что делает работу криптографических алгоритмов быстрее. Подробная информация содержится в рабо\-те Бернштейна \cite{Bernstein2007}  {\em и др.}\\

Допустим, что \(P_1 = (x_1, y_1)\) и \(P_2 = (x_2, y_2)\) являются двумя точками, принадлежащими скрученной кривой Эдврадса (далее просто именуемой EC). Производим сложение по точкам, определяя $P_1 + P_2 = (x_1, y_1) + (x_2, y_2)$ как $P_3 = (x_3, y_3)$, где\footnote{Как правило, точки на эллиптической кривой преобразуются в проективные координаты\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge.h} до выполнения операций на кривой, таких как сложение точек, чтобы избежать выполнения инверсий поля с целью повышения эффективности.  \cite{ecc-projective}}\vspace{.175cm}
\begin{align*}
x_3 & =  \frac{x_1 y_2 + y_1 x_ 2}{1 + d x_1 x_2 y_1 y_2}  \pmod{q} \\
y_3 & =  \frac{y_1 y_2 - a x_1 x_2}{1 - d x_1 x_2 y_1 y_2} \pmod{q} 
\end{align*}

Эти формулы добавления также применяются для дублирования точек, то есть для случаев, когда необходимо получить \(P_1 = P_2\). Чтобы выделить точку, необходимо инвертировать её координаты по оси $y$ $(x,y) \rightarrow (-x,y)$ \cite{Bernstein2008} и добавить точку. При каждом появлении «отрицательного» элемента $-x$ поля $\mathbb{F}_q$ в этом отчёте фактически это будет $-x \pmod{q}$.
\\

Всякий раз при сложении точек кривой $P_3$ является точкой на «оригинальной» эллиптической кривой, или, другими словами, все $x_3,y_3 \in \mathbb{F}_q$ соответствуют условиям уравнения EC.

Каждая точка $P$ кривой EC может формировать подгруппу порядка (размера) $u$ из несколь\-ких других точек EC, используя свои кратные. Например, подгруппа некоторой точки $P$ может быть порядка 5 и включать в себя другие точки $(0, P, 2P, 3P, 4P)$, каждая из которых будет находиться на EC. В точке $5P$ появляется так называемая {\em бесконечно удалённая точка}, которая, вероятнее всего, будет находиться в нулевой точке EC с координатами $(0, 1)$.\footnote{В результате использования описанной операции добавления эллиптические кривые приобретают структуру {\em абелевой группы}, так как их бесконечно удалённые точки являются единичными элементами. Точное определение этого понятия можно прочитать по ссылке \url{https://brilliant.org/wiki/abelian-group/}.}

Это очень удобно: $5P + P = P$. Это указывает на {\em цикличность}\footnote{\label{cyclical_note}Цикличность подгруппы означает, что для подгруппы точки $P$ порядка $u$ и любого целого числаr $n$, $n P = [n \pmod{u}] P$. Можно представить, что мы находимся в какой-то точке земного шара, находящейся на некотором расстоянии от «нулевой» метки, и каждый шаг, который мы делаем, смещает нас на это расстояние. В какой-то момент мы вернёмся в начальную точку, даже несмотря на то, что до того момента, как мы точно попадём в исходную точку, нам придётся несколько раз обернуться вокруг земного шара. Количество шагов, необходимых для того, чтобы попасть в ту же самую точку, будет «порядком» «группы шагов», и все наши следы будут уникальными точками в этой группе. Рекомендуем использовать эту концепцию применительно к остальным идеям, изложенным в данной работе.} подгруппы. Все точки $P$ кривой EC формируют циклические подгруппы. Если точка $P$ формирует подгруппу, то все входящие в эту подгруппу точки (за исключением бесконечно удалённой точки) также формируют такую подгруппу. В нашем примере взяты кратные значения точки $2P$:\vspace{.175cm}
\[2P, 4P, 6P, 8P, 10P \rightarrow 2P, 4P, 1P, 3P, 0\]

Другой пример: подгруппа порядка 6 $(0, P, 2P, 3P, 4P, 5P)$. Кратными точки $2P$ будут:\vspace{.175cm}
\[2P, 4P, 6P, 8P, 10P, 12P \rightarrow 2P, 4P, 0, 2P, 4P, 0\]
В данном случае $2P$ имеет порядок 3. Так как 6 не является простым числом, не все входящие сюда точки смогу воссоздать оригинальную подгруппу.

Каждая кривая EC имеет порядок $N$, равный общему количеству точек кривой, включая бесконечно удалённую точку, а порядки всех подгрупп, сформированных точками, являются делителями $N$ (по {\em теореме Лагранжа}). Можно представить себе набор из всех точек EC $\{0,P_1,...,P_{N-1}\}$. Если $N$ не является простым числом, некоторые точки создадут подгруппы с порядками, равными делителям $N$.

Чтобы определить порядок $u$ подгруппы точки $P$, необходимо:
\begin{enumerate}
    \item Найти $N$ (например, используя {\em алгоритм Шуфа}).
    \item Найти все делители $N$.
    \item Для каждого делителя $n$ у $N$ найти $n P$.
    \item Самый малый делитель $n$, при котором $n P = 0$ будет порядком $u$ подгруппы.
\end{enumerate} 

У кривых EC\marginnote{{\tt ge}: групповой элемент}, выбранных для криптографии, обычно $N = hl$, где $l$ является достаточно большим простым числом (как 160 бит), а $h$ является так называемым {\em кофактором}, который будет иметь малое значение, равное 1 или 2.\footnote{EC с небольшими кофакторами обеспечивает возможность относительно быстрого добавления точек и т. д. \cite{Bernstein2008}.} Одна точка из подгруппы с размером $l$ выбирается в качестве генератора и обозначается как $G$. Для каждой другой точки $P$ в подгруппе существует целое число $0 < n \leq l$, соответствующее $P = n G$.

Давайте рассмотрим это подробнее для понимания. Допустим, у нас есть точка $P'$ порядка $N$, где $N=h l$. Любая другая точка $P_i$ может быть найдена при помощи некоторого целого числа $n_i$ так, чтобы $P_i=n_i P'$. Если $P_1=n_1 P'$ имеет порядок $l$, то любая точка $P_2=n_2 P'$ порядка $l$ должна находиться в той же подгруппе, что и $P_1$, поскольку $l P_1=0 = l P_2$, и если $l(n_1 P') \equiv l(n_2 P') \equiv N P'=0$, то $n_1$ и $n_2$ будут кратными $h$. Так как $N= h l$, значит $l$ будет кратным  $h$, что подразумевает возможность существования только одной подгруппы с размером $l$.

Другими словами, подгруппа, сформированная кратными $(h P')$, всегда будет включать в себя точки $P_1$ и $P_2$. Более того, $h(n' P')=0$, если $n'$ будет кратным $l$, и будет только $h$ таких вариантов $n' \pmod N$ (включая бесконечно удалённую точку для $n' = hl$), поскольку, если $n' = h l$ происходит обратное возвращение по циклу к 0: $h l P' = 0$. Таким образом, если $h P$ равно 0, будет только $h$ точек $P$ на EC.

Подобный аргумент можно применить и к любой другой подгруппе размера $u$. Любые две точки $P_1$ и $P_2$ порядка $u$ находятся в одной и той же подгруппе, состоящей из кратных $(N/u) P'$.
\\ \newline
Учитывая это новое объяснение, очевидно, мы можем использовать следующий алгоритм для вычисления точек (не являющихся бесконечно удалёнными) в подгруппе порядка $l$:
\begin{enumerate}
    \item Найти $N$ эллиптической кривой EC, выбрать подгруппу порядка $l$, вычислить $h=N/l$.
    \item Выбрать произвольную точку $P'$ на кривой EC.
    \item Вычислить $P=h P'$.
    \item Если $P=0$, вернуться к шагу 2, или же $P$ формирует подгруппу порядка $l$.
\end{enumerate}

Вычисление скалярного\marginnote{{\tt sc}: скаляр} произведения любого целого числа $n$ и любой точки $P$, $nP$, не представляет сложности, в то время как нахождение такого $n$, чтобы $P_1 = n P_2$, является сложным с точки зрения вычисления. По аналогии с модульной арифметикой эту задачу часто называют {\em задачей дискретного логарифмирования (discrete logarithm problem, DLP)}. Другими словами, скалярное умножение может рассматриваться в качестве  {\em необратимой функции}, что позволяет использовать эллиптические кривые в криптографии.\footnote{Не существует известного алгоритма, позволяющего эффективно (при помощи доступной технологии) найти решения для $n$ при $P_1 = n P_2$, а это означает, что для разбора всего одного скалярного произведения уйдут многие годы.}

Скалярное произведение $nP$ эквивалентно $(((P+P)+(P+P))…)$. Несмотря на то, что этот подход не всегда является наиболее эффективным, мы можем воспользоваться алгоритмом double-and-add, как это было сделано в разделе \ref{subsec:modular-addition-multiplication}. Чтобы получить сумму $R = n P$, , следует помнить о том, что мы используем операцию сложения точек, о которой говорится в разделе \ref{elliptic_curves_section}.

\begin{enumerate}
	\item Определяем $n_{scalar} \rightarrow n_{binary}$; $A = [n_{binary}]$; $R = 0$, бесконечно удалённую точку; $S = P$
	\item Выполняем итерацию: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item Если A[i] == 1, значит, R += S.
		\item Вычисляем S += S.
	\end{enumerate}
	\item Используем полученное R в качестве результата.
\end{enumerate}

Следует отметить, что скалярные величины EC точек в подгруппе размера $l$ (которая будет использоваться в дальнейшем) являются элементами конечного поля $\mathbb{F}_l$. Это означает, что арифметика между скалярами равна mod $l$.


\subsection{Использование криптографии на эллиптических кривых для созда\-ния публичных ключей}
\label{ec:keys}
Криптографические алгоритмы создания публичных ключей могут создаваться путём, анало\-гичным модульной арифметике.

Допустим, \(k\) является произвольно выбранным числом, соответствующим условию \(0 < k < l\), и мы назовём его {\em приватным ключом}.\footnote{Иногда приватный ключ называют  {\em секретным ключом}. Поэтому мы используем сокращения: pk = публичный ключ (public key), sk = секретный ключ (secret key).} Необходимо вычислить соответствующий {\em публичный ключ} \(K\) (точку на кривой EC), используя скалярное произведение \(k G = K\). 

Из-за {\em задачи дискретного логарифмирования} (DLP) мы не можем просто вывести \(k\) только на основе \(K\). Это свойство позволяет нам использовать значения \((k, K)\) в стандартных криптографических алгоритмах создания публичного ключа.


\subsection{Протокол обмена ключами Диффи-Хеллмана на эллиптических кри\-вых}
\label{DH_exchange_section}

Базовый обмен секретными ключами {\em Диффи-Хеллмана} \cite{Diffie-Hellman} между {\em Элис} и {\em Бобом} мог бы происходить следующим образом:

\begin{enumerate}
	\item Элис и Боб генерируют собственные приватные/публичные ключи \((k_A, K_A) \textrm{ и } (k_B, K_B)\). Оба публикуют или обмениваются своими публичными ключами, а приватные ключи оставляют у себя.

	\item Очевидно, что \[S = k_A K_B = k_A k_B G = k_B k_A G = k_B K_A\]

	Элис может приватно вычислить \(S = k_A K_B\), а Боб может вычислить \(S = k_B K_A\). Это позволяет им использовать это единственное значение в качестве общего секрета.

	Например, если у Элис имеется сообщение $m$, которое она хочет отправить Бобу, она может хешировать общий секрет \(h = \mathcal{H}(S)\), вычислить $x = m + h$, и отправить  $x$ Бобу. Боб вычисляет $h' = \mathcal{H}(S)$, вычисляет $m = x - h'$ и узнаёт $m$.
\end{enumerate}   

Сторонний наблюдатель не сможет вычислить общий секрет благодаря задаче Диффи-Хел\-лмана DHP, согласно которой найти $S$ на основе $K_A$ и $K_B$ очень сложно. Также DLP не позволяет им найти $k_A$ или $k_B$.\footnote{Предполагается, что задача DHP должна иметь, по крайней мере, ту же сложность, что и DLP, хотя это и не было доказано. \cite{diffie-hellman-problem}}


\subsection{Подписи Шнорра и преобразование Фиата-Шамира}
\label{sec:schnorr-fiat-shamir}

В 1989 году Клаусом Питером Шнорром был опубликован теперь уже ставший известным протокол интерактивной аутентификации \cite{schnorr-signatures}, затем обобщённый Маурером в 2009 \cite{simple-zk-proof-maurer}, который позволял кому-либо доказывать знание приватного ключа $k$ для определённого публичного ключа $K$, не раскрывая никакой информации о нём \cite{Signatures2015BorromeanRS}. Выглядит это примерно так:

\begin{enumerate}
	\item Доказывающая сторона генерирует случайное целое число \(\alpha \in_R \mathbb{Z}_l\)\footnote{\label{notation3_note}Примечание: $R$ в \(\alpha \in_R \mathbb{Z}_l\) означает, что $\alpha$ случайным образом выбирается из \(\{1,2,3,...,l-1\}\).\marginnote{src/crypto/ crypto.cpp {\tt random32\_ unbiased()}} Другими словами, $\mathbb{Z}_l$ является всеми числами$\pmod l$. Мы исключаем `$l$' поскольку в данном случае бесконечно удалённая точка не требуется.}, вычисляет $\alpha G$ и отправляет $\alpha G$ верификатору.
	\item Верификатор генерирует случайный {\em запрос} $c \in_R \mathbb{Z}_l$ и отправляет $c$ проверяющей стороне.
	\item Доказывающая сторона вычисляет {\em ответ} $r = \alpha + c*k$ и отправляет $r$ верификатору.
	\item Верификатор вычисляет $R = r G$ и $R' = \alpha G + c*K$ и проверяет $R \stackrel{?}{=} R'$.
\end{enumerate}

Верификатор может вычислить $R' = \alpha G + c*K$ до доказывающей стороны, передав $c$ и как бы говоря: «Я запрашиваю ответа в форме дискретного логарифма $R'$». На такой запрос доказывающая сторона может ответить, только зная $k$ (за исключением ничтожной вероятности).

Если значение $\alpha$ было выбрано случайным образом, то $r$ распределяется случайным образом \cite{SCOZZAFAVA1993313}, а $k$ является теоретико-информационно безопасным в пределах $r$ (его по-прежнему можно найти, решив задачу DLP для $K$ или $\alpha G$).\footnote{\label{information_theoretic_note}Криптосистемой, обеспечивающей теоретико-информационную безопасность, является та система, которая не может быть взломана злоумышленником, обладающим даже безграничным вычислительным ресурсом, просто потому, что у него не будет достаточного количества информации.} Тем не менее, если доказывающая сторона повторно использует $\alpha$, чтобы доказать знание $k$, любой, кому известны оба запроса в $r = \alpha + c*k$ и $r' = \alpha + c'*k$, сможет вычислить $k$ (два уравнения, два неизвестных).\footnote{Если доказывающей стороной является компьютер, можете представить кого-то «клонирующего»/копирующего компьютер после того, как он сгенерирует $\alpha$, а затем передающего каждую копию с отдельным запросом.}\vspace{.175cm}%In security proofs, phrases like `forking lemma' and `rewind on success' are analagous to this cloning attack. See for example \cite{Liu2004}.
\[k = \frac{r-r'}{c-c'}\]

Если доказывающей стороне с самого начала было известно $c$ (например, если верификатор секретно передал его доказывающей стороне), гона должна сгенерировать случайный ответ $r$ и вычислить $\alpha G = r G - c K$. Когда она позже отправит $r$ верификатору, она докажет знание $k$, даже не зная его. Кто-то, просматривающий запись событий между доказывающей стороной и верификатором, также ничего не узнает. Схему нельзя {\em верифицировать публично}. \cite{Signatures2015BorromeanRS}\\

В роли запросчика верификатор после получения $\alpha G$ выдаёт случайное число, что делает его эквивалентным {\em случайной функции}. Случайные функции, такие как хеш-функция, называ\-ются случайными оракулами, поскольку их вычисление подобно запросу у кого-то случайного числа \cite{Signatures2015BorromeanRS}.\footnote{В более общем смысле «в криптографии… оракул является любой системой, которая может дать дополнительную информацию по системе, которая в противном случае не была бы известна».\cite{cryptographic-oracle}}\\

Использование хеш-функции вместо верификатора для формирования вызовов известно как {\em преобразование Фиата-Шамира} \cite{fiat-shamir-transform}, поскольку таким образом интерактивное доказательство превращается в неинтерактивное и публично верифицируемое \cite{Signatures2015BorromeanRS}.\footnote{Выход криптографической хеш-функции $\mathcal{H}$ единообразно распределяется среди ряда возможных выходов. Другими словами, для некоторого входа $A$, $\mathcal{H}(A) \in^D_R \mathbb{S}_H$, где $\mathbb{S}_H$ является рядом возможных выходов $\mathcal{H}$. Мы используем $\in^D_R$, чтобы указать на то, что функция является детерминированно случайной. $\mathcal{H}(A)$ каждый раз даёт тот же результат, но её выход эквивалентен случайному числу.
}\footnote{Следует отметить, что неинтерактивные доказательства (и подписи), подобные доказательствам Шнорра, либо используют фиксированный генератор $G$, либо включают генератор в хеш запроса. Такое включение известно как прибавление префикса ключа, о чём будет говориться чуть позже (разделы \ref{blsag_note} и \ref{sec:robust-key-aggregation}).}

\subsubsection*{Неинтерактивное доказательство}

\begin{enumerate}
	\item Генерирование случайного числа $\alpha \in_R \mathbb{Z}_l$ и вычисление $\alpha G$.
	\item Вычисление запроса при помощи криптографически защищённой хеш-функции, \(c = \mathcal{H}([\alpha G])\).
	\item Определение ответа $r = \alpha + c*k$.
	\item Публикация пары доказательства $(\alpha G, r)$.
\end{enumerate}

\subsubsection*{Верификация}

\begin{enumerate}
	\item Вычисление запроса: \(c' = \mathcal{H}([\alpha G])\).
	\item Вычисление $R = r G$ и $R' = \alpha G + c'*K$.
	\item Если $R = R'$, значит, доказывающей стороне известен $k$ (за исключением ничтожной вероятности).
\end{enumerate}

\subsubsection*{Почему это работает}

\begin{align*}
r G &= (\alpha + c*k) G \\
	&= (\alpha G) + (c*k G) \\
	&= \alpha G + c*K \\
  R &= R'
\end{align*}

Важной составляющей любой схемы доказательства/подписи являются ресурсы, необходимые для их верификации. Они включают в себя место, необходимое для сохранения доказательств, и время, необходимое для верификации. В случае с данной схемой мы сохраняем точку EC и одно целое число, и нам необходимо знать публичный ключ — другую точку EC. Поскольку вычисление хеш-функций происходит относительно быстро, следует помнить о том, что время верификации по большей части является функцией операций на эллиптической кривой\marginnote{src/ringct/ rctOps.cpp}.


\subsection{Подписание сообщений}
\label{sec:signing-messages}

Обычно криптографическая подпись строится на криптографическом хеше сообщения, а не на самом сообщении, что облегчает подписание сообщений разного размера. Тем не менее в этом отчёте нами будет свободно использоваться термин «сообщение» и символ $\mathfrak{m}$ для определения сообщения и/или его значения хеша, если не будет указано иное.

Подписание сообщений является основой интернет-безопасности и даёт получателю уверен\-ность в том, что его содержание является именно тем, что было определено отправителем. Одной из наиболее широко используемых подписей является ECDSA (см. \cite{ecdsa}, ANSI X9.62 и \cite{Hankerson:2003:GEC:940321}.

Схема подписи, о которой мы будем говорить в данном случае, является альтернативной формулировкой преобразованного доказательства Шнорра, о котором было сказано выше. Если рассматривать подписи под таким углом, будет понятнее то, что будет говориться о кольцевых подписях в следующей главе.

\subsubsection*{Подпись}

Предположим, у Элис есть пара, состоящая из приватного/публичного ключей \((k_A, K_A)\). Чтобы уникально подписать случайное сообщение $\mathfrak{m}$, она могла бы сделать следующее:

\begin{enumerate}
	\item Генерирование случайного числа $\alpha \in_R \mathbb{Z}_l$ и вычисление $\alpha G$.
	\item Вычисление запроса при помощи криптографически защищённой хеш-функции, \(c = \mathcal{H}(\mathfrak{m},[\alpha G])\).
	\item Определение такого $r$, чтобы $\alpha = r + c*k_A$. Другими словами, $r = \alpha - c*k_A$.
	\item Публикация подписи $(c, r)$.
\end{enumerate}

\subsubsection*{Верификация}

Любая третья сторона, которой известны параметры кривой EC (указывающие на то, какая эллиптическая кривая использовалась), подпись $(c, r)$ и метод подписания, $\mathfrak{m}$ и хеш-функция, а также $K_A$ , может верифицировать подпись:

\begin{enumerate}
	\item Вычисление запроса: \(c' = \mathcal{H}(\mathfrak{m},[r G + c*K_A])\).
	\item Если $c = c'$, подпись проходит верификацию.
\end{enumerate}

В случае с данной схемой подписи мы сохраняем две скалярные величины, и нам нужен один публичный ключ EC.

\subsubsection*{Почему это работает}

Причиной является тот факт, что
\begin{align*}
  	 r G &= (\alpha - c*k_A) G \\
  	  	 &= \alpha G - c*K_A \\
\alpha G &= r G + c*K_A \\
\mathcal{H}_n(\mathfrak{m},[\alpha G]) &= \mathcal{H}_n(\mathfrak{m},[r G + c*K_A]) \\
       c &= c'
\end{align*}

Следовательно, обладатель $k_A$ (Элис) создал $(c,r)$ на основе $\mathfrak{m}$: она подписала сообщение. Вероятность того, что кто-то ещё, злоумышленник, пытающийся создать подделку, не зная $k_A$, сможет сделать $(c,r)$, ничтожна, поэтому верификатор может быть уверен в том, что сообщение не было сфальсифицировано.



%----------CURVE ED25519
\section{Кривая Ed25519}
\label{Ed25519_section}

Для выполнения криптографических операций Monero использует определённую скрученную эллиптическую кривую Эдвардса, {\em Ed25519}, {\em бирациональный эквивалент}\footnote{\label{birational_note}Если не вдаваться в подробности, то бирациональным эквивалентом можно назвать изоморфизм, который можно выразить в рациональных терминах.} 
кривой Монтгоме\-ри {\em Curve25519}.

Как кривая Curve25519, так и кривая Ed25519 были описаны в работах Бернштейна {\em и др.} \cite{Bernstein2008, Bernstein2012, Bernstein2007}.\footnote{Доктором Бернштейном была также разработана схема шифрования, известная как ChaCha \cite{Bernstein_chacha,chacha-irtf}, которая использовалась первым вариантом реализации Monero для шифрования\marginnote{src/wallet/ ringdb.cpp} определённой чувствительной информации, связанной с «кошельками пользователей».}

Кривая\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge.h} определяется через простое поле \(\mathbb{F}_{2^{255} - 19}\) (то есть $q = 2^{255}-19$) при помощи следующе\-го уравнения:\vspace{.175cm}
\[-x^2 + y^2 = 1 - \frac{121665}{121666} x^2 y^2\]

Использование этой кривой решает ряд вопросов, поднятых криптографическим сообщес\-твом.\footnote{Даже если с кривой не связано никаких вопросов относительно её криптографической безопасности, существует вероятность того, что человеку/организации, создавшей её, будет известен некий секретный недостаток, который будет всплывать только в очень редких случаях. Такой человек может случайным образом генерировать множество кривых, чтобы найти ту, у которой будет скрытая уязвимость, а известные слабые места будут отсутствовать. Если параметры кривой потребуют разумных объяснений, будет ещё сложнее найти уязвимые кривые, которые будут приняты криптографическим сообществом. Кривая Ed25519 известна как «крайне стабильная» кривая, а это означает, что процесс её генерирования имеет полное объяснение. \cite{elliptic-curve-rigidity}} Прекрасно известно, что стандартные алгоритмы NIST\footnote{\label{NIST_note}Национальный институт стандартов и технологий США, \url{https://www.nist.gov/}} 
не лишены недостатков. Например, недавно стало очевидно, что алгоритм генерации случайных чисел PNRG (его версия, основанная на использовании эллиптических кривых) имеет определённый изъян и может содержать потенциальную лазейку \cite{hales2014nsa}. Если смотреть с более широкой перспективы, организации, занимающиеся стандартизацией, такие как NIST, способствуют развитию крип\-тографической монокультуры, создают условия для централизации. Великолепным примером может служить то, как Агентство национальной безопасности США (NSA) использовало своё влияние на NIST, чтобы ослабить международный криптографический стандарт \cite{NSA-NIST}.

Кривая Ed25519 не запатентована (в работе \cite{ECC-patents} обсуждается эта тема), и команда\marginnote{src/crypto/ crypto\_ops\_ builder/}, стоящая за её созданием, занималась разработкой и адаптацией базовых криптографических алгоритмов, ориентируясь на их эффективность \cite{Bernstein2007}.

Скрученные эллиптические кривые Эдвардса имеют порядок, который можно выразить как \(N=2^c l\), где \(l\) является простым числом, а \(c\) положительным целым числом. В случае с кривой Ed25519 порядок будет десятичным числом 76 ($l$ занимает 253 бита):\footnote{Это означает, что приватные ключи EC, в случае с Ed25519, занимают 253 бита.}\vspace{.175cm}
\[2^3 \cdot 7237005577332262213973186563042994240857116359379907606001950938285454250989\marginnote{src/ringct/ rctOps.h {\tt curve- Order()}}\]


\subsection{Двоичное представление}
\label{binary_note}
Элементы \(\mathbb{F}_{2^{255} - 19} \) являются 256-битными целыми числами, поэтому они могут быть представ\-лены 32 байтами. Так как на каждый элемент требуется только 255 бит, самым значимым битом всегда является нулевой.

Следовательно, любая точка кривой Ed25519 может быть выражена 64 байтами. Тем не менее методы {\em сжатия точек}, описанные ниже, позволяют снизить это количество вдвое, до 32 байтов.


\subsection{Сжатие точек}
\label{point_compression_section}

Кривая Ed25519 обладает свойством, которое заключается в том, что её точки можно легко сжать настолько, что представление одной точки займёт пространство всего одной координа\-ты. Мы не станем углубляться в математические подробности, необходимые для того, чтобы объяснить это, но мы можем кратко показать, как это работает \cite{eddsa-ed25519-irtf}. . Процесс сжатия точек кривой Ed25519 впервые был описан в работе \cite{Bernstein2012}, в то время как сама концепция впервые была изложена в работе \cite{Miller:point-compression-origin}.

Данная схема сжатия точек основана на преобразовании уравнения скрученной кривой Эд\-вардса (с допуском $a = -1$, что действительно для Monero): $x^2 = (y^2-1)/(d y^2+1)$,\footnote{В данном случае $d = - \frac{121665}{121666}$.} которое демонстрирует, что у $x$ для каждого $y$ может быть только два возможных значения ($+$ или $-$). Элементы поля $x$ и $y$ вычисляются$\pmod{q}$, поэтому фактические отрицательные значения отсутствуют. Тем не менее $\pmod{q}$ от $–x$ изменит значение между нечётными и чётными, так как $q$ является нечётным. Например, $3 \pmod{5} = 3$, $-3 \pmod{5} = 2$. Другими словами, элементам поля $x$ и $–x$ присваиваются различные чётные/нечётные значения.

Если нам известно, что $x$ имеет чётное значение, но при заданном значении $y$ преобразованное уравнение кривой даёт нечётное число, то мы знаем отрицание, при котором значение даст нам правильный $x$. Эта информация может содержаться в одном бите, а для $y$ есть запасной бит, что очень удобно.

Предположим, что нам нужно сжать точку \((x, y)\).

\begin{description}
	\item[Шифровка] Мы\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge\_to- bytes.c} присваиваем наиболее значимому биту $y$ нулевое значение, если $x$ имеет чётное значение, и 1 , если нечётное. Полученное значение $y’$ будет представлять точку кривой.
	
	\item[Дешифровка] \hfill
	    \begin{enumerate}
    	    \item Берём\marginnote{ge\_from- bytes.c}[2.05cm] сжатую точку $y’$, а затем копируем её наиболее значимый бит в контрольный бит чётности $b$, перед тем как присвоить ему нулевое значение. Теперь это снова будет оригинальный $y$.
    	    \item Допустим, \(u = y^2-1 \pmod q\), а \(v = d y^2  + 1 \pmod q\). Это означает $x^2 = u/v \pmod q$.
    	    \item Вычисляем\footnote{Так как $q = 2^{255}-19 \equiv 5 \pmod{8}$, $(q-5)/8$ и $(q-1)/4$ являются целыми числами.} \(z = u v^3 (u v^7)^{(q-5)/8} \pmod q\).
            \begin{enumerate}
                \item Если \(v z^2 = u \pmod q\), значит \(x' = z\).
                \item Если \(v z^2 = -u \pmod q\), вычисляем \(x' = z*2^{(q-1)/4} \pmod q\).
            \end{enumerate}
            \item Используя контрольный бит чётности \(b\) полученный при выполнении первого этапа, если $b \ne$ наименее значимому биту $x'$, получаем  \(x = -x' \pmod q\), в противном случае получаем \(x = x'\).
            \item Получаем несжатую точку $(x,y)$.
	    \end{enumerate}
\end{description}

Варианты реализации Ed25519 (как в случае с Monero) обычно используют генератор $G = (x,4/5)$ \cite{Bernstein2012}, где $x$ является «чётным», или $b = 0$, вариант, основанный на развёртывании точки \(y = 4/5 \pmod q\).


\subsection{Алгоритм подписи EdDSA}
\label{EdDSA_section}

Бернштейном и его командой был разработан ряд базовых алгоритмов, основанных на кривой Ed25519.\footnote{\label{group_ops_twisted_edwards_note}В работе\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/} \cite{Bernstein2007} описана группа эффективных операций со скрученной эллиптической кривой Эдвардса (то есть добавление точки, удвоение, смешанное добавление и т.д.). В работе \cite{curve25519} приводятся эффективные модульные арифметические операции.}
Для примера нами описана предельно оптимизированная и безопасная альтернати\-ва схеме подписи ECDSA, которая, со слов её авторов, позволяет создавать более 100 000 подписей в секунду, используя обычный потребительский процессор Intel Xeon \cite{Bernstein2012}. Алгоритм также описан в Internet RFC8032 \cite{rfc8032}. . Следует отметить, что эта схема имеет много общего со схемой подписи Шнорра.

Помимо прочего, вместо постоянной генерации случайных целых чисел в данном случае используется значение хеша, выведенное на основе приватного ключа подписанта и на основе самого сообщения. Это позволяет обойти все уязвимости, связанные с реализацией генерато\-ров случайных чисел. Также, другая цель алгоритма состоит в том, чтобы не допустить несанкционированного доступа к секретным или непрогнозируемым областям памяти, что позволяет не избежать так называемых {\em атак кэша по времени} \cite{Bernstein2012}.

В этой работе исключительно для наглядности нами кратко описаны этапы алгоритма. Пол\-ное описание и пример реализации на языке Python можно найти в работе \cite{rfc8032}. 

\subsubsection*{Подпись}

\begin{enumerate}
	\item Допустим, \(h_k\) является хешем \(\mathcal{H}(k)\) приватного ключа \(k\) подписанта. 
	Вычисляем \(\alpha\) как \(\alpha = \mathcal{H}(h_k, \mathfrak{m})\) хешированного приватного ключа и сообщения. В зависимости от варианта реализации, $\mathfrak{m}$ может являться фактическим сообщением или его хешем \cite{rfc8032}.
	
	\item Вычисляем \(\alpha G\) и запрос $ch = \mathcal{H}([\alpha G], K,  \mathfrak{m})$.

	\item Вычисляем ответ \(r = \alpha + ch \cdot k \).
	
	\item Подпись будет представлена парой \((\alpha G, r)\).
\end{enumerate}

\subsubsection*{Верификация}
Верификация производится следующим образом

\begin{enumerate}
	\item Вычисляем \(ch' = \mathcal{H}([\alpha G], K,  \mathfrak{m})\).
	
	\item Если равенство \(2^c r G \stackrel{?}{=} 2^c \alpha G + 2^c ch'*K \) соблюдается, значит, подпись является действи\-тельной.
\end{enumerate}

Член уравнения $2^c$ взят из общей формы Бернштейна алгоритма EdSDA \cite{Bernstein2012}. . Согласно этой работе, хотя этого и не требуется для адекватной верификации, удаление $2^c$ усиливает уравнения.

Публичный ключ $K$ может быть любой точкой на кривой EC, но мы хотим использовать только те точки, которые входят в подгруппу генератора $G$. Умножение на кофактор $2^c$ гарантирует, что все точки будут находиться в подгруппе. Как вариант, верификаторы могут проверять соответствие $l K \stackrel{?}{=} 0$, которое будет таковым только в том случае, если $K$ будет принадлежать подгруппе. Нам неизвестно, сколько уязвимостей позволяют нейтрализовать эти меры предосторожности, однако мы ещё увидим, насколько последний метод важен для Monero (раздел \ref{blsag_note}).

В случае с этой схемой подписи мы сохраняем одну точку на кривой EC и одну скалярную величину, и у нас получается один публичный ключ EC.

\subsubsection*{Почему это работает}
\begin{align*}
2^c r G &= 2^c (\alpha + \mathcal{H}([\alpha G], K,  \mathfrak{m}) \cdot k) \cdot G \\
		&= 2^c \alpha G + 2^c \mathcal{H}([\alpha G], K,  \mathfrak{m}) \cdot K 
\end{align*}

\subsubsection*{Двоичное представление}

По умолчанию подписи EdDSA для представления требуется \(64 + 32\) байта для точки EC $\alpha G$ и скалярной величины $r$. Тем не менее RFC8032 предполагает, что точка \(\alpha G\) является сжатой, что снижает требования к занимаемому пространству до \(32 + 32\) байт. Мы также включаем сюда публичный ключ $K$, в результате чего получаем всего \(32 + 32 + 32\) байт.



\section{Двоичный оператор XOR}
\label{sec:XOR_section}

Двоичный оператор XOR является полезным инструментом, о котором ещё зайдёт речь в разделах \ref{sec:integrated-addresses} и \ref{sec:pedersen_monero}. Он берёт два аргумента и возвращает истинный, если один из них, но не оба, является таковым \cite{wolfram-xor}. Таблица истинности выглядит следующим образом:

\begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
        A & B & A XOR B \\
    \hline\hline
        T & T & F \\
    \hline
        T & F & T \\
    \hline
        F & T & T \\
    \hline
        F & F & F \\
    \hline
    \end{tabular}
\end{center}

В контексте компьютерной науки операция XOR эквивалентна битовому сложению по модулю 2. Например, XOR для двух пар битов:
\begin{alignat*}{1}
    \text{XOR}(\{1,1\},\{1,0\}) &= \{1+1,1+0\} \pmod 2 \\
                                &= \{0,1\} 
\end{alignat*}

Каждая из них также производит $\{0,1\}$: $\text{XOR}(\{1,0\},\{1,1\})$, $\text{XOR}(\{0,0\},\{0,1\})$ и \linebreak $\text{XOR}(\{0,1\},\{0,0\})$. Для входов XOR с $b$ бит существует $2^{\text{b}} - 1$ других комбинаций входов, который дадут тот же выход. Это означает, что если $C = \text{XOR}(A,B)$ и вход $A \in_R \{0,...,2^{\text{b}-1}\}$, наблюдатель, которому стало известно значение $C$, не получит никакой информации о $B$.

В то же самое время любой, корму известны два элемента из трёх $\{A,B,C\}$, где $C = \text{XOR}(A,B)$, сможет вычислить третий элемент, например, $A = \text{XOR}(B,C)$. XOR показывает, являются ли два элемента одинаковыми или разными, поэтому знания $C$ и $B$ достаточно для выделения $A$. Подробное изучение таблицы истинности вскрывает эту крайне важную особенность.\footnote{Одним из интересных вариантов применения XOR (не связанным с Monero) является замена двух разрядных регистров без использования третьего регистра. Для обозначения операции XOR мы используем символ $\oplus$ to indicate an XOR operation. $A \oplus A = 0$, и после трёх операций XOR между двумя регистрами: $\{A, B\} \rightarrow{} \{[A \oplus B], B\} \rightarrow{} \{[A \oplus B], B \oplus [A \oplus B]\} = \{[A \oplus B], A \oplus 0\} = \{[A \oplus B], A\} \rightarrow{} \{[A \oplus B] \oplus A, A\} = \{B, A\}$.}