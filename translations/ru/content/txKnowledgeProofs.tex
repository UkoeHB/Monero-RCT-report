\chapter{Доказательства знания в транзакциях Monero}
\label{chapter:tx-knowledge-proofs}
%original draft by Sarang Noether, Ph.D.

\iffalse
https://github.com/monero-project/monero/pull/6329/files

https://monero.stackexchange.com/questions/8122/what-is-the-spendproofv1-or-outproofv1-in-the-details-of-a-sent-transa

https://monero.stackexchange.com/questions/9991/how-does-the-get-reserve-proof-command-work

https://github.com/monero-project/research-lab/issues/68
\fi

Monero — это валюта, и, как и в случае с любой другой валютой, процесс её использования сложен. Начиная со сферы корпоративного бухгалтерского учёта и заканчивая биржевой торговлей и судебными разбирательствами, найдутся самые разные заинтересованные сторо\-ны, которым может понадобиться подробная информация о совершённых транзакциях.

Как узнать наверняка, что деньги поступили от конкретного человека? Или доказать, что вы действительно отправили кому-то определённый выход или транзакцию, несмотря на утверждения об обратном? Отправителей и получателей в публичном реестре Monero распо\-знать невозможно. Как доказать, что у вас имеется определённая сумма денег, не раскрывая своих приватных ключей? Суммы в Monero полностью скрыты от внешних наблюдателей.

Нами рассматриваются несколько типов доказательств, используемых в транзакциях, некото\-рые из которых реализованы в Monero и используются встроенными инструментами кошель\-ков. Также нами предлагается концепция аудита полного баланса на счету физического лица или организации без утечки какой-либо информации относительно будущих возможных транзакций.



\section{Доказательства в транзакциях Monero}
\label{sec:proofs-monero-proofs}

Доказательства, используемые в транзакциях Monero, находятся в процессе обновления\cite{sarang-txproofs-updates-issue}. Все реализованные на данный момент доказательства имеют версию 1 и не поддерживают разделения доменов. Мы описываем только самые продвинутые доказательства, независимо того, реализованы ли они на данный момент, планируются для реализации при выходе после\-дующих версий \cite{sarang-txproofs-v2-update-pr} или же являются лишь гипотетическими доказательствами, которые уже могли быть, а могли и не быть реализованы (см. подпункты \ref{subsec:proofs-owned-output-spent-unspentproof} \cite{unspent-proof-issue-68} и \ref{subsec:proofs-address-subaddress-correspond-subaddressproof}).


\subsection{Многоосновные доказательства в транзакциях Monero}
\label{subsec:proofs-multi-base-monero}

Есть некоторые детали, которые необходимо знать, чтобы двигаться дальше. Большинство доказательств транзакций Monero используют многоосновные доказательства (вспомните под\-пункт \ref{sec:proofs-discrete-logarithm-multiple-bases}). Везде, где уместно, разделителем домена будет $T_{txprf2} = \mathcal{H}_n(``\textrm{TXPROOF\_V2}")$.\footnote{Подобно тому как было описано в подпункте \ref{sec:CLSAG}, хеш-функции должны быть разделены по доменам путём добавления к ним префикса в виде тега. Используемый в настоящее время вариант реализации доказательств транзакций не предполагает разделения по доменам, поэтому все теги, которые указываются в данной главе, {\em пока не реализованы}.} Подписываемым сообщением, как правило\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}}, будет $\mathfrak{m} = \mathcal{H}_n(\texttt{tx\_hash, \texttt{message}})$ (если не будет указано иное), где хеш {\tt tx\_hash} является идентификатором соответствующей транзакции (см. подпункт \ref{subsec:transaction-id}), и {\tt сообщение} будет опциональным. Доказывающие или третьи стороны смогут использовать его, чтобы гарантировать, что у доказывающей стороны на самом деле имеется доказательство и оно не было украдено.

Доказательства шифруются при помощи кодировки base-58, схемы кодирования двоичного текста, впервые использованной в Bitcoin \cite{base-58-encoding}. Верификация этих доказательств всегда подра\-зумевает сначала их расшифровку из кодировки base-58 обратно в двоичную. Следует отме\-тить, что верификаторам требуется доступ к блокчейну, чтобы они могли использовать ссыл\-ки на ID транзакций для получения информации, например, данных одноразовых адресов.\footnote{Идентификаторы транзакций обычно передаются отдельно от доказательств.}
\\

Структура добавления префиксов к ключам в доказательствах является неравномерной из-за того, что в некоторых обновлениях она не была использована. Запросы с 2-основными доказательствами «версии 2» транслируются в этом формате, где, если «базовый ключ 1» является $G$, то его место в запросе заполняется 32 нулевыми байтами,\vspace{.175cm}
\[c = \mathcal{H}_n(\mathfrak{m}\textrm{, public key 2, proof part 1, proof part 2, $T_{txprf2}$, public key 1, base key 2, base key 1})\]


\subsection{Доказательство создания входа транзакции ({\tt SpendProofV1})}
\label{subsec:proofs-input-creation-spendproof}

Предположим, нами была создана транзакция, и мы хотим доказать её. Очевидно, что если переделать подпись по входу транзакции для нового сообщения, у любого верификатора не останется выбора, кроме как прийти к выводу, что нами был создан оригинал. Переделка {\em всех} подписей по входам транзакции означает, что мы создали всю транзакцию (вспомните подпункт \ref{full-signature}), или же самое малое полностью «профинансировали» её.\footnote{Как станет понятно из Главы \ref{chapter:txtangle}, совсем не обязательно тот, кто создаёт одну подпись по входу, создаёт все подписи по входам.}

Так называемое SpendProof\marginnote{src/wallet/ wallet2.cpp {\tt get\_spend\_ proof()}} содержит переделанные подписи по всем входам транзакции. Что важно, в кольцевых подписях SpendProof повторно используются участники оригинального кольца, что позволяет не допустить идентификации истинного подписанта путём анализа «пересечения» колец.

Доказательства SpendProof реализованы в Monero, и, чтобы зашифровать такое доказатель\-ство для передачи верификаторам, доказывающей стороне необходимо присоединить строку префикса ``{\tt SpendProofV1}" к списку подписей. Следует отметить, что кодировка base-58 не применяется к строке префикса и её не требуется шифровать/кодировать, поскольку она должна быть читабельной для человека.%what about the message signed?

\subsubsection*{Доказательство SpendProof}

Доказательства SpendProof не используют подписей MLSAG. Они используют оригинальную схему \marginnote{src/crypto/ crypto.cpp {\tt generate\_ ring\_signa- ture()}} кольцевой подписи Monero, которая использовалась в рамках самого первого протокола транзакций (до введения RingCT) \cite{cryptoNoteWhitePaper}.

\begin{enumerate}
	\item Вычисляем образ ключа \(\tilde{K} = k^o_\pi \mathcal{H}_p(K^o_\pi)\).

	\item Генерируем случайное число \(\alpha \in_R \mathbb{Z}_l\) и случайные числа \(c_i, r_i \in_R \mathbb{Z}_l\) для \(i \in \{1, 2, ..., n\}\), за исключением \(i = \pi\).

	\item Вычисляем
	\[c_{tot} = \mathcal{H}_n(\mathfrak{m},[r_1 G + c_1 K^o_1],[r_1 \mathcal{H}_p(K^o_1) + c_1 \tilde{K}],...,[\alpha G],[\alpha \mathcal{H}_p(K^o_{\pi})],...,\textrm{etc.})\]

	\item Определяем реальный запрос
	\[c_{\pi} = c_{tot} - \sum^{n}_{i=1,i\neq \pi} c_i\]

	\item Определяем \(r_{\pi} = \alpha - c_{\pi}*k^o_{\pi} \pmod l\).
\end{enumerate}

Подпись будет следующей: $\sigma = (c_1, r_1,c_2,r_2,...,c_n,r_n)$.

\subsubsection*{Верификация}

Чтобы верифицировать\marginnote{src/wallet/ wallet2.cpp {\tt check\_spe- nd\_proof()}} доказательство SpemdProof конкретной транзакции, верификатору, воспользовавшись информацией из соответствующей эталонной транзакции (например, обра\-зами ключей и значениями смещения выходов для получения одноразовых адресов от других транзакций), необходимо подтвердить, что все кольцевые подписи являются действительными.

\begin{enumerate}
	\item Вычисляем
	\[c_{tot} = \mathcal{H}_n(\mathfrak{m},[r_1 G + c_1 K^o_1],[r_1 \mathcal{H}_p(K^o_1) + c_1 \tilde{K}],...,[r_n G + c_n K^o_n],[r_n \mathcal{H}_p(K^o_n) + c_n \tilde{K}])\]

	\item Проверяем равенство
	\[c_{tot} \stackrel{?}{=} \sum^{n}_{i=1} c_i\]
\end{enumerate}

\subsubsection*{Почему это работает}

Следует отметить, что это та же схема, что и в случае с bLSAG (см. подпункт \ref{blsag_note}), при которой присутствует только один участник кольца. Чтобы добавить ложного участника, а не решать превращать запрос $c_{\pi+1}$ в новый хеш запроса, участник добавляется в оригинальный хеш. Поскольку уравнение\vspace{.175cm}
\[c_{s} = c_{tot} - \sum^{n}_{i=1,i\neq s} c_i\]

заведомо остаётся действительными для любого  индекса $s$, верификатор никак не сможет идентифицировать реальный запрос. Более того, не зная $k^o_{\pi}$, доказывающая сторона никогда не смогла бы правильно определить $r_{\pi}$ (кроме как с ничтожной вероятностью).


\subsection{Создание доказательства по выходу транзакции ({\tt OutProofV2})}
\label{subsec:proofs-output-creator-outproof}

Теперь предположим, что мы отправляем какие-то деньги (выход) и хотим доказать это. Выходы транзакций включают в себя три компонента: адрес получателя, отправляемую сумму и приватный ключ транзакции. Суммы зашифрованы, поэтому, чтобы начать, нам, по сути, требуются только адрес и приватный ключ транзакции. Любой, кто удалит или потеряет свой приватный ключ транзакции не сможет создать доказательства OutProof, поэтому в данном контексте доказательства OutProof представляются наименее надёжными из всех доказательств транзакций Monero.\footnote{Доказательство OutProof можно рассматривать в качестве доказательства того, что выход поступает от доказывающей стороны. Соответствующие доказательства InProof (см. подпункт \ref{subsec:proofs-output-ownership-inproof}) показывают выходы, поступающие на адрес доказывающей стороны.}

В данном случае наша задача состоит в том, чтобы показать, что одноразовый адрес был создан на основе адреса получателя, и позволить верификаторам восстановить обязательство по выходу. Мы можем сделать это, доказав общий секрет отправителя и получателя $rK^v$, а затем доказав, что мы создали его и что он соответствует публичному ключу транзакции и адресу получателя, подписав 2-основную подпись (см. подпункт \ref{sec:proofs-discrete-logarithm-multiple-bases}) по базовым ключам $G$ и $K^v$. Верификаторы могут использовать общий секрет для проверки получателя\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}} (см. подпункт \ref{sec:one-time-addresses}), расшифровки суммы (см. подпункт \ref{sec:pedersen_monero}) и восстановления обязательства по выходу (см. подпункт \ref{sec:pedersen_monero}). Мы даём подробную информацию как по обычным адресам, так и по подадресам.

\subsubsection*{Доказательство OutProof}

Чтобы сгенерировать\marginnote{src/crypto/ crypto.cpp {\tt generate\_ tx\_proof()}} доказательство по выходу, направленному по адресу $(K^{v},K^{s})$ или подад\-ресам $(K^{v,i},K^{s,i})$, при наличии приватного ключа транзакции $r$, где общим секретом отправи\-теля и получателя является $rK^v$, вспомним, что публичным ключрм транзакции, сохранённым в данных транзакции, будет либо $rG$, либо $rK^{s,i}$,i, в зависимости от того, использует или нет получатель подадрес (см. подпункт \ref{sec:subaddresses}).

\begin{enumerate}
	\item Генерируем случайное число $\alpha \in_R \mathbb{Z}_l$ и вычисляем:
	\begin{enumerate}
	    \item {\em для обычного адреса}: $\alpha G$ and $\alpha K^v$
	    \item {\em для подадреса}: $\alpha K^{s,i}$ and $\alpha K^{v,i}$
	\end{enumerate}{}
	\item Вычисляем запрос
	\begin{enumerate}
	    \item {\em для обычного адреса}:\footnote{В данном случае значение 0 является 32-байтовой кодировкой нулевых байтов.}
	    \[c = \mathcal{H}_n(\mathfrak{m},[rK^v], [\alpha G], [\alpha K^v], [T_{txprf2}], [rG], [K^v], [0])\]
	    \item {\em для подадреса}:
	    \[c = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [\alpha K^{s,i}], [\alpha K^{v,i}], [T_{txprf2}], [rK^{s,i}], [K^{v,i}], [K^{s,i}])\]
	\end{enumerate}{}
	\item Определяем ответ\footnote{Из-за ограниченного количества доступных символов, к сожалению, нам пришлось использовать $r$ как для обозначения ответов, так и приватного ключа транзакции. По необходимости, в целях обозначения отличия, будет использоваться верхний индекс `resp', обозначающий `response' (ответ).} $r^{resp} = \alpha - c*r$.
	\item Подпись будет следующей $\sigma^{outproof} = (c, r^{resp})$.
\end{enumerate}{}

Доказывающая сторона\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} может сгенерировать целую группу доказательств OuProof и отпра\-вить все их верификатору. Он присоединит строку префикса ``{\tt OutProofV2}" к списку доказа\-тельств, где каждый пункт (зашифрованный с использованием кодировки base-58) будет включать в себя общий секрет отправителя и получателя $r K^v$ (или $r K^{v,i}$ в случае использова\-ния подадреса) и соответствующую подпись $\sigma^{outproof}$. Предполагается, что верификатору известен соответствующий адрес для каждого доказательства.

\subsubsection*{Верификация}

\begin{enumerate}
    \item Вычисляем запрос\marginnote{src/crypto/ crypto.cpp {\tt check\_tx\_ proof()}}
    \begin{enumerate}
        \item {\em для обычного адреса}:\vspace{.145cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^v], [r^{resp} G + c*r G], [r^{resp} K^v + c*r K^v], [T_{txprf2}], [rG], [K^v], [0])\]
	    \item {\em для подадреса}:\vspace{.16cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [r^{resp} K^{s,i} + c*r K^{s,i}], [r^{resp} K^{v,i} + c*r K^{v,i}], [T_{txprf2}], [rK^{s,i}], [K^{v,i}], [K^{s,i}])\]
    \end{enumerate}{}
    \item Если $c = c'$, значит, доказывающей стороне известен $r$, а $rK^v$ является действительным общим секретом между $r G$ и $K^v$ (за исключением ничтожной вероятности).
    \item Верификатор\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ key\_hel- per()}} должен проверить адрес получателя, который может использоваться для создания одноразового адреса соответствующей транзакции (вычисления будут одинако\-выми как для обычных адресов, так и для подадресов)
    \[K^s \stackrel{?}{=} K^o_t - \mathcal{H}_n(r K^v,t)\]
    \item Также необходимо расшифровать сумму в выходе $b_t$, вычислить маску выхода $y_t$ и попытаться восстановить соответствующее обязательство по выходу\footnote{Действительная подпись OutProof совсем не обязательно будет означать, что получатель является реальным получателем. Доказывающая сторона, действующая со злым умыслом, может сгенерировать случайный ключ просмотра $K'^v$, вычислить $K'^s = K^o - \mathcal{H}_n(rK'^v,t)*G$ и выдать $(K'^v,K'^s)$ в качестве условного получателя. За счёт повторного вычисления обязательства по выходу верификаторы могут быть более уверены в том, что рассматриваемый адрес получателя является легитимным. Тем не менее доказывающая сторона и получатель могут объединить усилия и зашифровать обязательство по выходу, воспользовавшись $K'^v$, в то время как одноразовый адрес будет использовать $(K^v,K^s)$. Поскольку получателю понадобится знание приватного ключа $k'^v$ (предполагается, что сумму в выходе по-прежнему можно будет потратить), это сомнительное свойство при таком уровне жульничества. А почему бы получателю просто не использовать $(K'^v,K'^s)$ (или некоторый другой одноразовый адрес) для всего выхода? Поскольку вычисление $C^b_t$ связано с получателем, мы считаем описанный процесс верификации OutProof адекватным. Другими словами, доказывающая сторона не сможет использовать его для введения верификаторов в заблуждение, не координируя свои действия с получателем.}\vspace{.175cm}
    \[C^b_t \stackrel{?}{=} y_t G + b_t H\]
\end{enumerate}{}


\subsection{Доказательство владения выходом ({\tt InProofV2})}
\label{subsec:proofs-output-ownership-inproof}

Доказательство OutProof демонстрирует, что доказывающая сторона отправила выход на адрес, в то время как доказательство InProof показывает, что выход был получен на какой-то определённый адрес. Как правило, это другая «сторона» в общем секрете отправителя и получателя $r K^v$. В этот раз доказывающая сторона доказывает знание $k^v$ в $K^v$, а это в сочетании с публичным ключом транзакции $r G$ даёт общий секрет $k^v*r G$.

Как только верификатор получит $r K^v$, он сможет, используя\marginnote{src/wallet/ wallet2.cpp {\tt check\_tx\_ proof()}} $K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s$, проверить, принадлежит ли одноразовый адрес адресу доказывающей стороны (см. подпункт \ref{sec:multi_out_transactions}). Создавая InProof для всех публичных ключей в блокчейне, доказывающая сторона раскроет все выходы, которыми обладает.

Прямая передача ключа просмотра верификатору имела бы те же последствия, но как только он получит такой ключ, он сможет идентифицировать принадлежность выходов, которые будут создаваться в будущем. При наличии доказательств InProof верификатор сохраняет контроль над своими приватными ключами, но за счёт времени, необходимого для доказатель\-ства (и последующей верификации) принадлежности или отсутствия принадлежности выхода.

\subsubsection*{Доказательство InProof}

InProof строится так же, как и OutProof\marginnote{src/crypto/ crypto.cpp {\tt generate\_ tx\_proof()}}, за тем лишь исключением, что базовыми ключами теперь будут $\mathcal{J} = \{G, r G\}$, публичными ключами $\mathcal{K} = \{K^v, r K^{v}\}$, а ключом подписания станет $k^v$ вместо $r$.Для ясности понимания мы покажем только этап верификации. Следует отметить, что порядок добавления префиксов к ключам изменяется ($r G$ и $K^v$ меняются местами) в целях обеспечения соответствия роли, исполняемой каждым из ключей.

Верификатору может быть отправлено сразу множество доказательств InProof, связанных с множеством выходов, имеющимся по одному и тому же адресу.\marginnote{src/wallet/ wallet2.cpp {\tt get\_tx\_ proof()}} Вначале добавляется строка префикса ``{\tt InProofV2}", и каждое доказательство (зашифрованное с использованием кодировки base-58) будет включать в себя общий секрет отправителя и получателя $r K^v$ (или $r K^{v,i}$) и соответствующую подпись $\sigma^{inproof}$.

\subsubsection*{Верификация}

\begin{enumerate}
    \item Вычисляем запрос:\marginnote{src/crypto/ crypto.cpp {\tt check\_tx\_ proof()}}
    \begin{enumerate}
        \item {\em для обычного адреса}:\vspace{.145cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^v], [r^{resp} G + c*K^v], [r^{resp}*r G + c*k^v*r G], [T_{txprf2}], [K^v], [rG], [0])\]
	    \item {\em для подадреса}:\vspace{.16cm}
	    \[c' = \mathcal{H}_n(\mathfrak{m},[rK^{v,i}], [r^{resp} K^{s,i} + c*K^{v,i}], [r^{resp}*r K^{s,i} + c*k^v*r K^{s,i}], [T_{txprf2}], [K^{v,i}], [r K^{s,i}], [K^{s,i}])\]
    \end{enumerate}{}
    \item Если $c = c'$, значит, доказывающей стороне известен $k^v$, а $k^v*r G$ является действитель\-ным общим секретом между $K^v$ и $r G$ (за исключением ничтожной вероятности).
\end{enumerate}{}

\subsubsection*{Доказательство «полноты» владения ключом к одноразовому адресу}

Несмотря на то, что доказательство InProof демонстрирует, что одноразовый адрес был построен по определённому адресу (за исключением ничтожной вероятности), это не обяза\-тельно означает, что доказывающая сторона может {\em потратить} выход. Только те, кто может потратить выход, действительно владеют таким выходом.

Доказательство владения при завершении InProof настолько же просто, как и подписание сообщения при помощи ключа траты.\footnote{Возможность предоставления такой подписи напрямую в Monero, кажется, невозможно, даже несмотря на то, что доказательства ReserveProof включают её (см. подпункт \ref{subsec:proofs-minimum-balance-reserveproof}).}


\subsection{Доказательство того, что имеющийся выход не был потрачен в какой-либо транзакции (UnspentProof)}
\label{subsec:proofs-owned-output-spent-unspentproof}

Доказательство того, что выход был потрачен или не потрачен, так же просто, как и создание его образа ключа с многоосновным доказательством по $\mathcal{J} = \{G,\mathcal{H}_p(K^o)\}$ и $\mathcal{K} = \{K^o,\tilde{K}\}$. Несмотря на то, что это, очевидно, работает, верификаторам необходимо знать образ ключа, который так же раскрывает, когда непотраченный выход будет потрачен {\em в будущем}.

Но мы можем доказать, что выход не был потрачен в определённой транзакции, не раскрывая образа ключа. Более того, мы {\em полностью} можем доказать, что до настоящего момента выход не был потрачен, расширив это доказательство \cite{unspent-proof-issue-68} до всех транзакций, в которые он был включён в качестве участника кольца.\footnote{Доказательства UnspentProof не были реализованы в Monero.}

В частности, наше доказательство UnspentProof указывает на то, что определённый образ ключа транзакции, находящейся в блокчейне, соответствует или не соответствует определён\-ному одноразовому адресу соответствующего кольца. В данном случае, как мы увидим, доказательства UnspentProof неразрывно связаны с доказательствами InProof.

\subsubsection*{Создание доказательства UnspentProof}

Верификатор UnspentProof должен знать $r K^v$, общий секрет отправителя и получателя для определённого имеющегося выхода с одноразовым адресом $K^o$ и публичным ключом транзак\-ции $r G$. Ему должен быть известен либо ключ просмотра $k^v$, позволяющий вычислить $k^v*r G$ и проверить $K^o - \mathcal{H}_n(k^v*rG,t)*G \stackrel{?}{=} K^s$, чтобы он знал, что проверяемый выход принадлежит доказывающей стороне (см. подпункт \ref{sec:one-time-addresses}), либо предоставленный доказывающей стороной общий секрет $r K^v$. Вот здесь и вступают в игру доказательства InProof, поскольку при наличии InProof верификатор может быть уверен в том, что $r K^v$ действительно принадлежит ключу просмотра доказывающей стороны и соответствует имеющемуся у неё выходу. При этом верификатору не требуется приватного ключа просмотра.

Перед проверкой UnspentProof верификатору необходимо узнать образ ключа, который будет проверяться $\tilde{K}_?$, и он также проверяет, содержит ли соответствующее кольцо одноразовый адрес $K^o$ выхода, имеющегося у доказывающей стороны. Затем верификатор вычисляет частичный образ «траты» $\tilde{K}^s_?$.\vspace{.175cm}
\[\tilde{K}^s_? = \tilde{K}_? - \mathcal{H}_n(r K^v,t)*\mathcal{H}_p(K^o)\]

Если проверяемый образ ключа был создан на основе $K^o$, то полученной точкой будет $\tilde{K}^s_? = k^s*\mathcal{H}_p(K^o)$.

\subsubsection*{Доказательство UnspentProof}

Доказывающая сторона создаёт два многоосновных доказательства (см. подпункт \ref{sec:proofs-discrete-logarithm-multiple-bases}). Её адресом, которому принадлежит рассматриваемый выход, будет $(K^v, K^s)$ или $(K^{v,i}, K^{s,i})$.\footnote{оказательства UnspentProof одинаково создаются как для обычных адресов, так и для подадресов. Для этого требуется полный ключ траты конкретного подадреса, например, $k^{s,i} = k^s + \mathcal{H}_n(k^v,i)$ (см. подпункт \ref{sec:subaddresses}).}

\begin{enumerate}
    \item 3-основное доказательство, где подписывающим ключом является $k^s$, а\vspace{.175cm}
    \begin{align*}
        \mathcal{J}^{unspent}_3 &= \{[G], [K^s], [\tilde{K}^s_?]\}\\
        \mathcal{K}^{unspent}_3 &= \{[K^s], [k^s*K^s], [k^s*\tilde{K}^s_?]\}
    \end{align*}{}
    \item 2-основное доказательство, где подписывающим ключом является $k^s*k^s$, а\vspace{.175cm}
    \begin{align*}
        \mathcal{J}^{unspent}_2 &= \{[G], [\mathcal{H}_p(K^o)]\}\\
        \mathcal{K}^{unspent}_2 &= \{[k^s*K^s], [k^s*k^s*\mathcal{H}_p(K^o)]\}
    \end{align*}{}
\end{enumerate}{}

Наряду с доказательствами $\sigma^{unspent}_3$ и $\sigma^{unspent}_2$ доказывающая сторона должна передать пуб\-личные ключи $k^s*K^s$, $k^s*\tilde{K}^s_?$ и $k^s*k^s*\mathcal{H}_p(K^o)$.

\subsubsection*{Верификация}

\begin{enumerate}
    \item Подтверждаем легитимность $\sigma^{unspent}_3$ и $\sigma^{unspent}_2$.
    \item Убеждаемся в том, что публичный ключ $k^s*K^s$ использовался в обоих доказательствах.
    \item Проверяем, одинаковы ли $k^s*\tilde{K}^s_?$ и $k^s*k^s*\mathcal{H}_p(K^o)$. Если да, то выход был потрачен, а если нет, то он не был потрачен (за исключением ничтожной вероятности).
\end{enumerate}{}

\subsubsection*{Почему это работает}

Этот кажущийся обходным подход не даёт верификатору узнать $k^s*H_p(K^o)$ непотраченного выхода, который он мог бы использовать в сочетании с $r K^v$ для вычисления реального образа ключа. При этом у него будет уверенность в том, что проверенный образ ключа не соответствует выходу.

Доказательство $\sigma^{unspent}_2$ может повторно использоваться для любого количества \linebreak доказательств UnspentProof, касающихся одного и того же выхода, и даже если он будет фактически потрачен, понадобится только одно (то есть, доказательства UnspentProofs также могут использоваться для того, чтобы продемонстрировать, что выход был потрачен). Ис\-пользование доказательств UnspentProofs во всех кольцевых подписях, в которых был отмечен определённый непотраченный выход, не должно быть затратным с точки зрения требуемых вычислений. Выход, вероятно со временем будет включён в качестве ложного участника в 11 (текущий размер кольца) различных колец.


\subsection{Доказательство наличия минимального количества непотраченных средств по адресу ({\tt ReserveProofV2})}
\label{subsec:proofs-minimum-balance-reserveproof}

Несмотря на снижение уровня анонимности при раскрытии образа ключа выхода, когда он ещё не потрачен, это всё же полезный метод, и он был реализован в Monero \cite{reserveproofs-pull-request-3027} до того, как были изобретены доказательства UnspentProof \cite{unspent-proof-issue-68}. Так называемое доказательство `ReserveProof'\marginnote{src/wallet/ wallet2.cpp {\tt get\_rese- rve\_proof()}} используется в Monero для доказательства того факта, что по адресу имеется минимальная сумма денег, путём создания образов ключей для некоторых непотраченных выходов.

Если говорить более конкретно, при наличии минимального баланса доказывающая сторона может найти достаточное количество выходов, чтобы покрыть его, и продемонстрирует такое наличии при помощи InProofs, создавая образы ключей для таких выходов, и доказывает, что в основе действительно лежат выходы, при помощи 2-основных доказательств (используя различный формат добавления префиксов к ключам). А затем она доказывает, что ей известны приватные ключи траты, используемые в обычных подписях Шнорра (ключей\linebreak может быть несколько, если выходы находятся по разным подадресам). Верификатор может прове\-рить, появлялись или нет образы ключей в блокчейне, и если нет, то соответствующие выходы должны быть непотраченными.

\subsubsection*{Доказательство ReserveProof}%get_reserve_proof() wallet2.cpp

Все «поддоказательства» в ReserveProof используются для подписания иных сообщений, не тех, которые подписываются другими доказательствами (например, OutProof, InProof или SpendProofs). В этот раз это $\mathfrak{m} = \mathcal{H}_n(\texttt{message}, \texttt{address}, \tilde{K}^o_1, ..., \tilde{K}^o_n)$, где {\tt address} является зашифрованной формой (см. работу \cite{luigi-address}) обычного адреса доказывающей стороны $(K^v, K^s)$, а образы ключей соответствуют непотраченным выходам, которые будут включены в доказа\-тельство.

\begin{enumerate}
    \item У каждого выхода есть доказательство InProof, которое демонстрирует, что данный выход находится по адресу доказывающей стороны (или по одному из её подадресов).
    \item Образ ключа каждого выхода подписывается 2-основным доказательством\marginnote{src/crypto/ crypto.cpp {\tt generate\_ ring\_signa- ture()}}, где запрос форматируется подобным образом:%generate_ring_signature()
    \[c = \mathcal{H}_n(\mathfrak{m}, [r G + c*K^o], [r \mathcal{H}_p(K^o) + c*\tilde{K}])\]
    \item Каждый адрес (и подадрес), по которому находится по крайней мере один выход, имеет обычную подпись Шнорра (см. подпункт \ref{sec:signing-messages}), и запрос (который будет одинаковым как для обычных адресов, так и для подадресов) выглядит так:\marginnote{src/crypto/ crypto.cpp {\tt generate\_ signature()}}
    \[c = \mathcal{H}_n(\mathfrak{m}, K^{s,i}, [r G + c*K^{s,i}])\]
\end{enumerate}{}

Чтобы отправить доказательство ReserveProof кому-то ещё\marginnote{src/wallet/ wallet2.cpp {\tt get\_rese- rve\_proof()}}[.3cm], доказывающей стороне необходи\-мо добавить строку префикса ``{\tt ReserveProofV2}" в два списка, зашифрованных с использова\-нием кодировки base-58 (например, ``{\tt ReserveProofV2}, list 1, list 2"). Каждое доказательство в списке 1 связано с определённым выходом и содержит хеш соответствующей транзакции (см. подпункт \ref{subsec:transaction-id}), индекс выхода для данной транзакции (см. подпункт \ref{sec:multi_out_transactions}), соответствующий общий секрет $r K^v$, его образ ключа, его $\sigma^{inproof}$ InProof и его доказательство образа ключа. В списке 2 содержатся адреса, по которым находятся эти выходы, наряду с их подписями Шнорра.

%in encoded data there are two lists of items, first list is per output [tx_hash, owned output's index, the shared secret r K^v, its key image, a \sigma^{inproof}, and a key image proof], second list is [subaddress, subaddress proof]
%key image proof uses generate_ring_signature() on message m (InProof also uses this message, different from otherwise), basically a 1-member ring sig
%subaddress proofs (basic schnorr signatures) includes a proof for main spend key if necessary! so ReserveProof not only reveals an unspent balance, but also means the prover fully owns them; however, this does not prove the subaddresses correspond with the original address

\subsubsection*{Верификация}

\begin{enumerate}
    \item Проверяем отсутствие образов ключей ReserveProof в блокчейне.\marginnote{src/wallet/ wallet2.cpp {\tt check\_rese- rve\_proof()}}
    \item Проверяем InProof для каждого выхода и что один из предоставленных адресов принад\-лежит каждому из них.
    \item Проверяем 2-основные подписи образов ключей.
    \item Используем общие секреты отправителя и получателя для расшифровки сумм в выходах (см. подпункт \ref{sec:pedersen_monero}).
    \item Проверяем подпись каждого адреса.
\end{enumerate}{}

Если всё будет верно, то у доказывающей стороны должна иметься непотраченная, по крайней мере, общая сумма, указанная в выходах ReserveProof (за исключением ничтожной вероятно\-сти).\footnote{Несмотря на то, что доказательства ReserveProof демонстрируют полную принадлежность средств, они не включают в себя доказательств того, что данные подадреса фактически соответствуют обычному адресу доказывающей стороны.}



\section{Концепция аудита Monero}
\label{sec:proofs-monero-audit-framework}

В США большинство компаний проходит ежегодный аудит своей финансовой отчётности \cite{investopedia-audits}, которая включает в себя отчёт о доходах, балансовый отчёт и баланс оборотных средств. Первые два документа, по сути, представляют собой большую часть внутренних записей компании, в то время как в последнем указывается каждая транзакция, влияющая на общее количество денег, имеющихся на данный момент у компании. Криптовалюты являются цифровыми деньгами, поэтому любой аудит баланса оборотных криптовалютных средств пользователя также будет связан с транзакциями, данные которых сохраняются в блокчейне.

Первая задача лица, проходящего аудит, состоит в указании всех выходов, которые у него имеются на данный момент (как потраченных, так и нет). Это можно сделать при помощи доказательств InProof, использующих все адреса. В случае с большим бизнесом подадресов может быть множество, особенно когда речь идёт о ритейлерах, работающих в формате торговых онлайн площадок (см. Главу \ref{chapter:escrowed-market}). Создание доказательств InProof для всех транзак\-ций и каждого отдельно взятого подадреса может привести к появлению чудовищных затрат, связанных с вычислениями и хранением данных как со стороны доказывающих сторон, так и верификаторов.

Вместо этого мы можем создавать доказательства InProof только для нормального адреса доказывающей стороны (для всех транзакций). Аудитор использует общие секреты отправи\-теля и получателя для проверки того, принадлежит ли какой-либо из выходов основному адресу доказывающей стороны или связанным с ним подадресам. Как было сказано в подпунк\-те \ref{sec:subaddresses}, для идентификации всех выходов, имеющихся по подадресам основного адреса, доста\-точно ключа просмотра пользователя.

Чтобы убедиться в том, что доказывающая сторона не вводит в заблуждение аудитора, скрывая обычный адрес для некоторых из её подадресов, она также должна доказать, что все подадреса соответствуют одному из её известных обычных адресов.


\subsection{Доказательство соответствия адреса и подадресов (SubaddressProof)}
\label{subsec:proofs-address-subaddress-correspond-subaddressproof}

Доказательства SubaddressProof демонстрируют, что ключ просмотра адреса может быть использован для идентификации выходов, имеющихся по определённому подадресу.\footnote{Доказательства SubaddressProof не были реализованы в Monero.}

\subsubsection*{Доказательство SubaddressProof}
%subaddress proof: base keys [G, K^{s,i}] public keys [K^v, K^{v,i}] signing key [k^v]
Доказательства SubaddressProof создаются во многом так же, как доказательства OutProofs и InProofs. В данном случае базовыми ключами являются $\mathcal{J} = \{G, K^{s,i}\}$, публичными ключами - $\mathcal{K} = \{K^v, K^{v,i}\}$, а подписывающим ключом - $k^v$. И вновь для ясности понимания мы покажем только этап верификации.

\subsubsection*{Верификация}

Верификатору известен адрес доказывающей стороны $(K^v, K^s)$, подадрес $(K^{v,i}, K^{s,i})$, \linebreak и $\sigma^{subproof} = (c,r)$ SubaddressProof.

\begin{enumerate}
    \item Вычисляем запрос\vspace{.175cm}
	\[c' = \mathcal{H}_n(\mathfrak{m},[K^{v,i}], [r G + c*K^v], [r K^{s,i} + c*K^{v,i}], [T_{txprf2}], [K^v], [K^{s,i}], [0])\]
    \item Если $c = c'$, значит, доказывающей стороне известен $k^v$ для $K^v$, а $K^{s,i}$ в сочетании с этим ключом просмотра даёт $K^{v,i}$ (за исключением ничтожной вероятности).
\end{enumerate}{}


\subsection{Концепция аудита}
\label{subsec:audit-framework}

Теперь мы готовы получить максимум информации о транзакциях пользователя.\footnote{Данная концепция аудита доступна в случае Monero не полностью. Доказательства SubaddressProof и UnspentProof не реализованы. Доказательства InProof не готовы к оптимизации, связанной с подадресами, что мы уже объясняли. Кроме того, структура, необходимая для лёгкого получения или организации информации, необходимой как доказывающим сторонам, так и верификаторам, отсутствует.}

\begin{enumerate}
    \item Доказывающая сторона собирает список всех своих счетов, и каждый счёт включает в себя обычный адрес и различные подадреса. Он создаёт доказательства SubaddressProof для всех подадресов. Во многом как и в случае с доказательствами ReserveProof, он также создаёт подпись, используя ключ траты каждого адреса и подадреса, демонстри\-руя тем самым, что у него есть права на трату всех выходов, находящихся по этим адресам.
    \item Для каждого своего обычного адреса доказывающая сторона генерирует доказательства InProof по всем транзакциям (например, всем публичным ключам транзакций), имею\-щимся в блокчейне. Это раскрывает аудитору все выходы, которые имеются по адресам доказывающей стороны, так как он может проверить все одноразовые адреса, воспользо\-вавшись общим секретом отправителя и получателя. Благодаря доказательствам SubaddressProof он может убедиться в том, что выходы, имеющиеся по подадресам, будут идентифицированы.\footnote{Этот шаг также может быть выполнен путём предоставления приватных ключей просмотра, но это скажется на общем уровне анонимности.}
    \item Для каждого имеющегося у неё выхода доказывающая сторона генерирует доказатель\-ства UnspentProof по всем входам транзакций, где они являются участниками колец. После этого аудитору будет известен баланс доказывающей стороны, и он сможет дальше проверять потраченные выходы.\footnote{Как вариант, можно создать доказательства ReserveProof для всех имеющихся выходов. И снова, раскрытие образов ключей непотраченных выходов имеет очевидные последствия с точки зрения анонимности.}
    \item {\em Как вариант}: для каждой транзакции, где был потрачен выход, доказывающая сторона генерирует доказательство OutProof, чтобы показать аудитору получателя и сумму. Этот шаг возможен только в том случае, если доказывающей стороной был сохранён приватный ключ (или ключи) транзакции.
\end{enumerate}{}

Важен тот факт, что у доказывающей стороны нет возможности напрямую продемонстриро\-вать происхождение средств. Единственным способом является запрос ряда доказательств от людей, отправивших ей деньги.

\begin{enumerate}
    \item В отношении транзакции, в которой доказывающей стороне были переданы средства, автор такой транзакции создаёт доказательство SpendProof, демонстрирующее, что\linebreak именно он отправил эти средства.
    \item Также тот, кто передал средства доказывающей стороне, используя идентифицирующий публичный ключ, создаёт подпись. Например, это может быть ключ траты обычного адреса того, кто отправил средства. При помощи доказательства SpendProof вместе с этой подписью вновь подписывается сообщение, содержащее этот идентифицирующий публичный ключ, и это гарантирует, что доказательство SpendProof не было украдено или, по сути, создано кем-то другим.
\end{enumerate}{}