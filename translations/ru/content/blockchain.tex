\chapter{Блокчейн Monero}
\label{chapter:blockchain}

Век интернета расширил границы человеческого опыта. Теперь мы можем общаться с челове\-ком, находящимся в любом уголке мира, и имеем просто невероятный объём информации буквально на кончиках наших пальцев. Обмен товарами и услугами является одной из фундаментальных основ создания мирного и процветающего общества \cite{human-action}, а в цифровом мире мы можем предложить свои возможности всему миру.

Среда обмена (деньги) очень важна и является для нас отправной точкой к великому разнооб\-разию экономических благ, которые в противном случае было бы невозможно оценить, а также она позволяет людям, не имеющим ничего общего, взаимодействовать на обоюдовыгод\-ной основе \cite{human-action}. В течение всей истории человек использовал самые разные виды денег: от морских ракушек до бумажных денег и золота. Тогда деньги передавали из рук в руки, а сейчас ими можно обмениваться при помощи электронных средств.

В наши дни самая распространённая модель электронных транзакций предполагает их обра\-ботку сторонними финансовыми организациями. Эти организации принимают деньги на ответственное хранение, и им доверяют перевод этих денег по запросу. Такие организации могут выступать в качестве посредника при разрешении споров, проводимые ими платежи обратимы, и они проверяются или контролируются более полномочными организациями. \cite{Nakamoto_bitcoin}

Чтобы нивелировать эти недостатки были разработаны децентрализованные цифровые валю\-ты.\footnote{Эта глава содержит более подробную информацию по реализации, чем предыдущие, так как природа блокчейна сильно зависит от специфики его структуры.}



\section{Цифровая валюта}
\label{sec:digital-currency}

Разработка цифровой валюты — дело нетривиальное. Существует три типа: личная, центра\-лизованная и распределённая. Следует помнить о том, что цифровая валюта — это просто набор сообщений, а «суммы», записанные в сообщениях, рассматриваются в качестве денеж\-ных единиц.

В случае с \textbf{«email-моделью»} любой может создать монеты (например, написав сообщение «У меня есть 5 монет») и любой может отправлять свои монеты снова и снова любому человеку, у которого есть email адрес. Эмиссия не ограничена, и ничто не мешает многократно тратить одни и те же монеты (двойная трата).

В случае с \textbf{«игровой моделью»}, когда вся криптовалюта хранится/регистрируется в одной центральной базе данных, пользователи надеются на честность хранителя. Наблюдатели не могут проверить новых монет, а хранитель может изменить правила в любой момент, или же его могут цензурировать сторонние лица, наделённые соответствующими полномочиями.


\subsection{Распределённая / совместно используемая версия событий}
\label{subsec:shared-version-events}

В случае с цифровыми «совместно используемыми» деньгами на множестве компьютеров хранится запись каждой валютной транзакции. Когда транзакция совершается на одном компьютере, она передаётся на другие компьютеры и принимается, если она соответствует предварительно определённым правилам.

Пользователи выгодно используют свои монеты только в том случае, если другие пользова\-тели принимают их в обмен на что-либо, и пользователи принимают только те монеты, которые считают легитимными. Чтобы повысить ценность своих монет, пользователи, что совершенно естественно, склонны следовать одному общепринятому набору правил при отсут\-ствии какого-либо централизованного контролирующего органа.\footnote{В политологии это называется точкой Шеллинга \cite{friedman-schelling}, социальным минимумом или смарт-контрактом.}
\begin{itemize}
    \item[] \textbf{Правило 1}: Деньги могут быть созданы только по чётко определённому сценарию.
    \item[] \textbf{Правило 2}: При проведении транзакций могут тратиться только те деньги, которые уже существуют.
    \item[] \textbf{Правило 3}: Пользователь может потратить денежную единицу лишь один раз.
    \item[] \textbf{Правило 4}: Только то лицо, у которого находится денежная единица, может потратить её.
    \item[] \textbf{Правило 5}: Количество денег в выходе транзакции должно быть равно тому количе\-ству денег, которое тратится.
    \item[] \textbf{Правило 6}: Транзакции должны иметь правильный формат.
\end{itemize}

Правила 2-6 уже охвачены схемой транзакций, описанной в Главе \ref{chapter:transactions} и обеспечивающей преиму\-щества, связанные с взаимозаменяемостью и приватностью, обеспечиваемыми неопределён\-ностью подписанта, а также с анонимностью получателя средств и невозможностью прочте\-ния передаваемой суммы. О Правиле 1 мы ещё поговорим ниже в этой главе.\footnote{В случае с товарными деньгами, такими как золото, эти правила соблюдаются в физической реальности.} При проведении транзакций используется криптография. Поэтому мы называем их содержимое {\em криптовалю\-той}.

Если два компьютера получают данные двух легитимных транзакций с тратой одних и тех же денег, то до того, как они пошлют информацию друг другу, как им решить, какая информация будет правильной? В случае с криптовалютами вводится понятие «форк», так как возможно наличие двух различных копий, следующих одним и тем же правилам.

Сначала кажется очевидным: более ранняя легитимная транзакция с тратой денежной едини\-цы и должна считаться канонической. Но это проще сказать, чем сделать. Как мы увидим далее, достижение консенсуса в историях транзакций составляет raison d'être (суть и смысл) блокчейн технологии.


\subsection{Простой блокчейн}
\label{subsec:simple-blockchain}

Для начала нам нужно, чтобы все компьютеры, которые в дальнейшем мы будем называть узлами, были согласованы относительно порядка проведения транзакций.

Допустим, валюта будет изначально создана заявлением о «генезисе» (т.е. создании): «Да будет SampleCoin!» Мы называем это сообщение «блоком», и хеш этого блока будет следую\-щим: \vspace{.175cm}
\[\mathit{BH}_G = \mathcal{H}(\textrm{«Да будет SampleCoin!»})\]

Всякий раз, когда узел принимает какие-либо транзакции, они будут использовать такие хеши транзакций, $\mathit{TH}$, в качестве сообщений, а также хеш предыдущего блока и вычислять хеши нового блока.\vspace{.175cm}
\[\mathit{BH}_1 = \mathcal{H}(\mathit{BH}_G, \mathit{TH}_1, \mathit{TH}_2,...)\]
\[\mathit{BH}_2 = \mathcal{H}(\mathit{BH}_1, \mathit{TH}_3, \mathit{TH}_4,...)\]

И так далее, публикуя каждый новый блок сообщений по мере их создания. Каждый новый блок ссылается на предыдущий, самый последний из опубликованных блоков. Таким образом, чёткий порядок событий распространяется на всю цепочку вплоть до «генезис-сообщения». То есть у нас получается очень простой «блокчейн».\footnote{Технически блокчейн является «направленным ациклическим графом» (DAG), при этом блокчейны типа Bitcoin являются его одномерным вариантом. Графы DAG содержат конечное количество узлов и однонаправленные рёбра (векторы), соединяющие узлы. Если вы начнёте с одного узла, то уже никогда не вернётесь обратно к нему, независимо от того, какое направление будет выбрано. \cite{DAG-wikipedia}}

Блоки узлов смогут содержать временные метки, которые делают их запись проще. Если большинство узлов имеет верные временные метки, то блокчейн обеспечивает последователь\-ную картину времени записи транзакций.

Если различные блоки, ссылающиеся на один и тот же предыдущий блок, будут опубликованы в одно и то же время, сеть узлов снова разветвится (произойдёт форк), так как каждый блок получит один из новых блоков перед другим (для простоты представьте себе, что у около половины узлов имеются по обеим сторонам форка).



\section{Сложность}
\label{sec:difficulty}

Если узлы могут публиковать новые блоки всякий раз, когда им вздумается, то сеть может разбиться и разойтись на множество различных в равной степени законных цепочек. Скажем, сейчас уходит 30 секунд на то, чтобы каждый участник сети гарантированно получил новый блок. Что было бы, если бы блоки отправлялись каждые 31, 15, 10 секунд и так далее?

Мы можем контролировать скорость создания новых блоков в сети. Если время, необходимое для создания нового блока, будет значительно выше времени, за которое предыдущий блок достигнет каждого узла, то с сетью ничего подобного не произойдёт.


\subsection{Майнинг блока}

Выход криптографической хеш-функции распределяется равномерно и очевидно не зависит от входа. Это означает, что при наличии потенциального входа его хеш в равной степени вероятно станет каждым отдельно взятым возможным выходом. Кроме того, на вычисление каждого отдельного взятого хеша уходит определённое количество времени.

Представьте хеш-функцию $\mathcal{H}_i(x)$, выходы которой являются числами в пределах от 1 до 100: $\mathcal{H}_i(x) \in^D_R \{1,...,100\}$.\footnote{Мы используем $\in^D_R$ , чтобы показать, что выход является детерминировано случайным.} При некотором заданном $x$ функция $\mathcal{H}_i(x)$ выбирает то же самое «случайное» число в диапазоне \{$1,...,100$\} всякий раз, когда вы вычисляете её. На вычисление $\mathcal{H}_i(x)$ уходит одна минута..

Допустим, у нас есть сообщение $\mathfrak{m}$, и нам необходимо вычислить такой «нонс» $n$ (некоторое целое число), чтобы выходы $\mathcal{H}_i(\mathfrak{m},n)$ были числом меньшим или равным {\em заданному значению} $t = 5$ (то есть $\mathcal{H}_i(\mathfrak{m},n) \in \{1,...,5\}$). 

Так как только $1/20$\nth выходов $\mathcal{H}_i(x)$ будет соответствовать целевому значению, потребуется примерно 20 попыток вычислить рабочий $n$ (а следовательно, вычисления займут 20 минут).

Мы называем поиск подходящего нонса {\em майнингом}, а публикация сообщения с его нонсом является {\em доказательством работы}, так как это доказывает, что мы нашли подходящий нонс (даже если нам повезло и для этого понадобился всего один хеш, или же правильный нонс был опубликован просто вслепую), и это может проверить каждый, вычислив $\mathcal{H}_i(\mathfrak{m},n)$.

Теперь, допустим, у нас есть хеш-функция для создания доказательства работы $\mathcal{H}_{PoW} \in^D_R \{0,...,m\}$, где $m$ является максимально возможным выходом. При наличии сообщения $\mathfrak{m}$ (блока информации), нонса $n$ для майнинга и целевого значения $t$ мы можем вычислить ожидаемое количество хешей ({\em сложность} $d$) следующим образом: $d = m/t$. Если\marginnote{src/crypto- note\_basic/ difficulty.cpp {\tt check\_ hash()}} $\mathcal{H}_{PoW}(\mathfrak{m},n)*d \leq m$, то $\mathcal{H}_{PoW}(\mathfrak{m},n) \leq t$ и $n$ принимается.\footnote{В случае Monero записывается/вычисляется только сложность, так как для вычисления $\mathcal{H}_{PoW}(\mathfrak{m},n)*d \leq m$ $t$ не требуется.}

По мере того как целевое значение становится меньше, растёт сложность, и компьютеру требуется всё больше и больше хешей, а также всё больше и больше времени, чтобы найти подходящие нонсы.\footnote{Майнинг и верификация ассиметричны, поскольку верификация доказательства работы занимает какое-то время (одно вычисление алгоритма доказательства работы), и при этом не важно, какова сложность.}


\subsection{Скорость майнинга}

Допустим, что все узлы одновременно занимаются майнингом, но выходят из своего «теку\-щего» блока, как только получают новый из сети. Они немедленно начинают майнинг свежего блока, который ссылается на новый.

Предположим, мы собрали группу блоков $b$ из блокчейна (допустим, с индексом $u \in \{1,...,b\}$), каждый из которых имеет значение сложности $d_u$. Теперь предположим, что узлы, которые произвели майнинг блоков, являются честными, поэтому временная метка каждого блока ${TS}_u$ является точной.\footnote{Временные метки определяются сразу после того, как майнер {\em начинает} майнинг нового блока, поэтому они могу немного отставать от фактического момента публикации. Майнинг следующего блока начинается сразу же. Таким образом, временная метка появляется {\em после} того, как блок обозначит, сколько времени было потрачено на его вычисление майнерами.} Общее время между самым первым блоком и самым последним блоком будет выражено как $\mathit{totalTime} = {TS}_b - {TS}_1$. Приблизительное количество хешей, необходимое для майнинга всех блоков: $\mathit{totalDifficulty} = \sum_u d_u$.

Теперь мы можем понять, насколько быстро сеть, используя все свои узлы, может вычислять хеши. Если фактическая скорость не изменилась значительно в то время, когда производилась группа блоков, то она должна быть следующей:\footnote{Если узел 1 пытается найти нонс $n = 23$, а позже узел 2 также пытается найти нонс $n = 23$, то попытка узла 2 будет потрачена впустую, так как сеть уже «знает», что $n = 23$ не работает (в противном случае узел 1 уже опубликовал бы этот блок). {\em Фактический} хешрейт сети зависит от того, насколько быстро она хеширует {\em уникальные} нонсы для заданного блока сообщений. Как мы увидим далее, поскольку майнеры включают в свои блоки майнинговую транзакцию с одноразовым адресом $K^o \in_{ER} \mathbb{Z}_l$ (где ER = effectively random, т.е. фактическую случайность), у майнеров всегда будут уникальные блоки, за исключением ничтожно малой вероятности, поэтому попытка нахождения одних и тех же нонсов не имеет значения.}%\vspace{.175cm}
\[\mathit{hashSpeed} \approx \mathit{totalDifficulty}/\mathit{totalTime}\]

Если мы хотим задать целевое время для майнинга новых блоков, чтобы блоки производились с частотой\\ \(\textrm{(один блок) / (целевое время)}\), то, исходя из скорости хеширования, мы можем вычислить, сколько хешей потребуется сети, чтобы потратить такое количество времени на майнинг. Примечание: мы округляем значения, поэтому сложность никогда не будет нулевой:%\vspace{.175cm}
\[\mathit{newDifficulty} = \mathit{hashSpeed}*\mathit{targetTime}\]

Нет никакой гарантии, что майнинг следующего блока займёт то количество хешей, которое соответствует $\mathit{newDifficulty}$ , но со временем и с ростом количества блоков, а также при постоянной перекалибровке сложность можно будет использовать для отслеживания реальной скорости хеширования сети, а блоки будут вычисляться близко к $\mathit{targetTime}$.\footnote{Если мы допустим постоянное постепенное повышение хешрейта сети, то, так как новые значения сложности будут зависеть от {\em последних} хешей (то есть предшествующих даже малейшему повышению хешрейта) то можно ожидать, что фактическое время вычисления блоков в среднем будет чуть меньше, чем $\mathit{targetTime}$. В результате этого график эмиссии (см. Раздел \ref{subsec:block-reward}) может быть уравновешен штрафами, связанными с увеличением веса блоков, о чём будет говориться в Разделе \ref{subsec:penalty}.}


\subsection{Консенсус: самая большая совокупная сложность}

Теперь у нас есть механизм разрешения конфликтов между форками блокчейна.

По определению блокчейн с самой высокой совокупной сложностью (всех блоков блокчейна), а следовательно, на построение которого пришёлся наибольший объём работы, считается реальной, легитимной версией. Если блокчейн расходится, и каждый форк имеет одну и ту же совокупную сложность, узлы продолжают майнинг в своём форке до тех пор, пока одна ветвь не перегонит другую, и именно в этой точке более слабая ветвь станет заброшенной (то есть orphaned - «осиротевшей»).%source?

Если узлы захотят изменить или обновить базовый протокол, то есть набор правил, которым следуют узлы при принятии решения, является или нет копия блокчейна или новый блок легитимными, то они легко смогут сделать это, реализовав форк блокчейна. Повлияет или нет новая ветвь каким-либо образом на пользователей, зависит от количества переключив\-шихся узлов, а также от объёма изменений в программной инфраструктуре.\footnote{Разработчики Monero успешно изменяли\marginnote{src/hardforks/ hardforks.cpp {\tt mainnet\_hard\_ forks[]}} протокол 11 раз, и практически все пользователи и майнеры следовали каждому форку: версия v1 18 апреля 2018 (генезис-версия) \cite{bitmonero-launched}; версия v2 в марте 2016; версия v3 в сентябре 2016; версия v4 в январе 2017; версия v5 в апреле 2017; версия v6 в сентябре 2017; версия v7 в апреле 2018; версии v8 и v9 в октябре 2018; версии v10 и v11 в марте 2019; версия v12 в ноябре 2019. В README, выложенном в главном git-репозитории, можно найти краткое описание изменений, внесённых в протокол в рамках каждой версии.}

Если злоумышленник захочет убедить честные узлы изменить историю транзакций, возмож\-но, чтобы повторно потратить / отменить трату средств, ему придётся реализовать форк блок\-чейна (по текущему протоколу), который будет иметь более высокий уровень сложности, чем у текущего блокчейна (который в это время будет по-прежнему расти). Это будет очень трубно сделать, если вы не контролируете 50\% хешрейта сети и не можете обогнать другие майнеры. \cite{Nakamoto_bitcoin}
 
\subsection{Майнинг Monero} %get_difficulty_for_next_block, next_difficulty

Чтобы убедиться в том, что форки блокчейна делаются на ровном основании, нам не понадо\-бится отбирать самые последние блоки (для вычисления новых значений сложности). Вместо этого будет необходимо задержать нашу группу $b$ на $l$. Например, если в блокчейне есть 29 блоков (блоки $1,...,29$), $b = 10$, а $l = 5$, нам нужно будет отобрать блоки 15-24, чтобы вычислить сложность блока 30.

Если узлы, осуществляющие майнинг, не являются честными, они могут манипулировать временными метками таким образом, что значения сложности не будут соответствовать реаль\-ной скорости хеширования сети. Эту проблему можно решить, рассортировав временные метки в хронологическом порядке, а затем отбросив первые посторонние значения $o$, а после и последние посторонние значения $o$. Теперь у нас есть «окно» блоков $w = b-2*o$. Исходя из предыдущего примера, если $o = 3$, а временные метки являются честными, то мы можем отбросить блоки 15-17 и 22-24, оставив блоки 18-21 для вычисления сложности блока 30 на их основе.

Перед тем, как отбросить сторонние значения, мы отсортировали временные метки, но {\em только} временные метки. Сложность блоков осталась не отсортированной. Мы используем совокуп\-ное значение сложности для каждого блока, которое представляет собой значение сложности этого блока плюс значение сложности всех предыдущих блоков в цепочке.

Используя\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt get\_diff- iculty\_for\_ next\_ block()}}[-1.8cm] отброшенные множества временных меток $w$ и совокупные значения сложности (с индексами $1,...,w$), мы можем определить следующее:
\[ \mathit{totalTime} = \mathit{choppedSortedTimestamps}[w] - \mathit{choppedSortedTimestamps}[1]\]
\[ \mathit{totalDifficulty} = \mathit{choppedCumulativeDifficulties}[w] - \mathit{choppedCumulativeDifficulties}[1]\]

В\marginnote{src/crypto- note\_config.h} случае с Monero целевое значение времени составляет 120 секунд (2 минуты), $l = 15$ (30 минут), $b = 720$ (один день), а $o = 60$ (2 часа).\footnote{В марте 2016 (версия v2 протокола) целевое значение времени блоков увеличилось с 1 минуты до 2 минут \cite{monero-0.9.3}. Другие параметры сложности всегда оставались такими же.}\footnote{Алгоритм определения сложности Monero может показаться недостаточно оптимальным, если сравнивать с другими современными алгоритмами \cite{difficuly-algorithm-summary}. Однако, к счастью, он «довольно просто адаптируется к эгоистичному майнингу» \cite{selfish-miner-profitability-algorithm-analysis}, что является его важной особенностью.}

Значения сложности блоков не сохраняются в блокчейне, поэтому кто-либо загружающий копию блокчейна и верифицирующий все блоки на предмет их легитимности, должен пересчи\-тать все значения сложности на основе записанных временных меток. Существует\marginnote{src/crypto- note\_basic/ difficulty.cpp {\tt next\_diff- iculty()}} несколько правил, которые необходимо соблюдать при вычислении первых $b+l = 735$ блоков.

\begin{itemize}
    \item[] \textbf{Правило 1}: Следует полностью игнорировать генезис-блок (блок 0, где $d = 1$). У блоков 1 и 2 значение $d = 1$.
    \item[] \textbf{Правило 2}: Перед тем как отбросить посторонние значения, необходимо попытаться получить окно $w$, чтобы вычислить на его основе итоговые значения.
    \item[] \textbf{Правило 3}: После $w$ блоков следует отбросить высокие и низкие посторонние значения, сведя отброшенную сумму до $b$ блоков. Если сумма предшествующих блоков (минус $w$ будет нечётной, следует удалить ещё одно низкое, а не высокое постороннее значение.
    \item[] \textbf{Правило 4}: После $b$ блоков следует отобрать самые ранние блоки $b$ вплоть до $b+l$ блоков, после чего всё пойдёт нормально с задержкой на $l$.
\end{itemize}


\subsection*{Доказательство работы Monero (PoW)}

В различных версиях протокола Monero\marginnote{src/crypto- note\_basic/ cryptonote\_ tx\_utils.cpp {\tt get\_block\_ longhash()}} использовала несколько различных хеш-алгоритмов доказательства работы (с размером выходов 32 байта). Оригинальный протокол, известный как Cryptonight, был относительно неэффективен применительно к архитектурам GPU, FPGA и ASIC \cite{CryptoNight}, если сравнивать его работу с работой стандартных хеш-функций, таких как SHA256. В апреле 2018 (версия v7 протокола) этот алгоритм был немного изменён, чтобы сделать невозможным майнинг при помощи микросхем ASIC, разработанных под Cryptonight \cite{cryptonight7}, для чего понадобилось добавление новых блоков. Другая, немного отличающаяся от предшествующей, версия алгоритма, Cryptonight V2, была реализована в октябре 2018 (v8) \cite{berylliumbullet-v8}, а версия Crytonight-R (также основанная на Cryptonight, но с более значительными изменениями, которые уже нельзя было назвать небольшими правками) стала использоваться с новыми блоками уже в марте 2019 (v10) \cite{boronbutterfly-v10}. Радикально новый\marginnote{src/crypto/ rx-slow-hash.c} алгоритм доказательства работы под названием RandomX \cite{randomx-pr-5549} был разработан и стал обязательным для использования при вычислении новых блоков в ноябре 2019 (v12), чтобы обеспечить долгосрочную защиту от ASIC-майнинга \cite{randomx}.



\section{Денежная масса}
\label{sec:money-supply}

В случае с криптовалютами, в основе которых лежит блокчейн технология, существует два основных механизма создания денег.

Используя первый способ, создатели валюты могут просто создавать монеты и распростра\-нять их среди людей посредством генезис-сообщения. Часто такой способ называют  «эйрдро\-пом» (airdrop). Иногда создатели криптовалют создают для самих себя большую сумму денег путём так называемого «премайнинга» (pre-mine). \cite{premine-description}

Если использовать второй способ, то криптовалюта автоматически распределяется в качестве вознаграждения за майнинг блоков во многом подобно тому, как это происходит при добыче золота. В данном случае существует два пути. Модель Bitcoin предполагает наличие «потол\-ка» возможной денежной массы. Награды за блок постепенно сводятся к нулю, и после этой точки уже не будет создано ни одной монеты. При реализации инфляционной модели денежная масса продолжает расти до бесконечности. 

Monero основана на валюте, известной как Bytecoin, у которой был большой премайнинг, за которым последовали вознаграждения за майнинг блоков \cite{monero-history}. У Monero не было премайнин\-га, и, как мы увидим, награды за блок медленно сводятся к небольшой сумме, после которой вознаграждение за все новые блоки будет одинаковым, что делает Monero инфляционной валютой.


\subsection{Вознаграждение за майнинг блока}
\label{subsec:block-reward} %get_block_reward

Майнеры, перед тем как начать майнинг нонса, создают «майнинговую транзакцию» (miner transaction) без входов и, по крайней мере, с одним выходом.\footnote{Майнинговая транзакция может содержать любое количество выходов, несмотря на то, что на данный момент базовый вариант реализации позволяет включать только один. Кроме того, в отличие от обычных транзакций какие-либо чёткие ограничения по весу такой транзакции отсутствуют. Они ограничены лишь функционально максимальным размером блоков.} Общая сумма выходов равна вознаграждению за блок плюс комиссии за проведение транзакции со всех транзакций, входящих в блок, и эта сума указывается простым текстом. Узлы, получающие таким образом добытый блок, должны верифицировать\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt validate\_ miner\_ trans- action()}}, является ли вознаграждение правильным, и могут вычислить текущую денежную массу путём суммирования всех последних вознаграждений за майнинг блоков.

Помимо того, что при помощи вознаграждений происходит распределение денег, они также стимулируют сам процесс майнинга. Если бы не было таких вознаграждений (или какого-либо другого механизма), зачем тогда кому-либо понадобилось бы заниматься майнингом новых блоков? Возможно, только из каких-либо альтруистических побуждений или из про\-стого любопытства. Тем не менее наличие нескольких майнеров позволяет злоумышленникам собрать $>$50\% хешрейта сети и без труда переписать историю блокчейна.\footnote{По мере того, как злоумышленнику удаётся заполучить большую часть хешрейта (свыше 50\%), тем меньше у него уходит на то, чтобы переписать всё более и более старые блоки. При наличии блока, созданного $x$ дней назад, и при скорости хеширования $v$, а также честной скорости хеширования $v_h$ ($v > v_h$), такое переписывание займёт $y = x*(v_h/(v-v_h))$ дней.} Вот ещё одна из причин, по которой размер вознаграждения за вычисление блоков Monero не падает до нуля.

При наличии вознаграждений за майнинг блоков между майнерами происходит соревнование, что поднимает общий хешрейт до тех пор, пока маргинальная стоимость добавления хешрейта не станет выше, чем маргинальное вознаграждение за получение пропорции добытых блоков (которая становится постоянным коэффициентом) (плюс некоторые премиальные за риск или альтернативные издержки). Это означает, что валюта становится более ценной, её общий хешрейт растёт, и становится всё более сложно и затратно завладеть $>$50\% хешрейта.

\subsubsection*{Сдвиг разрядов}

Сдвиг разрядов используется для вычисления базового вознаграждения за майнинг блока (как будет указано в подпункте \ref{subsec:penalty}, вознаграждение иногда может опуститься ниже базовой суммы).

Предположим, у нас есть целое число A = 13 в двоичном представлении [1101]. Если сдвинуть разряды A вниз на 2, что можно обозначить как A $>>$ 2, то мы получим [0011].01, что равняется 3,25. В реальности эта последняя часть отбрасывается, «сдвигается» в никуда, и в результате у нас остаётся [0011] = 3.\footnote{Поразрядное смещение на $n$ разрядов эквивалентно целочисленному делению на $2^n$.}

\subsubsection*{Вычисление базового вознаграждения за блок Monero}

Обозначим существующую совокупную денежную массу как M, а «предел» денежной массы как L = $2^{64} - 1$ (в двоичном представлении это будет выглядеть как [11....11] с 64 разрядами).\footnote{Теперь, возможно, вы понимаете, почему доказательства диапазона (см. подпункт \ref{sec:range_proofs}) ограничивают суммы транзакции до 64 бит.} В самом начале базовое вознаграждение за блок Monero составляло \(\textrm{B = (L-M) $>>$ 20}\). Если M = 0, то в десятичном формате мы получим следующее:\vspace{.175cm}
\[\textrm{L} = 18,446,744,073,709,551,615\]
\[\textrm{B}_0 = (L-0) >> 20 = 17,592,186,044,415\]

Эти числа являются «атомными единицами» — 1 атомную единицу Monero нельзя поделить. Очевидно, что атомные единицы просто смехотворны — значение L составляет более 18 квинтиллионов! Мы можем поделить всё на $10^{12}$ , чтобы подвинуть десятичную запятую и получить стандартные единицы Monero (также известные как XMR, так называемый «бирже\-вой тиккер» Monero).\vspace{.15cm}
\[\frac{\textrm{L}}{10^{12}} = 18,446,744.073709551615\]
\[\textrm{B}_0 = \frac{(L-0) >> 20}{10^{12}} = 17.592186044415\]

И так мы получаем вознаграждение за самый первый блок, которое, к слову, ушло человеку под псевдонимом thankful\_for\_today (который и запустил проект Monero) в генезис-блоке Monero \cite{bitmonero-launched} и составило 17.6 Moneroj! Убедиться в этом вы можете, ознакомившись с Приложением \ref{appendix:genesis-block}.\footnote{В блокчейне суммы Monero сохраняются в формате атомных единиц.}

По мере майнинга всё большего количества блоков значение M растёт, что снижает размер вознаграждения за будущие блоки. Изначально (с появлением генезис-блока в апреле 2014) блоки Monero вычислялись по одному в минуту, но уже в марте 2016 майнинг одного блока занимал уже две минуты \cite{monero-0.9.3}. В целях соблюдения и сохранения «графика эмиссии»\footnote{Интересное сравнение графиков эмиссии Monero и Bitcoin приводится в работе \cite{monero-coin-emission}.}, то есть скорости создания денег, размер вознаграждения за майнинг блока был удвоен. Это просто означало, что после изменения размер вознаграждения за майнинг новых блоков стал вычисляться как (L-M) $>>$ 19 вместо $>>$ 20. В настоящее время базовое вознаграждение за майнинг блока является следующим:\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_block\_ reward()}}\vspace{.175cm}
\[\textrm{B} = \frac{(L-M) >> 19}{10^{12}}\]


\subsection{Динамическое весовое значение блока}
\label{subsec:dynamic-block-weight}

Было бы здорово, если бы каждая новая транзакция сразу же включалась в блок. Но что, если бы кто-то со злым умыслом захотел включить сразу множество транзакций? Блокчейн, в котором сохраняется каждая транзакция, быстро бы разросся до чудовищных размеров.

Одним из способов, позволяющих избежать этого, является фиксированный размер блоков (выраженный в байтах), то есть количество транзакций, включаемых в блок, ограничено. А что, если объём честных транзакций вырастет? Автору каждой транзакции придётся добиваться предоставления ему места в новом блоке, предлагая более высокую комиссию майнерам. Майнеры сосредоточат своё внимание на транзакциях с наибольшей комиссией. По мере роста объёма транзакций, комиссии станут непозволительно высокими для транзак\-ций с небольшими суммами (как в случае, когда Элис покупала яблоко у Боба). Только транзакции тех людей, кто предложит больше остальных, попадут в блокчейн.\footnote{В истории Bitcoin были моменты, когда объём транзакций становился слишком большим. На этом сайте (\url{https://bitcoinfees.info/}) зафиксирован невероятный размер комиссий (до 35 долларов США за одну транзакцию в определённый момент времени).}\\

Monero старается избегать подобных крайностей (неограниченного и фиксированного разме\-ра), используя динамическое весовое значение блоков.

\subsubsection*{Размер и вес}

После\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt get\_trans- action\_ weight()}} реализации алгоритма Bulletproofs (v8) размер транзакций и блоков уже не соблюдается так строго. Теперь используется термин {\em вес транзакции (transaction weight)}. Вес майнинговой транзакции (см. подпункт \ref{subsec:miner-transaction}) и обычной транзакции с двумя выходами равен их размеру, выраженному в байтах. Если обычная транзакция содержит более двух выходов, её вес будет несколько больше размера.

Как было сказано в подпункте \ref{sec:range_proofs}, доказательство Bulletproof занимает $(2 \cdot \lceil \textrm{log}_2(64 \cdot p) \rceil + 9) \cdot 32$ байт. Поэтому по мере добавления выходов место, необходимое для сохранения доказательств диапазона, будет сублинейно возрастать. Тем не менее верификация Bulletproofs происходит линейно, поэтому искусственное повышение веса транзакций «стоит» дополнительного време\-ни верификации (это называется «компенсацией затрат»).%see get_transaction_weight_clawback() and n_bulletproof_max_amounts() for exact details

Предположим\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt get\_trans- action\_ weight\_ clawback()}}, что у нас есть транзакция с $p$ выходов, и представим, что если $p$ не в степени 2, мы можем создать достаточное количество ложных выходов, чтобы заполнить пробел. Мы вычисляем разницу между фактическим размером доказательства Bulletproof и размером всех доказательств Bulletproof, если эти $p$ + «ложные выходы» были в транзакциях с двумя выходами (это будет $p = 2$). Мы компенсируем только 80\% разницы.\footnote{Следует отметить, что $\textrm{log}_2(64 \cdot 2) = 7$, а $2*7 + 9 = 23$.}\vspace{.175cm}
\[\textrm{transaction\_clawback} = 0.8*[(23*(p + \textrm{num\_dummy\_outs})/2) \cdot 32 - (2 \cdot \lceil \textrm{log}_2(64 \cdot p) \rceil + 9) \cdot 32]\]

Следовательно, вес транзакции будет следующим:\vspace{.175cm}
\[\textrm{transaction\_weight} = \textrm{transaction\_size} + \textrm{transaction\_clawback}\]

Весовое значение блока\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt create\_ block\_ template()}} равно сумме весов транзакций, входящих в его состав, плюс вес майнинговой транзакции.

\subsubsection*{Долгосрочное весовое значение блока}

Если разрешить быстро увеличивать размер динамических блоков, размер блокчейна также очень скоро станет неконтролируемым \cite{big-bang-github}. Чтобы избежать этого, максимальные весовые значения блоков ограничиваются {\em долгосрочными весовыми значениями блоков}. Помимо обыч\-ного весового значения у каждого блока имеется «долгосрочное весовое значение», которое вычисляется на основе фактического среднего долгосрочного весового значения предшес\-твующего блока.\footnote{Как и в случае со сложностью блоков, обычные и долгосрочные весовые значения блоков вычисляются и сохраняются верификаторами блокчейна, а не включаются в данные блокчейна.} Фактическое среднее долгосрочное весовое значение предшествующего блока связано со средними долгосрочными весовыми значениями самых последних 100000 блоков (включая его собственное значение).\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt update\_ next\_cumu- lative\_ weight\_ limit()}}\footnote{Блоки, созданные до внедрения долгосрочных весовых значений, имеют долгосрочные весовые значения, равные их обычным весовым значениям. Поэтому мы не будем рассматривать подробно то, что связано с генезис-блоком или ранними блоками. Совершенно новая цепочка блоков позволяет делать разумный выбор.}\footnote{В самом начале\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_min\_ block\_ weight()}} составляющая «300 Кбайт» была равна 20 килобайтам, а затем в марте 2016 (версия v2 протокола) выросла до 60 Кбайт \cite{monero-0.9.3}, а начиная с апреля 2017 (версия v5 протокола) составляет 300 Кбайт \cite{monero-v5}. Этот ненулевой «минимальный уровень» средних значений динамического веса блока поспособствовал переходному изменению объёма транзакций, когда абсолютный объём был низок, особенно на ранних этапах внедрения Monero.}%Blockchain::get_next_long_term_block_weight()

\begin{align*}
    \textrm{longterm\_block\_weight} &= min\{\textrm{block\_weight}, 1.4*\textrm{previous\_effective\_longterm\_median}\}\\
    \textrm{effective\_longterm\_median} &= max\{\textrm{300kB}, \textrm{median\_100000blocks\_longterm\_weights}\}%m_long_term_effective_median_block_weight
\end{align*}{}

Если размер обычных весовых значений блоков в течение долгого времени остаётся высоким, то понадобится по крайней мере 50000 блоков (примерно 69 дней), чтобы фактическое долго\-срочное среднее значение выросло на 40\% (именно столько времени необходимо, чтобы долго\-срочное весовое значение стало средним).

\subsubsection*{Совокупное среднее весовое значение}

Объём транзакций может значительно измениться в предельно короткие сроки, особенно в праздники \cite{visa-seasonality}. Для решения этой проблемы Monero предусматривает краткосрочную гибкость весовых значений блоков. Чтобы сгладить\marginnote{{\tt CRYPTONOTE\_ REWARD\_ BLOCKS\_ WINDOW}} переходное изменение, для определения совокупного среднего значения блоков используется среднее значение по обычным весовым значениям последних 100 блоков (включая собственное значение).\vspace{.1cm}
\begin{align*}
    \textrm{cumulative\_weights\_median} = max\{\textrm{300kB}, min\{&max\{\textrm{300kB}, \textrm{median\_100blocks\_weights}\},\\
    &50*\textrm{effective\_longterm\_median}\}\}%HF_VERSION_EFFECTIVE_SHORT_TERM_MEDIAN_IN_PENALTY %update_next_cumulative_weight_limit() %m_current_block_cumul_weight_median %CRYPTONOTE_SHORT_TERM_BLOCK_WEIGHT_SURGE_FACTOR = 50
\end{align*}{}

Следующий блок, добавляемый в блокчейн, ограничивается следующим образом:\footnote{В версии протокола v8 совокупное медианное значение заменило «M100» (подобную среднюю составляющую). При вычислении штрафов и комиссий, описанных в первой редакции этого отчёта \cite{ztm-1}, использовалось значение M100.}\vspace{.1cm}
\[\textrm{max\_next\_block\_weight}\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_block\_ reward()}} = 2*\textrm{cumulative\_weights\_median}\]% handle_block_to_main_chain() -> validate_miner_transaction() ->  get_block_reward()

Несмотря на то, что максимальное весовое значение блока может вырасти в 100 раз больше фактического среднего долгосрочного весового значения после нескольких сотен блоков, оно не может увеличиться более чем на 40\% сверх значения за последние 50000 блоков. Следова\-тельно, рост долгосрочного весового значения блока ограничивается долгосрочными весовыми значениями, а краткосрочные весовые значения могут превысить свои обычные значения.


\subsection{Штраф, налагаемый на вознаграждение за блок}
\label{subsec:penalty}

В случае майнинга блоков, размер которых превышает совокупное среднее значение, майне\-рам приходится платить определённую цену, штраф в форме меньшего вознаграждения за блок. Это означает, что функционально существуют две зоны в пределах максимального весового значения блока: зона без штрафа и зона, облагаемая штрафом. Среднее значение может медленно увеличиваться, что позволяет создавать всё большие блоки без штрафа.

Если весовое значение определённого блока будет больше совокупного среднего значения, то при наличии базового вознаграждения за блок B штраф, налагаемый на вознаграждение за блок, будет следующим:\vspace{.1cm}
\[\textrm{P} = \textrm{B}*((\textrm{block\_weight}/\textrm{cumulative\_weights\_median}) - 1)^2\]

Таким образом, фактический размер вознаграждения\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_block\_ reward()}} за блок будет\footnote{о реализации конфиденциальных транзакций (RingCt)  в версии v4 все суммы передавались простым текстом, а в некоторых ранних версиях разбивались на куски (например $\rightarrow$ 1000 + 200 + 40 + 4). Чтобы сократить размер майнинговых транзакций, в базовой реализации отбрасывались младшие разряды вознаграждения за блок (всё, что было менее 0,0001 Monero; см. {\tt BASE\_REWARD\_CLAMP\_THRESHOLD}). Это были версии v2-v3. Дополнительный малый разряд не терялся, а использовался в будущих вознаграждениях за блок. В более общем смысле, начиная с версии v2\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt validate\_ miner\_trans- action()}}, для вычисления размера вознаграждения за блок просто брался верхний предел реального вознаграждения за блок, который распределялся среди выходов транзакций майнера. Также стоит отметить, что выходы самых ранних транзакций с суммами, прописанными простым текстом, {\em не разбиваются} на части, не являются «смешиваемыми» выходами, которые потом можно было бы потратить в обычных транзакциях RingCT, создавая кольца из других частей с той же суммой. Правила современного протокола, касающиеся этих «древних» выходов, созданных до RingCT, точно не определены.}\vspace{.3cm}
\begin{align*}
    \textrm{B}^{\textrm{actual}} &= \textrm{B} - \textrm{P} \\
    \textrm{B}^{\textrm{actual}} &= \textrm{B}*(1-((\textrm{block\_weight}/\textrm{cumulative\_weights\_median}) - 1)^2)
\end{align*}

Использование операции \^{}2 означает, что штрафы субпропорциональны размеру блока. На весовое значение блока на 10\% выше предшествующего cumulative\_weights\_median налагает\-ся штраф в размере всего 1\% на 50\% выше - 25\% на 90\% выше - штраф в размере 81\% и так далее. \cite{monero-coin-emission}\\

Можно ожидать, что майнеры станут создавать блоки, размер которых будет превышать совокупное значение, если комиссия за добавление очередной транзакции превысит размер налагаемого штрафа.


\subsection{Динамическая минимальная комиссия}
\label{subsec:dynamic-minimum-fee} %get_dynamic_per_kb_fee

Чтобы злоумышленники не смогли заполонить блокчейн своими транзакциями, например с целью «заражения» кольцевых подписей, и в целом раздуть его без какой-либо необходимости, Monero требуется определить минимальный размер комиссии\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt check\_fee()}} на килобайт данных транзак\-ции.\footnote{Этот минимум определяется протоколом консенсуса узлов, а не протоколом блокчейна. Большинство узлов не станут ретранслировать транзакцию другим узлам, если её комиссия будет ниже минимальной\marginnote{src/crypto- note\_core/ tx\_pool.cpp {\tt add\_tx()}} (по крайней мере, частично, и только транзакции, «добытые» будут передаваться \cite{articmine-36c3-dynamics}), но они {\em будут} принимать новые блоки, содержащие такую транзакцию. В частности, это означает отсутствие необходимости в подержании обратной совместимости в случае с алгоритмами вычисления комиссий.} Изначально комиссия просто составляла 0,01 XMR/KiB (добавлена на ранних этапах реализации протокола версии v1) \cite{fee-old-stackexchange}, а затем в сентябре 2016 (v3) уменьшилась до 0,002 XMR/KiB\footnote{Единица измерения KiB (кибибайт, 1 KiB = 1024 байтам) отличается от Кбайт (килобайт, 1 Кбайт = 1000 байтам).}%HF_VERSION_PER_BYTE_FEE

В январе 2017 (версия v4 протокола) был добавлен алгоритм вычисления динамической комиссии на KiB \cite{articmine-fee-video, articmine-36c3-dynamics, articmine-defcon27-video, jollymore-old-analysis} was added,\footnote{В апреле 2017 (версия v5 протокола) размер комиссии снизился с 0,002 XMR/KiB до 0,0004 XMR/KiB \cite{monero-v5}. В первой редакции данного отчёта описан оригинальный алгоритм расчёта динамической комиссии \cite{ztm-1}.}, а затем вместе со снижением веса транзакций после введения Bulletproofs (v8) расчёт стал производиться не в KiB, а в Кбайтах. Самой важной особенностью алгоритма являлось то, что он не даёт размеру минимально возможной общей комиссии превысить размер вознаграждения за блок (даже при небольшом вознагра\-ждении за блок и больших весовых значениях блоков), что, как считалось, стало причиной нестабильности \cite{fee-reward-instability, no-reward-instability, selfish-miner}.\footnote{Выражаем благодарность архитектору схемы динамического размера блоков и системы комиссий Франсиско Кабаньясу (также известному как ArticMine) за концепции, изложенные в данном Разделе. См. работы \cite{articmine-fee-video, articmine-36c3-dynamics, articmine-defcon27-video}.}%, by scaling with both the base block reward and the median.%\cite{dynamic-per-kb-fee}

\subsubsection*{Алгоритм вычисления комиссии}

В основе нашего алгоритма лежит стандартная транзакция \cite{jollymore-old-analysis} весом 3000 байт (подобная транзакции {\tt RCTTypeBulletproof2} с 2 входами и 2 выходами, вес которой, как правило, состав\-ляет 2600 байт)\footnote{ес базовой транзакции Bitcoin с 1 входом и 2 выходами составляет 250 байт \cite{bitcoin-txsizes-2015} или 430 байт в случае с 2 входами / 2 выходами.}, а при вычислении комиссии штраф будет смещаться, если среднее значение будет минимальным (самая малая зона, не облагаемая штрафом, 300 Кбайт) \cite{articmine-36c3-dynamics}. Другими словами, штраф, налагаемый на блок весом 303 Кбайта.% Doing this ensures fees required for common transactions to push up the median directly scale off the default fee, rather than requiring a disjointed multiplier compared to sub-median fees.

Во-первых, комиссия F, сбалансированная с маргинальным штрафом MP путём добавления весового значения TW к блоку весом BW будет следующей:\vspace{.175cm}
\begin{align*}
    \textrm{F} = \textrm{MP} = \textrm{B}&*(([\textrm{BW} + \textrm{TW}]/\textrm{cumulative\_median} - 1)^2 -\\ \textrm{B}&*((\textrm{BW}/\textrm{cumulative\_median} - 1)^2
\end{align*}{}

Определяя коэффициент весового значения блока $\textrm{WF}_b = (\textrm{BW}/\textrm{cumulative\_median} - 1)$, а также коэффициент веса транзакции $\textrm{WF}_t = (\textrm{TW}/\textrm{cumulative\_median})$, упростим:\vspace{.175cm}
\[\textrm{F} = \textrm{B}*(2*\textrm{WF}_b*\textrm{WF}_t + \textrm{WF}_t^2)\]

При наличии весового значения блока, равного 300 Кбайтам (при совокупном среднем значе\-нии, составляющем 300 Кбайт), и нашей стандартной транзакции весом 3000 байт,
\begin{align*}
    \textrm{F}_{\textrm{ref}} &= \textrm{B}*(2*0*\textrm{WF}_t + \textrm{WF}_t^2)\\
    \textrm{F}_{\textrm{ref}} &= \textrm{B}*\textrm{WF}_t^2\\
    \textrm{F}_{\textrm{ref}} &= \textrm{B}*(\frac{\textrm{TW}_{\textrm{ref}}}{\textrm{cumulative\_median}_{\textrm{ref}}})^2
\end{align*}{}

Эта комиссия распространяется на 1\% зоны, облагаемой штрафом (3000 из 300 000). Эта комиссия также может распространяться на 1\% любой зоны, облагаемой штрафом обобщённой стандартной транзакции.\vspace{.175cm}
\begin{align*}
    \frac{\textrm{TW}_{\textrm{ref}}}{\textrm{cumulative\_median}_{\textrm{ref}}} &= \frac{\textrm{TW}_{\textrm{general-ref}}}{\textrm{cumulative\_median}_{\textrm{general}}}\\
    1 &= (\frac{\textrm{TW}_{\textrm{general-ref}}}{\textrm{cumulative\_median}_{\textrm{general}}}) * (\frac{\textrm{cumulative\_median}_{\textrm{ref}}}{\textrm{TW}_{\textrm{ref}}})\\
    \textrm{F}_{\textrm{general-ref}} &= \textrm{F}_{\textrm{ref}}\\
    &= \textrm{F}_{\textrm{ref}}*(\frac{\textrm{TW}_{\textrm{general-ref}}}{\textrm{cumulative\_median}_{\textrm{general}}}) * (\frac{\textrm{cumulative\_median}_{\textrm{ref}}}{\textrm{TW}_{\textrm{ref}}})\\
    \textrm{F}_{\textrm{general-ref}} &= \textrm{B}*(\frac{\textrm{TW}_{\textrm{general-ref}}}{\textrm{cumulative\_median}_{\textrm{general}}}) * (\frac{\textrm{TW}_{\textrm{ref}}}{\textrm{cumulative\_median}_{\textrm{ref}}})
\end{align*}{}

Теперь мы можем масштабировать комиссию на основе реального веса транзакции при извест\-ном среднем значении. Так, например, если транзакция попадает на 2\% в зону, облагаемую штрафом, комиссия удваивается.\vspace{.175cm}
\begin{align*}
    \textrm{F}_{\textrm{general}} &= \textrm{F}_{\textrm{general-ref}} * \frac{\textrm{TW}_{\textrm{general}}}{\textrm{TW}_{\textrm{general-ref}}}\\
    \textrm{F}_{\textrm{general}} &= \textrm{B}*(\frac{\textrm{TW}_{\textrm{general}}}{\textrm{cumulative\_median}_{\textrm{general}}}) * (\frac{\textrm{TW}_{\textrm{ref}}}{\textrm{cumulative\_median}_{\textrm{ref}}})
\end{align*}{}

Это реорганизуется в комиссию, рассчитываемую в байтах, над чем мы и работаем.\vspace{.175cm}
\begin{align*}
    f^{B}_{default} &= \textrm{F}_{\textrm{general}}/\textrm{TW}_{\textrm{general}}\\
    f^{B}_{default} &= \textrm{B}*(\frac{1}{\textrm{cumulative\_median}_{\textrm{general}}}) * (\frac{3000}{300000})
\end{align*}{}

Если объём транзакции будет ниже среднего значения, не будет никакой причины, чтобы размер комиссии оставался на базовом уровне \cite{jollymore-old-analysis}. По умолчанию мы устанавливаем минимум равный 1/5.\vspace{.175cm}
\begin{align*}
    f^{B}_{min} &= \textrm{B}*(\frac{1}{\textrm{cumulative\_weights\_median}}) * (\frac{3000}{300000}) * (\frac{1}{5})\\
    f^{B}_{min} &= \textrm{B}*(\frac{1}{\textrm{cumulative\_weights\_median}}) * 0.002
\end{align*}{}

\subsubsection*{Среднее значение комиссии}

Выходит так, что совокупное среднее значение комиссий можно использовать для проведения спам-атаки. Повышение краткосрочного среднего значения до максимума (50 x долгосрочное среднее значение) позволяет злоумышленнику использовать минимальные комиссии, поддер\-живая высокое весовое значение блоков (относительно органичного объёма транзакций) без особых затрат.

Чтобы избежать этого, мы ограничиваем размер комиссий для транзакций, которые войдут в следующий блок, самым низким из доступных средних значений, в результате чего предпо\-чтение более высоким комиссиям будет отдаваться в любом случае.\footnote{Злоумышленник может потратить достаточное количество средств комиссионными по краткосрочному значению, чтобы достигнуть 50*долгосрочного среднего значения. При текущем (на момент написания отчёта) размере вознаграждения за блок, составляющем 2 XMR, «оптимизированный» злоумышленник может повышать краткосрочное среднее значение на 17\% каждые 50 блоков и достигнуть верхней границы примерно через 1300 блоков (приблизительно 43 часа), потратив 0,39*2 XMR на блок, и при этом на всё им будет потрачено около 1000 XMR (или приблизительно 65k долларов США по текущему курсу), а после он сможет вернуться к минимальной комиссии. Когда среднее значение комиссии станет равным зоне, не облагаемой штрафом, размер минимальной общей комиссии для заполнения зоны, не облагаемой штрафом, составит 0,004 XMR (примерно 0,26 доллара США по текущему курсу). Если среднее значение комиссии будет равным долгосрочному среднему значению, это в соответствии со сценарием спам-атаки составит 1/50 зоны, не облагаемой штрафом. Следовательно, это будет всего 50x краткосрочного среднего значения, 0,2 XMR на блок (13 долларов США). Это составит 2,88 XMR в день против 144 XMR в день (69 дней, пока долгосрочное среднее значение не вырастет на 40\%), чтобы обеспечить поддержку веса каждого блока с 50*долгосрочным средним значением. Затраты в размере 1000 XMR будут оправданными в первом случае, но не во втором. Они сокращаются до 300 XMR плюс 43 XMR на поддержку при последующей эмиссии.}\vspace{.1cm}
\[\textrm{smallest\_median}\marginnote{src/crypto- note\_core\ block- chain.cpp {\tt check\_fee()}} = max\{\textrm{300kB}, min\{\textrm{median\_100blocks\_weights}, \textrm{effective\_longterm\_median}\}\}\]

Поддержание более высоких комиссий при росте объёма транзакций также облегчает коррек\-тировку краткосрочного среднего значения и гарантирует, что транзакции не останутся ожи\-дать своей очереди, так как майнеры, вероятнее всего, введут их в зону, облагаемую штрафом.

Следовательно, фактическая минимальная комиссия будет следующей:\footnote{Чтобы проверить, является ли определённая комиссия правильной, мы создаём 2\% буфер для $f^{B}_{min-actual}$ при наличии целочисленного переполнения (комиссии вычисляются перед тем, как будет окончательно определён вес транзакций). Это означает, что фактическая минимальная комиссия будет следующей: 0.98*$f^{B}_{min-actual}$.\marginnote{src/crypto- note\_core\ block- chain.cpp {\tt check\_fee()}}}\footnote{Исследования по улучшению вычисления минимального размера комиссий продолжаются. \cite{min-fee-research-issue-70}}%Blockchain::check_fee()

\[f^{B}_{min-actual}\marginnote{src/crypto- note\_core\ block- chain.cpp {\tt get\_dyna- mic\_base\_ fee()}} = \textrm{B}*(\frac{1}{\textrm{smallest\_median}}) * 0.002\]

\subsubsection*{Комиссии за проведение транзакций}

Как сказал Кабаньяс в рамках своей содержательной презентации по этой теме \cite{articmine-36c3-dynamics}: «Комис\-сии говорят майнеру о том, насколько большой штраф [авторы транзакции] готовы заплатить, чтобы их транзакция была включена». Майнеры будут заполнять блоки транзакциями в убывающем порядке сумм комиссий \cite{articmine-36c3-dynamics} (если предположить, что у всех транзакций будет одинаковый вес), поэтому, чтобы зайти в облагаемую штрафом зону, должно быть множество транзакций с большими комиссиями. Это означает, что «потолок» весового значения блока может быть достигнут только в том случае, если общий размер комиссий станет, по крайней мере, в 3-4 раза больше базового вознаграждения за блок (а в этой точке фактическое вознаграждение за блок будет равно нулю).\footnote{\label{penaltyzonecost_footnote}Предельный штраф за последние байты, включаемые в блок, сможет рассматриваться как «транзакция», сопоставимая с остальными транзакциями. Чтобы группа транзакций могла выкупить это место для проведения транзакций у майнера, комиссии каждой отдельно взятой транзакции должны быть выше размера штрафа, так как в том случае, если размер хотя бы одной из комиссий будет ниже, майнер сохранит предельное значение вознаграждения. Это последнее предельное вознаграждение, если блок будет заполнен небольшими транзакциями, требует для покупки, по крайней мере, черырёхкратного базового вознаграждения за блок по общей сумме комиссий. Если вес транзакций доходит до максимума (50\% минимальной зоны, не облагаемой штрафом, то есть 150 Кбайт), то, если среднее значение сводится к минимуму (300 Кбайт), то для включения последней предельной транзакции потребуется, по крайней мере, трёхкратный размер общей комиссии.}

Чтобы вычислить комиссии за включение транзакции, основной вариант реализации кошель\-ка Monero использует мультипликаторы «приоритета»\marginnote{src/wallet/ wallet2.cpp {\tt get\_fee\_ multi- plier()}}. «Медленная» транзакция напрямую использует минимальную комиссию, а «нормой» является комиссия (5x), заданная по умолча\-нию, если все транзакции используют «быстрый» (25x) вариант, они могут достичь 2,5\% штрафной зоны, а блок, содержащий «супер срочные» (1000x) транзакции, может на 100\% попасть в штрафную зону.%wallet2::get_fee_multiplier()

Одним из важных последствий введения динамических весовых значений блоков является то, что средний размер общих комиссий за блок будет на порядок величины меньше или, по крайней мере, таким же, как размер вознаграждения за блок (общий размер комиссий может быть равен размеру базового вознаграждения за блок примерно в 37\% штрафной зоны [68.5\% максимального весового значения блока], в то время как штраф будет составлять 13\%). Транзакции, конкурирующие за включение в блок, за которые предлагается более высокая комиссия, способствуют расширению пространства блока и снижению комиссий.\footnote{Поскольку размер вознаграждения за блок со временем снижается, а среднее значение увеличивается из-за роста распространения (теоретически), размер комиссий должен стабильно уменьшаться. С точки зрения «реальной покупательной способности» стоимость включения транзакций будет наименее затронута, если цена Monero вырастет вследствие более широкого распространения валюты и экономической дефляции.} Этот механизм взаимодействия представляет собой серьёзную контрмеру против известной угрозы «эгоистичного майнинга» \cite{selfish-miner}.


\subsection{Последующая эмиссия}
\label{subsec:emission-tail}

Предположим, что есть некая криптовалюта с фиксированным максимальным количеством денежной массы и динамическим весовым значением блока. Спустя какое-то время возна\-граждение за блок достигнет нулевого значения. Более не будет никаких штрафов за превы\-шение веса блока, майнеры смогут просто добавлять любую транзакцию с ненулевой комисси\-ей в свои блоки.

Весовые значения блоков в среднем стабилизируются для всех транзакций, попадающих в сеть, а у авторов транзакций более не будет причины соревноваться, используя комиссии за включение транзакций сверх минимума, который станет нулевым согласно изложенному в подпункте \ref{subsec:dynamic-minimum-fee}.

Это создаёт нестабильную и небезопасную ситуацию. У майнеров практически не будет совершенно никакой мотивации заниматься майнингом новых блоков, что приведёт к падению хешрейта сети и обернётся падением инвестиций. Время вычисления блоков останется тем же по мере корректировки сложности, но в результате риск проведения злоумышленниками атак путём двойной траты станет более ощутимым.\footnote{В случае фиксированной окончательной эмиссии и фиксированного весового значения блоков, как у Bitcoin, ситуация также будет нестабильной. \cite{no-reward-instability}} Если минимальный размер комиссий будет задан как ненулевой, то угроза «эгоистичного майнинга» \cite{selfish-miner} станет вполне реальной \cite{no-reward-instability}.\\

В случае Monero\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_block\_ reward()}} эта проблема решается следующим образом: вознаграждение за блок не может упасть ниже 0,6 XMR (0,3 XMR в минуту). Это означает, что если соблюдается следующее условие\vspace{.175cm}
\begin{align*}
               0.6 &> ((L-M) >> 19)/10^{12} \\
        \textrm{M} &> \textrm{L} - 0.6*2^{19}*10^{12} \\
\textrm{M}/10^{12} &> \textrm{L}/10^{12} - 0.6*2^{19} \\
\textrm{M}/10^{12} &> 18,132,171.273709551615
\end{align*}

то блокчейн Monero никогда не войдёт в состояние так называемой «последующей эмиссии» (emission tail) и вознаграждение в размере 0,6 XMR (0,3 XMR в минуту) будет выплачиваться по-прежнему.\footnote{Начало последующей эмиссии Monero запланировано на май 2022 \cite{monero-tail-emission}. Предельное значение денежной массы L будет достигнуто в мае 2024, но, так как эмиссия более не будет зависеть от денежной массы, это не будет иметь значения. В силу доказательства диапазона Monero в одном выходе будет невозможно отправлять сумму, превышающую значение L, даже если кто-то решит накопить больше этого (и с учётом того, что программное обеспечение кошелька такого пользователя позволит делать подобное).} Сначала это соответствует примерно 0,9\% годовой инфляции и снижается впоследствии.


\subsection{Майнинговая транзакция: {\tt RCTTypeNull}}
\label{subsec:miner-transaction} %-fees -> summed into block reward and spent in the miner tx (construct_miner_tx function)

Майнер блока может заявить своё право на комиссии с транзакций, включаемых в него, и создавать новые деньги в форме вознаграждения за блок. Механизм, позволяющий сделать это, называется «майнинговой транзакцией» (также известной как coinbase-транзакция), по\-добной обычной транзакции\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ miner\_tx()}}.\footnote{В определённый момент майнинговые транзакции можно было строить в формате урезанных транзакций, которые могли включать в себя некоторые компоненты обычных транзакций (RingCT). Проблемы были устранены в версии v12 после публикации этого хакерского отчёта: \cite{miner-tx-checks}.}

Сумма в выходе (выходах) транзакции майнера должна превышать сумму комиссий транзак\-ций и вознаграждения за блок, и она указывается простым текстом.\footnote{В текущей версии майнеры могут запросить меньше вознаграждение, чем составляет фактическое вычисленное вознаграждение за блок. Остаток отправляется обратно в график эмиссии для будущих майнеров.} На месте данных выхода записывается высота блока (то есть «Я запрашиваю вознаграждение за блок и комис\-сии за блок n»).

Факт владения выходом (выходами) майнера указывается путём назначения стандартного адреса\footnote{Выход майнинговой транзакции теоретически может быть отправлен на подадрес и/или использоваться в мультиподписи и/или зашифрованном ID платежа. Нам не известно, используются или нет эти возможности в каком-либо из вариантов реализации.} с соответствующим публичным ключом транзакции, который сохраняется в поле дополнительных данных. Средства блокируются и их нельзя потратить ещё в течение 60 блоков после публикации \cite{transaction-lock}.\footnote{Майнинговая транзакция не может быть заблокирована более чем или менее чем на 60 блоков. Если она будет опубликована на 10 блоке, то будет разблокирована именно на высоте 70, и её можно будет потратить на блоке 70 или позднее.\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt is\_tx\_ spendtime\_ unlocked()}}[.5cm]}%justification? Blockchain::prevalidate_miner_transaction()

С тех пор как в январе 2017 (версия v4 протокола) \cite{ringct-dates} был реализован протокол RingCT, людям, загружающим новую копию блокчейна, приходится вычислять обязательство по сумме\marginnote{src/block- chain\_db/ blockchain\_ db.cpp {\tt add\_trans- action()}} $a$ их майнинговой транзакции (также известной как tx) как $C = 1G + aH$ и сохранять его для ссылки. Это означает, что майнеры блоков могут тратить выходы своих майнинговых транзакций как выходы обычных транзакций, смешивая их с другими выходами в кольцах MLSAG как обычных, так и майнинговых транзакций.\\

Верификаторы блокчейна сохраняют обязательство по сумме каждой майнинговой транзак\-ции блока, созданного после реализации RingCT, и размер каждого обязательства составляет 32 байта.



\section{Структура блокчейна}
\label{sec:blockchain-structure}

Monero использует простой стиль блокчейна.

Блокчейн начинается с генезис-сообщения\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt generate\_ genesis\_ block()}} какого-либо рода (в нашем случае это, как правило, майнинговая транзакция, распределяющая вознаграждение за первый генезис-блок (см. При\-ложение \ref{appendix:genesis-block})). Следующий блок содержит ссылку на предыдущий блок в форме ID (идентифи\-катора) блока.

ID блока является простым хешем\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt get\_block\_ hashing\_ blob()}}[1.2cm] заголовка блока (списка данных блока), так называемого «корня Меркла», который присоединяет все ID транзакций блока (которые являются хешами каждой транзакции), и количества транзакций (включая майнинговую транзакцию).\footnote{+1 означает включение майнинговой транзакции.}\vspace{.175cm}
%calculate_block_hash, which ultimately uses cn_fast_hash(get_block_hashing_blob)
\[\textrm{Block ID} = \mathcal{H}_n(\textrm{Block header}, \textrm{Merkle root}, \# \textrm{transactions} + 1)\]\vspace{.05cm}

Чтобы создать новый блок, необходимо вычислить хеши доказательства работы, изменяя значение нонса, которое хранится в заголовке блока, до тех пор, пока не будет выполнено целевое условие сложности.\footnote{В случае с Monero типичный майнер (по данным \url{https://monerobenchmarks.info/})  может выдавать менее 50000 хешей в секунду, то есть менее 6  миллионов хешей на блок. Это означает, что переменная нонса не обязательно должна быть такой величины. Размер нонса Monero составляет 4 байта (максимум 4,3 миллиарда), и было бы странно, если бы какому-то майнеру понадобились все разряды.} Доказательство работы и ID блока хешируют одну и ту же информацию, но используют разные хеш-функции. Блоки создаются\marginnote{{\tt get\_block\_ longhash()}} (при \linebreak $({PoW}_{output} * {difficulty}) > 2^{256}-1$) путём циклического изменения нонса и пересчёта\vspace{.175cm}
\[{PoW}_{output} = \mathcal{H}_{PoW}(\textrm{Block header}, \textrm{Merkle root}, \# \textrm{transactions} + 1)\]\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt calculate\_ block\_ hash()}}


\subsection{ID транзакции}
\label{subsec:transaction-id} %calculate_transaction_hash
        %each arrow is a hash
Идентификаторы транзакций похожи на сообщения, подписанные MLSAG-подписью входов (см. подпункт \ref{full-signature}), но также включают в себя MLSAG подписи.

Хешируется следующая информация:
\begin{itemize}
    \item Префикс транзакции\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt calculate\_ transa- ction\_ hash()}}  = \{версия эры транзакции (то есть RingCT = 2), входы \{офсеты ключей, образы ключей\}, выходы \{одноразовые адреса\}, дополнительные данные \{пуб\-личный ключ транзакции, ID платежа или зашифрованный ID платежа, прочее\}\}
    \item Тело транзакции = \{тип подписи ({\tt RCTTypeNull} или {\tt RCTTypeBulletproof2}), размер ко\-миссии за транзакцию, обязательства по псевдовыходам, ecdhInfo (зашифрованные или указанные простым текстом суммы), обязательства по выходам\}
    \item Подписи = \{MLSAGs, доказательства диапазона\}
\end{itemize}

На следующей диаграмме черными стрелками показаны хеши входов.
        
\begin{center}
    \begin{forest}
        forked edges,
        for tree = {grow'=90, 
                    edge = {<-, > = triangle 60},
                    fork sep = 4.5 mm,
                    l sep = 8 mm,
                    rectangle, draw
                    },
        sn edges,
        where n children=0{tier=terminus}{},
        [Идентификатор транзакции
            [$\mathcal{H}_n$(Префикс транзакции)]
            [$\mathcal{H}_n$(Тело транзакции)] [$\mathcal{H}_n$(Подписи)]
        ]
    \end{forest}    
\end{center}

Вместо «входа» майнинговая транзакция записывает высоту своего блока. Это гарантирует, что ID майнинговой транзакции, который, по сути, является ID обычной транзакции, за тем лишь исключением, что включает $\mathcal{H}_n$(Подписи) $\rightarrow$ 0, всегда будет уникальным, что упрощает поиск ID.


\subsection{Дерево Меркла}
\label{subsec:merkle-tree} %tree_hash

Некоторые пользователи могут пожелать выбросить ненужные данные из своей копии блок\-чейна. Например, когда вы проверяете доказательства диапазона и подписи входов некоторых транзакций, единственной причиной сохранения этой информации по подписям является возможность самостоятельной верификации транзакции пользователями, получившими её от вас.

Чтобы\marginnote{src/crypto/ tree-hash.c {\tt tree\_hash()}} облегчить «обрезание» данных транзакций, а также для их более общей организации внутри блока, нами используется дерево Меркла \cite{merkle-tree}, которое является простым двоичным деревом хешей. Любая ветвь дерева Меркла может быть обрезана, если вы сохраните её корневой хеш.\footnote{Первый известный метод обрезания появился в версии v0.14.1 базовой реализации Monero (март 2019, что совпадает с версией v10 протокола). После верификации транзакции полные узлы могут удалить все данные подписей (включая Bulletproofs, MLSAGs и обязательства по псевдо выходам), но сохранить $\mathcal{H}_n$(Подписей) для вычисления ID транзакции. Но делают это только с 7/8 всех транзакций, поэтому каждая транзакция сохраняется, по крайней мере, 1/8 полных узлов сети. Это сокращает место, необходимо для хранения блокчейна, примерно на 2/3. \cite{monero-pruning-1/8}}\\

На рисунке \ref*{chapter:blockchain}.1 схематически показан пример дерева Меркла, в основе которого лежат четыре обычные и одна майнинговая транзакция.\footnote{Ошибка в коде вычисления дерева Меркла стала причиной серьёзной, но очевидно не критичной атаки на Monero, которая была произведена 4 сентября 2014 \cite{MRL-0002-merkle-problem}.}

\begin{center}
    \begin{forest}
        forked edges,
        for tree = {grow'=90, 
                    edge = {<-, > = triangle 60},
                    fork sep = 4.5 mm,
                    l sep = 8 mm,
                    rectangle, draw
                    },
        sn edges,
        where n children=0{tier=terminus}{},
        [Корень Меркла  
            [{\em Хеш} B
                [Идентификатор \\транзакции \\1]
                [Идентификатор \\транзакции \\2]
            ] 
            [{\em Хеш} C
                [Идентификатор \\транзакции \\3]
                [{\em Хеш} A
                    [Идентификатор \\транзакции \\4]
                    [Идентификатор \\майнинговой \\транзакции]
                ]
            ]
        ]
        \node at (current bounding box.south)
        [below=3ex,thick,draw,rectangle]
        {\emph{Рисунок \ref*{chapter:blockchain}.1: Дерево Меркла}};
    \end{forest}
\end{center}

Как видно, корень Меркла ссылается на все включённые транзакции.



\newpage
\subsection{Блоки}
\label{subsec:blocks} %https://monero.stackexchange.com/questions/3958/what-is-the-format-of-a-block-in-the-monero-blockchain/6461#6461

Блок в основном состоит из заголовка блока и нескольких транзакций. В заголовках блока записывается важная информация о каждом блоке. На транзакции, входящие в состав блока, можно выйти через корень Меркла. Ниже нами кратко описано содержание блоков. Пример реального блока приводится в Приложении \ref{appendix:block-content}.
\begin{itemize}
    \item \underline{Заголовок блока}:
    \begin{itemize}
        \item \textbf{Старшая версия}: Использовалась для отслеживания хардфорков (изменений протокола).
        \item \textbf{Младшая версия}: Ранее использовалась для голосования, а теперь просто для отображения старшей версии.
        \item \textbf{Временная метка}:\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt check\_ block\_ timestamp()}} Время блока по UTC (всемирное координированное время). Добавляется майнерами. Временные метки не верифицируются, но они не будут приняты, если будут ниже среднего значения всех временных меток последних 60 блоков. %check_block_timestamp
        \item \textbf{Идентификатор предыдущего блока}: Ссылка на предыдущий блок. Это важ\-ная характеристика блокчейна.
        \item \textbf{Нонс}: 4-байтовое целое число, которое майнеры перебирают снова и снова, пока хэш доказательства работы (PoW) не достигнет целевого уровня сложности. Любой желающий в качестве проверки может повторно пересчитать полученный хэш\linebreak доказательства работы.
    \end{itemize}
    \item \underline{Майнинговая транзакция}: Распределяет вознаграждение за блок и комиссию за тран\-закции между майнерами блока.
    \item \underline{Идентификаторы транзакции}: Ссылаются на не майнинговые транзакции, добавленные в блокчейн вместе с этим блоком. Идентификаторы транзакций могут в сочетании с идентификаторами майнинговой транзакции использоваться для вычисления корня Меркла, а также для вычисления фактических транзакций, где бы те не хранились.\\
\end{itemize}\vspace{.05cm}

Помимо данных каждой транзакции (см. подпункт \ref{sec:transaction_summary}) мы сохраняем следующую информа\-цию:
\begin{itemize}
    \setlength\itemsep{\listspace}
    \item Старшую и младшую версии: переменные целые числа $\leq 9$ байтам.
    \item Временную метку: переменное целое число $\leq 9$ байтам.
    \item Идентификатор предыдущего блока: 32 байта.
    \item Нонс: Размер нонса составляет 4 байта, но фактический размер может быть увеличен за счёт дополнительного нонса дополнительного поля майнинговой транзакции\footnote{В каждой транзакции есть «дополнительное» поле, которое может содержать более или менее произвольные данные. Если майнеру нужен более широкий, чем 4 байта, диапазон нонсов, он может добавить или изменить данные в дополнительном поле своей майнинговой транзакции, чтобы «расширить» размер нонса. \cite{extra-field-stackexchange}}
    \item Майнинговую транзакцию: 32 байта на одноразовый адрес, 32 байта на публичный ключ транзакции (+ 1 байт для «дополнительного» тега), а также переменные целые числа для времени разблокировки, высоты и суммы. После загрузки блокчейна нам также понадобится 32 байта для хранения обязательства по суммам $C = 1G + a H$ (касается только сумм майнинговых транзакций, созданных после реализации RingCT).
    \item Идентификаторы транзакций: по 32 байта на каждый.
\end{itemize}