\chapter{Кольцевые конфиденциальные транзакции (RingCT)}
\label{chapter:transactions}

В Главах \ref{chapter:addresses} и \ref{chapter:pedersen-commitments} нами были рассмотрены несколько аспектов транзакций Monero. До этого момента проведение простой транзакции с одним входом и одним выходом некоторым неиз\-вестным отправителем какому-то неизвестному получателю происходило примерно так:

«В моей транзакции используется публичный ключ $r G$. Я потрачу старый выход $X$ (следует отметить, что в нём имеется скрытая сумма $A_X$, обязательство по которой содержится в $C_X$). Я дам обязательство по псевдовыходу $C'_X$. Я создам один выход $Y$, который можно будет потратить по одноразовому адресу $K^o_Y$. В нём будет скрытая сумма $A_Y$, обязательство по которой будет содержаться в $C_Y$, которая будет зашифрована для получателя и которая будет доказана в определённом диапазоне в стиле доказательств диапазона Bulletproofs. Следует отметить, что $C'_X - C_Y = 0$».

Но остаются некоторые вопросы. Действительно ли отправитель является обладателем $X$? Действительно ли обязательство по псевдовыходу $C'_X$ соответствует $C_X$ так, что $A_X = A'_X = A_Y$? Может, кто-то вмешался в транзакцию и направил выход тому получателю, которому отправитель транзакции и не собирался отправлять его?
\\

Как было сказано в подпункте \ref{sec:one-time-addresses}, мы можем доказать факт обладания выходом, подписав сообщение его одноразовым адресом (тот, у кого имеется ключ от адреса, владеет и выходом). Мы также можем доказать, что в нём содержится та же сумма, что и в обязательстве по псевдовыходу, доказав знание приватного ключа к нулевому обязательству ($C_X - C'_X = z_X G$). Более того, если такое сообщение является {\em всеми данными транзакции} (кроме самой подписи), то верификатор может быть уверен в том, что всё происходит именно так, как того хотел отправитель (подпись работает только в случае с оригинальным сообщением). MLSAG-подписи позволяют нам делать всё это, скрывая при этом выход, который тратится на самом деле, среди других выходов, взятых из блокчейна. Таким образом, внешний наблюдатель никогда не сможет сказать с уверенностью, какой из выходов является действительным.

\section{Типы транзакций}
\label{sec:transaction_types}

Monero\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key()}} является криптовалютой, постоянно находящейся в разработке. Структуры транзак\-ций, протоколы и криптографические схемы развиваются по мере появления инноваций, новых задач или угроз.

В данном отчёте мы уделяем основное внимание {\em протоколу кольцевых конфиденциальных транзакций (Ring Confidential Transactions)}, также известному как {\em RingCT}, так как он исполь\-зуется в текущей версии Monero. Протокол RingCT обязателен для использования при созда\-нии всех новых транзакций Monero, поэтому мы не станем описывать унаследованные типы транзакций, хотя они до сих пор частично поддерживаются.\footnote{Протокол RingCT был впервые реализован в январе 2017 (в версии v4 протокола). Он стал обязательным для использования при создании всех новых транзакций в сентябре 2017 (в версии v6 протокола) \cite{ringct-dates}. RingCT является второй версией протокола транзакций Monero.} Вплоть до этого момента и в дальнейшем мы будем рассматривать тип транзакций, называемый {\tt RCTTypeBulletproof2}.\footnote{За время существования RingCT произошёл отказ от трёх типов транзакций: {\tt RCTTypeFull}, {\tt RCTTypeSimple} и {\tt RCTTypeBulletproof}. Первые две использовались в первой итерации RingCT и рассматриваются в первой редакции данного отчёта \cite{ztm-1}. Затем, после появления Bulletproofs (версия v8 протокола), произошёл отказ от {\tt RCTTypeFull}, а тип {\tt RCTTypeSimple} был обновлён до {\tt RCTTypeBulletproof}. {\tt RCTTypeBulletproof2} появился по причине небольшого усовершенствования шифрования масок и сумм в обязательствах по выходам (v10).}

В подпункте \ref{sec:transaction_summary} нами приводится краткое описание концепции данных транзакций.



\section{Конфиденциальные транзакции {\tt RCTTypeBulletproof2}}
\label{sec:RCTTypeBulletproof2}

В настоящее время (версия v12 протокола) при проведении всех транзакций требуется исполь\-зовать именно этот тип, где каждый выход подписывается отдельно. Реальный пример транзакции {\tt RCTTypeBulletproof2} со всеми её компонентами приводится в Приложении \ref{appendix:RCTTypeBulletproof2}.


\subsection{Обязательства по сумме и комиссии за проведение транзакций}
\label{sec:commitments-and-fees}

Допустим, отправителем транзакции ранее были различные выходы с суммами $a_1, ..., a_m$ направленные на одноразовый адрес $K^o_{\pi,1}, ..., K^o_{\pi,m}$ с обязательствами по сумме $C^a_{\pi,1}, ..., C^a_{\pi,m}$.

Этому отправителю известны приватные ключи $k^o_{\pi,1}, ..., k^o_{\pi,m}$, соответствующие одноразовым адресам (см. подпункт \ref{sec:one-time-addresses}). Отправителю также известны скрывающие факторы $x_j$, исполь\-зуемые в обязательствах $C^a_{\pi,j}$ (см. подпункт \ref{sec:pedersen_monero}).

Как правило, выходы транзакций в целом {\em ниже}, чем входы транзакций, что обеспечивает возможность выплаты комиссий майнерам за включение ими транзакции в блокчейн.\footnote{Протокол Monero предполагает наличие минимального размера базовой комиссии, который масштабируется по мере увеличения веса транзакции. Это «полуобязательное»  требование, поскольку, несмотря на то, что вы можете создавать новые блоки, содержащие транзакции с небольшой комиссией, большинство узлов Monero не станут ретранслировать такие транзакции другим узлам. В результате лишь немногие майнеры станут включать их в блоки (если вообще станут). Авторы транзакций могут по желанию увеличить размер комиссии сверх минимального. Более подробно эта проблема рассматривается в подпункте \ref{subsec:dynamic-minimum-fee}.} Суммы комиссий за проведение транзакций $f$ хранятся в форме обычного текста в данных транзакций, передаваемых в сеть. Майнер для себя может создать дополнительный выход с комиссией (см. подпункт \ref{subsec:miner-transaction}).

Транзакция состоит из входов \(a_1, ..., a_m\) и выходов \(b_0, ..., b_{p-1}\) в результате чего получаем \(\sum\limits_{j=1}^m a_j - \sum\limits_{t=0}^{p-1} b_t - f = 0\).\footnote{В соответствии с базовым вариантом реализации выходы\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key()}}[-1.9cm] перемешиваются случайным образом до того, как им будет присвоен индекс, поэтому внешний наблюдатель не в состоянии произвести эвристический анализ их порядка. Входы сортируются образом ключа в рамках данных транзакции.}

Отправитель вычисляет обязательство по псевдовыходу для сумм во входах, $C'^a_{\pi,1}, ..., C'^a_{\pi,m}$, и создаёт обязательства для заданных сумм выходов $b_0, ..., b_{p-1}$. Обозначим эти обязательства как $C^b_0, ..., C^b_{p-1}$.

Ему известны приватные ключи $z_1,...,z_m$ к нулевым обязательствам $(C^a_{\pi,1} - C'^a_{\pi,1}),...,(C^a_{\pi,m} - C'^a_{\pi,m})$.

Для верификаторов, которым необходимо подтвердить, что сумма сумм транзакции равна нулю, сумма комиссии должна быть преобразована в обязательство. Решение заключается в вычислении обязательства по комиссии $f$ без маскирующего эффекта какого-либо «ослепляю\-щего» фактора. То есть $C(f) = f H$.

Теперь\marginnote{src/ringct/ rctSigs.cpp verRct- Semantics- Simple()} мы можем доказать, что сумма входов равна сумме выходов:\\
\[(\sum_j C'^a_{j} - \sum_t C^b_{t}) - f H = 0\]


\subsection{Подпись}
\label{full-signature}

Отправитель выбирает из блокчейна $m$ наборов дополнительных несвязанных адресов и их обязательства с размером $v$, соответствующих очевидно неотправленным выходам.\footnote{\label{input-selection}В случае с Monero стандартный выбор набора\marginnote{src/wallet/ wallet2.cpp {\tt get\_outs()}} «дополнительных несвязанных адресов», как правило, происходит в соответствии с определением гамма-распределения\marginnote{{\tt gamma\_picker ::pick()}}[1.2cm] по всему ряду старых выходов (только выходов RingCT — треугольное распределение применяется только в отношении выходов, которые появились до реализации RingCTRi). Данный метод подразумевает применение процедуры биннинга, чтобы сгладить различие в плотности блоков. Сначала вычисляется среднее время между созданием выходов транзакций, вплоть до года в случае с выходами RingCT (среднее время = [\#кол-во выходов/\#кол-во блоков]*время создания блока). При помощи гамма-распределения выбирается блок, а затем из блока выбирается случайный выход, который войдёт в набор. \cite{AnalysisOfLinkability}}\footnote{В версии v12 протокола все входы должны быть созданы по крайней мере 10 блоков назад ({\tt CRYPTONOTE\_DEFAULT\_TX \_SPENDABLE\_AGE}). До выхода версии v12 в основном варианте реализации по умолчанию использовалось 10 блоков, но это не было обязательным требованием, поэтому любой кошелёк мог использовать иное количество блоков, и в некоторых случаях это было действительно так \cite{visualizing-monero-vid}.} Чтобы подписать вход $j$, он перемешивает набор с размером $v$, создавая {\em кольцо} с собственным непотраченным одноразовым адресом $j$\nth (с назначенным уникальным индексом $\pi$) и ложны\-ми нулевыми обязательствами следующим образом:\footnote{В случае с Monero каждое кольцо любой транзакции должно быть одинакового размера, а протокол регулирует количество участников кольца на каждый выход, который тратится. Это количество менялось от версии к версии: v2 (март 2016) $\geq$ 3, v6 (сентябрь 2017) $\geq$ 5, v7 (апрель 2018) $\geq$ 7, 7, v8 (октябрь 2018) — только 11. Начиная с версии\marginnote{src/crypto- note\_core/ cryptonote\_ core.cpp {\tt check\_ tx\_inputs\_ ring\_members\_ diff()}} v6 ни одно из колец не могло содержать повторяющихся участников. Тем не менее в разных кольцах участники могли повторяться, что позволяло использовать множество входов при недостаточном количестве выходов в истории транзакций (то есть можно было создавать кольца без пересечения) \cite{duplicate-ring-members}.}
%functions get_random_rct_outs for rct outputs mixed into an rct spend, and get_random_outputs for pre-rct outputs mixed into a pre-rct spend. These are only used for light wallets -> instead it is wallet2::get_outs for most situations.
%--ring member selection changing to gamma distribution in fall 2018
%CRYPTONOTE_DEFAULT_TX_SPENDABLE_AGE = 10 blocks

\begin{align*}
    \mathcal{R}_j = \{&\{K^o_{1, j}, (C_{1, j} - C'^a_{\pi, j})\}, \\
    &... \\
    &\{ K^o_{\pi, j}, (C^a_{\pi, j} - C'^a_{\pi, j})\}, \\
    &... \\
    &\{ K^o_{v+1, j}, (C_{v+1, j} - C'^a_{\pi, j})\}\}
\end{align*}

Чтобы подписать своё кольцо\marginnote{src/ringct/ rctSigs.cpp proveRct- MGSimple()}, где ей известны приватные ключи $k^o_{\pi,j}$ для $K^o_{\pi,j}$, Элис использу\-ет MLSAG-подпись (см. подпункт \ref{sec:MLSAG}) и $z_j$ в качестве нулевого обязательства $(C^a_{\pi,j}$ - $C'^a_{\pi,j})$. Поскольку в случае с нулевым обязательством в образе ключа нет необходимости, то и в структуре подписи такого компонента тоже не будет.\footnote{При построении и верификации подписи исключается член $r_{i,2} \mathcal{H}_p(C_{i, j} - C'^a_{\pi, j}) + c_i \tilde{K}_{z_j}$.}

Каждый вход транзакции подписывается индивидуально при помощи таких колец, как \(\mathcal{R}_j\), о чём говорилось выше. Это позволяет скрыть выходы, которые тратятся на самом деле, ($K^o_{\pi,1},...,K^o_{\pi,m}$), среди других непотраченных выходов.\footnote{Преимущество  раздельного подписания входов состоит в отсутствии необходимости расположения реальных входов и нулевых обязательств по одному и тому же индексу $\pi$, как это было бы в случае агрегации. Это означает, что даже если один из источников входа станет известен, остальные останутся скрытыми. Старый тип транзакций {\tt RCTTypeFull} подразумевал использование агрегированных подписей, где все кольца объединялись в одно, и именно по этой причине мы отказались от него.} Поскольку определённая часть каж\-дого кольца содержит нулевое обязательство, используемое обязательство по псевдовыходу должно содержать сумму, равную сумме входа, который реально тратится. Это связывает входы с доказательством равенства сумм. При этом не раскрывается, какой из участников кольца является реальным входом.

Сообщение $\mathfrak{m}$, подписываемое каждым входом, по сути, является хешем всех данных транзак\-ций, {\em за исключением} MLSAG-подписей.\footnote{Фактическим\marginnote{src/ringct/ rctSigs.cpp {\tt get\_pre\_ mlsag\_hash()}} сообщением является $\mathfrak{m} = \mathcal{H}(\mathcal{H}(tx\textunderscore prefix),\mathcal{H}(ss),\mathcal{H}(\text{range proofs}))$, где:\par
$tx\textunderscore prefix = $\{версия эры транзакции (то есть RingCT = 2), входы \{офсеты ключей участников кольца, образы ключей\}, выходы \{одноразовые адреса\}, дополнительные данные \{публичный ключ транзакции, ID платежа или прочее,\}\}\par
$ss = $\{тип транзакции ({\tt RCTTypeBulletproof2} = `4'), комиссия за проведение транзакции, обязательства по псевдовыходам для соответствующих входов, ecdhInfo (зашифрованные суммы), обязательства по выходам\}.\par
Терминология определяется в Приложении \ref{appendix:RCTTypeBulletproof2}.} Это гарантирует защиту транзакций от внесения изменений как с точки зрения её авторов, так и верификаторов. Создаётся только одно сообщение, и оно подписывается каждым входом MLSAG.

Одноразовый приватный ключ $k^o$ является сущностью модели транзакций Monero. Подписа\-ние сообщения $\mathfrak{m}$ при помощи $k^o$ доказывает, что вы владеете суммой, обязательство по которой даётся в $C^a$. Верификаторы могут быть уверены в том, что авторы транзакции тратят собственные средства, даже не зная, какие средства тратятся, сколько тратится и сколько ещё средств остаётся у таких авторов!


\subsection{Исключение возможности двойной траты}

Подпись\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt have\_tx\_ keyimges\_ as\_spent()}} MLSAG (см. подпункт \ref{sec:MLSAG}) содержит образы \(\tilde{K}_{j}\) приватных ключей \(k_{\pi, j}\). Важным свойством каждой криптографической схемы подписей является невозможность её подделки с высокой степенью вероятности. Следовательно, во всех практических смыслах мы можем допустить, что образы ключей подписи должны детерминировано выводиться из действи\-тельных приватных ключей.

Сети необходимо только проверить, чтобы образы ключей, включённые в MLSAG-подписи (соответствующие входам и вычисленные как $\tilde{K}^o_{j} = k^o_{\pi,j} \mathcal{H}_p(K^o_{\pi,j})$), не встречались ранее в других транзакциях.\footnote{Верификаторы также должны проверить, является ли образ изображения членом подгруппы генератора (см. подпункт \ref{blsag_note}).} Если встречались, то вы можете быть уверенными в том, что столкнулись с попыткой двойной траты выхода $(C^a_{\pi,j}, K_{\pi,j}^o)$.


\subsection{Требования к занимаемому месту}
\label{subsec:space-and-ver-rcttypefull}

\subsubsection*{Подпись MLSAG (входы)}

Как мы помним из подпункта \ref{sec:MLSAG}, MLSAG- подпись в данном контексте будет выражена как

\hfill \(\sigma_j(\mathfrak{m}) = (c_1, r_{1, 1}, r_{1, 2}, ..., r_{v+1, 1}, r_{v+1, 2}) \textrm{ with } \tilde{K}^o_j \) \hfill \phantom{.}

В силу наследия, оставленного CryptoNote, значения \(\tilde{K}^o_j\) не считаются частью подписи, а, скорее, являются {\em образами} приватных ключей $k^o_{\pi,j}$. Эти {\em образы ключей} обычно хранятся отдельно в рамках структуры транзакции, так как они используются для выявления атак с попыткой двойной траты.

Учитывая всё это, а также сжатие точек (см. подпункт \ref{point_compression_section}), поскольку каждое кольцо \(\mathcal{R}_j\) содержит \((v+1) \cdot 2\) ключа, хранение подписи входа $\sigma_j$ потребует \( (2(v+1) + 1) \cdot 32  \) байта. Кроме того, образ ключа $\tilde{K}^o_{\pi,j}$ и обязательство по псевдовыходу $C'^a_{\pi,j}$ занимают $(2(v+1)+3) \cdot 32$ байта на вход.

К этому значению добавим место, необходимое для хранения смещённых членов кольца в блокчейне (см. Приложение \ref{appendix:RCTTypeBulletproof2}). Эти офсеты (смещения) используются верификаторами для вычисления ключа и обязательств каждого выхода члена кольца MLSAG-подписи в блокчейне и хранятся как целые числа переменной длины, поэтому мы не можем точно количественно определить необходимое пространство.\footnote{См. работу \cite{varint-description} или \cite{varint-spec} где рассматривается тип данных, называемый varint и используемый Monero\marginnote{src/common/ varint.h}. It is an integer type that uses up to 9 bytes, and stores up to 63 bits of information.}\footnote{Представьте\marginnote{src/crypto- note\_basic/ cryptonote\_ format\_ utils.cpp {\tt absolute\_out- put\_offsets\_ to\_relative()}}, что блокчейн содержит длинный список выходов транзакций. Мы указываем индексы выходов, которые хотим использовать в кольцах. Большие индексы требуют больше места для хранения. Нам требуется «абсолютное» положение {\em одного} индекса из каждого кольца и «относительное» положение индексов других участников кольца. Например, при наличии реальных индексов \{7,11,15,20\} нам необходимо указать \{7,4,4,5\}. Верификаторы могут вычислить последний индекс как (7+4+4+5 = 20). Участники внутри колец расположены в возрастающем порядке по индексам, имеющимся в блокчейне.}\footnote{В случае с транзакцией с 10 входами, использующими кольца, состоящие из 11 участников, потребуется \(((11 \cdot 2 + 3) \cdot 32) \cdot 10 = 8000 \) байт для входов и примерно от 110 до 330 байт для офсетов (при наличии 110 участников колец).}%src/cryptonote_basic/cryptonote_format_utils.cpp absolute_output_offsets_to_relative

Верификация\marginnote{src/ringct/ rctSigs.cpp verRctMG- Simple() verRct- Semantics- Simple()}[-1cm] всех MLSAG-транзакций типа {\tt RCTTypeBulletproof2} предполагает вычисление \( (C_{i, j} - C'^a_{\pi, j}) \) и \( (\sum_j C'^a_{j} \stackrel{?}{=} \sum_t C^b_{t} + f H)\), а также верификацию образов ключей в подгруппе $G$ при помощи $l \tilde{K} \stackrel{?}{=} 0$.

\subsubsection*{Доказательства диапазона (выходы)}

Совокупное\marginnote{src/ringct/ bullet- proofs.cpp {\tt bullet- proof\_ VERIFY()}} доказательство Bulletproof требует $(2 \cdot \lceil \textrm{log}_2(64 \cdot p) \rceil + 9) \cdot 32$ байт места.



\newpage
\section{Краткое описание концепции}
\label{sec:transaction_summary}

Чтобы кратко изложить суть данной главы, мы хотим представить основное содержание транзакции, для простоты понимания организованное в виде концепции. Реальные примеры транзакций приводятся в Приложении \ref{appendix:RCTTypeBulletproof2}.

\begin{itemize}
    \item \underline{Тип}: `0' обозначает {\tt RCTTypeNull} (для майнеров), а `4' обозначает {\tt RCTTypeBulletproof2} %see chapter 7, blockchain, about type 0 transactions
    \item \underline{Входы}: для каждого входа $j \in \{1,...,m\}$, потраченного автором транзакции 
    \begin{itemize}
        \item \textbf{Смещённые члены кольца}: список «офсетов», указывающий, где верификатор может найти членов кольца $j$'s входа $i \in \{1,...,v+1\}$ в блокчейне (включающем реальный вход)
        \item \textbf{Подпись MLSAG}: члены $\sigma_j$: $c_1$, $r_{i,1}$ и $r_{i,2}$ для $i \in \{1,...,v+1\}$
        \item \textbf{Образ ключа}: образ ключа $\tilde{K}^{o,a}_j$ для входа $j$
        \item \textbf{Обязательство по псевдовыходу}: $C'^{a}_j$ для входа $j$
    \end{itemize}
    
    \item \underline{Выходы}: для каждого выхода $t \in \{0,...,p-1\}$, направленного на адрес или подадрес $(K^v_t,K^s_t)$.
    \begin{itemize}
        \item \textbf{Одноразовый (скрытый) адрес}: $K^{o,b}_t$ для выхода $t$
        \item \textbf{Обязательство по выходу}: $C^{b}_t$ для выхода $t$
        \item \textbf{Зашифрованная сумма}: чтобы владельцы выходов могли вычислить $b_t$ для выхода $t$
        \begin{itemize}
            \item \textit{Сумма}: $b_t \oplus_8 \mathcal{H}_n(``amount”, \mathcal{H}_n(r K_B^v, t))$
        \end{itemize}
        \item \textbf{Доказательство диапазона}: совокупное доказательство Bulletproof для всех сумм в выходах $b_t$
        \begin{itemize}
            \item \textit{Доказательство}: $\Pi_{BP} = (A, S, T_1, T_2, \tau_x, \mu, \mathbb{L}, \mathbb{R}, a, b, t)$
        \end{itemize}
    \end{itemize}
    \item \underline{Комиссия за проведение транзакции}: сообщается простым текстом как умноженная на $10^{12}$ (то есть атомные единицы, см. раздел \ref{subsec:block-reward}), поэтому комиссия в размере 1,0 будет записана как 1000000000000.
    \item \underline{Дополнительные данные}: включают в себя публичный ключ транзакции $r G$, или, если по крайней мере один выход будет направлен на подадрес, $r_t K^{s,i}_t$ for each subaddress'd output $t$ and $r_t G$ для каждого выхода $t$, направленного на обычный адрес, и, возможно, ID платежа (один на транзакцию самое большее).\footnote{Информация, содержащаяся в данном поле, не верифицируется, несмотря на то, что {\em она} подписывается MLSAG входов, поэтому, внесение изменений невозможно (за исключением ничтожной вероятности). Поле не ограничено по содержащимся в нём данным, пока соблюдается максимальный размер транзакции. Более подробная информация содержится в работе \cite{extra-field-stackexchange}.}
\end{itemize}

Наш окончательный вариант примера транзакции с одним входом и одним выходом будет выглядеть следующим образом: «В моей транзакции используется публичный ключ $r G$. Я потрачу один их выходов из набора $\mathbb{X}$ (следует отметить, что в нём имеется скрытая сумма $A_X$ обязательство по которой содержится в $C_X$). Я являюсь владельцем выхода, который трачу (я создал MLSAG-подпись по одноразовому адресу, содержащемуся в $\mathbb{X}$), и он не использовался ранее (его образ  ключа $\tilde{K}$ ещё не появлялся в блокчейне). Я дам по нему псевдообязательство $C'_X$. Я создам один выход $Y$, который можно будет потратить по одноразовому адресу $K^o_Y$. В нём будет скрытая сумма $A_Y$, обязательство по которой будет содержаться в $C_Y$, которая будет зашифрована для получателя и которая будет доказана в определённом диапазоне в стиле доказательств диапазона Bulletproofs. Моя транзакция включает комиссию за транзакцию $f$. Следует отметить, что $C'_X - (C_Y + C_f) = 0$ и что я подписал нулевое обязательство $C'_X - C_X = z G$, что означает, что сумма во входе равна сумме в выходе ($A_X = A'_X = A_Y + f$)Все данные транзакции подписаны с использованием моей MLSAG, поэтому внешний наблюдатель может быть уверен, что они не были изменены каким-либо образом».


\newpage
\subsection{Требования к занимаемому месту}

В случае с транзакцией типа {\tt RCTTypeBulletproof2} для сохранения занимаемого места нам требуется $(2(v+1)+2) \cdot m \cdot 32$ байт, а для сохранения совокупного доказательства диапазона Bulletproof требуется $(2 \cdot \lceil \textrm{log}_2(64 \cdot p) \rceil + 9) \cdot 32$ байт.\footnote{Количество содержимого транзакции ограничено так называемым максимальным «весом транзакции».\marginnote{src/crypto- note\_core/ tx\_pool.cpp {\tt get\_trans- action\_weight \_limit()}} До реализации доказательств Bulletproofs в версии v8 протокола (и на самом еле, сейчас транзакции включают в себя всего два выхода) вес и размер транзакции, выраженный в байтах, были одинаковыми. Максимальный вес составляет (0.5*300kB - {\tt CRYPTONOTE\_COINBASE\_BLOB\_RESERVED\_SIZE}), где зарезервированное для блоба место (600 байт) предназначено для включения майнинговых транзакций в блок. До реализации версии v8 множитель 0.5x не использовался, а член 300kB в предшествующих версиях протокола был меньше (20kB в v1, 60kB в v2, 300kB в v5). Мы более подробно рассматриваем эту тему в подпункте \ref{subsec:dynamic-block-weight}.}

Прочие требования:
\begin{itemize}
    \setlength\itemsep{\listspace}
    \item образы ключей входов: $m*32$ байта;
    \item одноразовые адреса выходов: $p*32$ байта;
    \item обязательства по выходам: $p*32$ байта;
    \item зашифрованные суммы в выходах: $p*8$ байт;
    \item публичный ключ транзакции: как правило, 32 байта, $p*32$ байта при отправке, по крайней мере, на один подадрес;
    \item ID платежа: 8 байт для интегрированных адресов (не более одного на транзакцию);
    \item комиссия за проведение транзакции: сохраняется как целое число переменной длины, то есть $\leq 9$ байт;
    \item офсеты входов: сохраняются как целые числа переменной длины, то есть $\leq 9$ байт на офсет для участников кольца $m*(v+1)$;
    \item время снятия блокировки: сохраняется как целое число переменной длины, то есть $\leq 9$ байт;\footnote{Автор любой транзакции может заблокировать её выходы\marginnote{src/crypto- note\_core/ block- chain.cpp {\tt is\_tx\_ spendtime\_ unlocked()}}, и их нельзя будет потратить до достижения определённой высоты блока (или до достижения определённой временной метки UNIX, после которой выходы можно будет добавить в кольцо транзакции, включаемой в блок). Все выходы могут быть заблокированы только до одной и той же высоты блока. Непонятно, имеет ли это какой-то практический смысл для авторов транзакций (возможно, это полезно в случае со смарт-контрактами). В случае с майнинговыми транзакциями выходы в обязательном порядке блокируются на 60 блоков. После реализации версии v12 протокола выходы по умолчанию блокируются на 10 блоков, что эквивалентно обязательному минимальному времени блокировки на 10 блоков. Если транзакция публикуется в 10-м блоке при времени блокировке, равном 25, её выходы можно будет потратить в 25-м блоке или позднее. В случае с обычными транзакциями время блокировки, пожалуй, одна из наиболее редко используемых функций Monero.}
    \item «дополнительные» теги: любые данные в «дополнительном» поле (например, публич\-ный ключ транзакции) начинаются с «тега» размером 1 байт, а в случае с некоторыми данными «длина» может составлять 1+ байт (более подробная информация содержится в Приложении \ref{appendix:RCTTypeBulletproof2}).
\end{itemize}