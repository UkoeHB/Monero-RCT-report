\chapter{Адреса Monero}
\label{chapter:addresses}

Владение цифровой валютой, которая хранится в блокчейне, контролируется посредством так называемых «адресов». На адреса переводятся средства, которые после этого может потратить только владелец такого адреса.\footnote{За исключением ничтожной вероятности.}

Если точнее, по адресу хранятся «выходы» некоторых транзакций, которые подобны «замет\-кам», дающим право владельцу адреса потратить некоторую «сумму» денег. В такой заметке будет сказано: «По адресу C теперь имеется 5,3 XMR».

Чтобы потратить имеющийся выход, владелец адреса берёт его в качестве входа в новой транзакции. В эту новую транзакцию также включаются выходы, имеющиеся по другим адресам (или по адресу отправителя, если он того пожелает). Общая сумма по входам транзакции равна общей сумме по выходам, и после того, как они будут потрачены, владелец уже не сможет сделать этого повторно. Кэрол, являющаяся владельцем адреса C, может включить старый выход в новую транзакцию (например, так: «В этой транзакции мне бы хотелось потратить вот этот выход») и добавить заметку: «По адресу B теперь имеется 5,3 XMR».

Балансом для отдельно взятого адреса является сумма средств, имеющихся по нему в соответ\-ствии с непотраченными выходами.\footnote{Компьютерные приложения, известные как «кошельки», используются для обнаружения и организации выходов, имеющихся по отдельно взятому адресу, а также для хранения приватных ключей, позволяющих проводить новые транзакции, а также передавать эти транзакции в сеть для верификации и последующего включения в блокчейн.}

О том, как от внешнего наблюдателя скрывается сумма транзакции, рассказывается в Главе \ref{chapter:pedersen-commitments}. Структура транзакций рассматривается в Главе \ref{chapter:transactions} (а также то, как доказать, что вы тратите выход, которым владеете и который не был потрачен ранее, даже не раскрывая, какой именно выход тратится). А процесс создания денег и роль наблюдателей обсуждаются в Главе \ref{chapter:blockchain}.



\section{Ключи пользователя}
\label{sec:user-keys}

В отличие от Bitcoin Monero использует два набора приватных/публичных ключей, \((k^v, K^v)\) и \( (k^s, K^s) \), которые генерируются, как описано в Разделе \ref{ec:keys}.

{\em Адрес}\marginnote{src/ common/ base58.cpp {\tt encode\_ addr()}} пользователя представлен парой публичных ключей \((K^v, K^s)\). Приватными ключами будет соответствующая пара \( (k^v, k^s) \).\footnote{При сообщении адреса другим пользователям он, как правило, шифруется при помощи base-58, схемы кодировки из двоичного в текстовый формат, которая изначально была создана для Bitcoin \cite{base-58-encoding}. Более подробная информация содержится в работе \cite{luigi-address}.}
\\

Использование двух наборов ключей делает возможным разделение функций. Обоснован\-ность такого подхода станет очевидной позже в этой главе, а сейчас будем называть приват\-ный ключ $k^v$ {\em ключом просмотра}, а ключ $k^s$ - {\em ключом траты}. Пользователь сможет использо\-вать свой ключ просмотра для того, чтобы определить, принадлежит ли выход ему или какому-либо другому адресу, а ключ траты позволит потратить этот выход в транзакции (и ретроактивно вычислить, что выход был потрачен).\footnote{It\marginnote{src/wallet/ api/wallet.cpp {\tt create()} wallet2.cpp {\tt generate()} {\tt get\_seed()}} В настоящее время, как правило, ключ просмотра $k^v$ равен $\mathcal{H}_n(k^s)$. Это означает, что пользователю просто нужно сохранить свой ключ траты $k^s$, чтобы получить доступ ко всем выходам, которые у него имеются (к их просмотру и трате). Ключ траты обычно представлен последовательностью из 25 слов (где 25-е слово является контрольной суммой). Другими, менее популярными методами являются: генерирование $k^v$ и $k^s$ как отдельных случайных чисел или же генерирование случайной мнемонической фразы $a$, состоящей из 12 слов, где $k^s = {\tt sc\textunderscore reduce32}(\mathit{Keccak}(a))$ и $k^v = {\tt sc\textunderscore reduce32}(\mathit{Keccak}(\mathit{Keccak}(a)))$. \cite{luigi-address}}



\section{Одноразовые адреса}
\label{sec:one-time-addresses}

Чтобы получить деньги, пользователь Monero может поделиться своим адресом с другими пользователями, чтобы они использовали его для отправки средств в выходах транзакции.

Адрес никогда не используется напрямую.\footnote{Метод, описанный здесь, не является обязательным с точки зрения протокола, а зависит от стандартов, которым следовал разработчик при реализации кошелька. Таким образом, альтернативная версия кошелька может быть реализована в стиле Bitcoin, где адреса получателей включаются в данные транзакций напрямую. Подобный «не соответствующий» кошелёк будет производить выходы транзакций, которые не смогут использовать другие кошельки, а каждый Bitcoin-подобный  адрес можно будет использовать только один раз благодаря уникальности образа ключа.} Вместо этого происходит обмен, как в случае с использованием алгоритма Диффи-Хеллмана. В результате создаётся уникальный {\em одноразо\-вый адрес} для каждого выхода транзакции, который должен быть выплачен пользователю. Таким образом, даже те внешние наблюдатели, которым известны все публичные адреса пользователей, не смогут идентифицировать пользователя, получившего какой-либо из выхо\-дов определённой транзакции.\footnote{За исключением ничтожной вероятности.}

%A recipient can spend their received outputs by signing a message with the one-time addresses, thereby proving they know the private keys and therefore own what they are spending. We will gradually flesh out this concept.
%\\

Давайте рассмотрим это на примере очень простой транзакции с одним входом и одним выходом — проведении платежа с «нулевой» суммой от Элис к Бобу.

У Боба есть приватные/публичные ключи $(k_B^v, k_B^s)$ и $(K_B^v, K_B^s)$, и Элис известны его публичные ключи (его адрес). Транзакция могла бы происходить следующим образом \cite{cryptoNoteWhitePaper}:

\begin{enumerate}
	\item Элис генерирует случайное число $r \in_R \mathbb{Z}_l$ и вычисляет одноразовый адрес\footnote{В\marginnote{src/crypto/ crypto.cpp {\tt generate\_ key\_deri- vation()}} случае с Monero каждая копия (даже когда она используется в других частях транзакции) $r k^v G$ умножается на кофактор 8, поэтому в данном случае Элис вычисляет $8*r K^v_B$, а Боб вычисляет $8*k^v_B r G$. Мы можем сказать, что это бессмысленно (но это {\em правило}, которому должны следовать пользователи).  Умножение на кофактор гарантирует, что полученная точка будет принадлежать подгруппе $G$, но если $R$ и $K^v$ не будут принадлежать к одной подгруппе, то дискретные логарифмы $r$ и $k^v$ уже нельзя будет использовать для создания общего секрета.}\vspace{.175cm}
	\[K^o  = \mathcal{H}_n(r K_B^v)G + K_B^s\marginnote{src/crypto/ crypto.cpp {\tt derive\_pu- blic\_key()}}\]

	\item Элис устанавливает $K^o$ в качестве адресата платежа, добавляет сумму по выходу, равную 0, добавляет значение $r G$ к данным транзакции и передаёт их в сеть.

	\item Боб\marginnote{src/crypto/ crypto.cpp {\tt derive\_ subaddress\_ public\_ key()}} получает данные и видит значения $r G$ и $K^o$. Он может вычислить $k_B^v r G = r K_B^v$. Затем он также может вычислить $K'^s_B = K^o - \mathcal{H}_n(r K_B^v)G$. Как только он увидит, что $K'^s_B = K_B^s$, он будет знать, что выход адресован ему.\footnote{$K'^s_B $ вычисляется при помощи {\tt derive\_subaddress\_public\_key()}, поскольку ключи траты для нормального адреса в таблице поиска ключей траты сохраняются с индексом 0, в то время как подадреса имеют индексы 1, 2… Скоро это будет иметь смысл (см. подпункт \ref{sec:subaddresses}.}

	Приватный ключ $k_B^v$ называется ключом просмотра, поскольку любой, у кого он есть (вместе с публичным ключом траты $K_B^s$ Боба), может вычислить $K'^s_B$ для каждого выхода транзакции в сети и «посмотреть», какие из выходов адресованы Бобу.

	\item Одноразовыми ключами для выхода будут:\vspace{.175cm}
	\begin{align*}
		K^o &= \mathcal{H}_n(r K_B^v)G + K_B^s = (\mathcal{H}_n(r K_B^v) + k_B^s)G  \\ 
		k^o &= \mathcal{H}_n(r K_B^v) + k_B^s
	\end{align*}
\end{enumerate}

Чтобы потратить выход с нулевой суммой [sic] в новой транзакции, всё, что необходимо сделать Бобу, это доказать, что он является его владельцем, подписав сообщение одноразовым ключом $K^o$. Приватный ключ $k_B^s$ является «ключом траты», так как он необходим для доказательства владения выходом, в то время как $k_B^v$ является «ключом просмотра», так как он может использоваться для поиска выходов, которые Боб может потратить.

Как станет ясно из Главы \ref{chapter:transactions}, не зная $k^o$, Элис не сможет вычислить образ ключа, поэтому она никогда не узнает наверняка, потратил ли Боб выход, который она отправила ему.\footnote{Представим, что Элис создаёт две транзакции, каждая из которых будет содержать один и тот же выход с одноразового адреса $K^o$, который Боб сможет потратить. Поскольку $K^o$ зависит только от $r$ и $K_B^v$, нет никакой причины, по которой она не смогла бы сделать этого. Боб сможет потратить только один из этих выходов, поскольку у каждого одноразового адреса имеется только один образ ключа. Таким образом, если Бооб не будет осторожным, Элис может обхитрить его. Она может создать транзакцию 1 с большой суммой для Боба, а позже — транзакцию 2 с небольшой суммой для Боба. Если он потратит деньги из транзакции 2, он никогда не сможет потратить деньги из транзакции 1. Фактически никто уже не сможет потратить деньги из транзакции 1. По сути, они «сгорят». Кошельки Monero разработаны так, чтобы игнорировать меньшие суммы в подобной ситуации.}

Боб может передать свой ключ просмотра третьей стороне. Такая третья сторона может являться доверенным хранителем, аудитором, налоговым органом и т. д. Кем-то, кто облада\-ет доступом к истории транзакций пользователя, но кто не обладает какими-либо большими правами. Эта третья сторона также  сможет расшифровать сумму транзакции, как это описа\-но в подпункте \ref{sec:pedersen_monero}). В Главе \ref{chapter:tx-knowledge-proofs} описаны другие способы, при помощи которых Боб мог бы предоставить историю своих транзакций.


\subsection{Транзакции со множеством выходов}
\label{sec:multi_out_transactions}

Большинство транзакций содержит более одного выхода. При отсутствии иного «сдача» пересылается обратно отправителю.\footnote{На самом деле после реализации версии v12, от каждой транзакции  (не майнинговой) {\em требуется} наличие двух выходов, даже если это будет означать, что один из выходов буде на нулевую сумму ({\tt HF\_VERSION\_MIN\_2\_OUTPUTS}). Это повышает уровень неотличимости транзакций друг от друга за счёт смешивания транзакций с одним выходом с более обычными транзакциями с 2 выходами. До версии v12 программное обеспечение кошелька уже позволяло создавать выходы с нулевой суммой. В соответствии с основным вариантом реализации выходы с нулевой суммой отправляются на случайный адрес.\marginnote{src/wallet/ wallet2.cpp {\tt transfer\_ selected\_ rct()}}}\footnote{После реализации Bulletproofs в версии v8 протокола каждая транзакция стала ограничиваться 16 выходами ({\tt BULLETPROOF\_MAX\_OUTPUTS}). Ранее подобное ограничение отсутствовало, а ограничивался только размер транзакции (в байтах).}%BULLETPROOF_MAX_OUTPUTS; wallet2::transfer_selected_rct() for random address 0-amount

Отправители Monero генерируют только одно случайное значение $r$. Точку кривой $r G$ обычно называют {\em публичным ключом транзакции}, и она вместе с другими данными транзакции публи\-куется в блокчейне.\\

Чтобы\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key()}}[-0.5cm] гарантировать, что все одноразовые адреса в транзакции с $p$ выходов являются разны\-ми, даже в случаях, когда один и тот же адрес применяется дважды, Monero использует индексы выходов. Каждый выход транзакции имеет индекс $t \in \{0, ..., p-1\}$. Приложив это значение к совместно используемым секретным данным перед хешированием, можно гарантировать, что полученные одноразовые адреса будут уникальными:\marginnote{src/crypto/ crypto.cpp {\tt derive\_pu- blic\_key()}}[1.2cm]\vspace{.175cm}%construct_tx_with_tx_key() indexes 0 to p-1
\begin{align*}
  K_t^o &= \mathcal{H}_n(r K_t^v, t)G + K_t^s = (\mathcal{H}_n(r K_t^v, t) + k_t^s)G  \\ 
  k_t^o &= \mathcal{H}_n(r K_t^v, t) + k_t^s
\end{align*} 



\section{Подадреса}
\label{sec:subaddresses}

Пользователи Monero могут генерировать подадреса на основе каждого адреса \cite{MRL-0006-subaddresses}. Средства, отправляемые на подадреса, могут быть просмотрены и потрачены при помощи ключей просмотра и траты основного адреса. Аналогичным образом: под одной учётной записью пользователя в онлайн банке может иметься множество счетов, соответствующих кредитным картам и вкладам, и ко всем ним можно получить доступ через одну и ту же точку — учётную запись владельца.\\

Подадреса удобны с точки зрения получения средств в одно и то же место, если пользователь не хочет связывать все свои действия, публикуя/используя один и тот же адрес. Как можно будет увидеть, наблюдателю придётся решить DLP, чтобы определить, был ли выведен кон\-кретный подадрес на основе определённого адреса \cite{MRL-0006-subaddresses}.\footnote{До введения подадресов (были добавлены при обновлении программного обеспечения до версии, соответствующей версии протокола v7 \cite{subaddress-pull-request}) пользователи могли генерировать только множество обычных адресов. Чтобы просмотреть баланс по каждому из адресов приходилось сканировать отдельную запись в блокчейне. Это было очень неэффективно. После ведения подадресов у пользователей появилась поисковая таблица, содержащая (хешированные) ключи траты. Таким образом, одно сканирование блокчейна занимает столько же времени, что и для 1 подадреса или 10 000 подадресов.}

Подадреса также полезны с точки зрения дифференциации полученных выходов. Например, если Элис захочет купить яблоко у Боба во вторник, то Боб может выписать квитанцию об оплате, в которой будет указан покупаемый предмет, а также указать подадрес этой квитанции. Затем Боб попросит Элис использовать этот подадрес, когда она будет отправлять ему деньги. Таким образом, Боб может связать деньги, которые он получает, с яблоком, которое он продал. Ещё один способ, позволяющий отличить полученные выходы, рассматри\-вается в следующем подпункте.%\footnote{Before subaddresses were implemented in April 2018, the Monero developers supported a method called payment IDs, which allowed receivers to differentiate between owned outputs. Payment IDs were text strings included in a transaction's `extra', miscellaneous, data. Recipients could ask senders to include the payment IDs when writing a transaction. Payment IDs could also be encoded in conjunction with so-called integrated addresses. Payment IDs and integrated addresses do not affect transaction verification, so they can still be implemented by anyone, but since they are currently deprecated in the most popular wallets we have chosen not to explain them here.}

%\footnote{Note that the index $i$ could just as easily be some password-generated hash $\mathcal{H}_n(x)$. This would allow an address owner to view his subaddress funds from his main address view key, but only be able to spend those funds by inputting a password. There are currently no wallet implementations password protecting subaddresses, nor any known plans to develop a wallet with that feature.}
Боб\marginnote{src/device/ device\_de- fault.cpp {\tt get\_sub- address\_ secret\_ key()}} генерирует свой $i$ подадрес $(i = 1, 2, ...)$ на основе своего адреса как пару публичных ключей $(K^{v,i}, K^{s,i})$:\footnote{так получается, что хеш подадреса отделён от домена, поэтому на самом деле это $\mathcal{H}_n(T_{sub},k^v,i)$, где $T_{sub} = $``SubAddr". В этом документе мы опускаем $T_{sub}$ для краткости.}\vspace{.175cm}
\begin{align*}
    K^{s,i} &= K^s + \mathcal{H}_n(k^v, i) G\\
    K^{v,i} &= k^v K^{s,i}
\end{align*}
\quad Таким образом,
\begin{alignat*}{2}
    K^{v,i} &= k^v&&(k^s + \mathcal{H}_n(k^v, i))G\\
    K^{s,i} &= &&(k^s + \mathcal{H}_n(k^v, i))G
\end{alignat*}
    

\subsection{Отправка средств на подадрес}
    
Допустим, Элис снова собирается отправить Бобу нулевую сумму, но в этот раз на его подадрес $(K_B^{v,1}, K_B^{s,1})$.
\begin{enumerate}
	\item Элис генерирует случайное число $r \in_R \mathbb{Z}_l$ и вычисляет одноразовый адрес\vspace{.175cm}
	\[ K^o  = \mathcal{H}_n(r K_B^{v,1},0)G + K_B^{s,1} \]

	\item Элис устанавливает $K^o$ в качестве адресата платежа, добавляет сумму по выходу, равную 0, добавляет значение $r K_B^{s,1}$ к данным транзакции и передаёт их в сеть.
	
	\item Боб\marginnote{src/crypto/ crypto.cpp {\tt derive\_ subaddress\_ public\_ key()}} получает данные и видит значения $r K_B^{s,1}$ и $K^o$. Он может вычислить $k_B^v r K_B^{s,1} = r K_B^{v,1}$. Затем он также может вычислить $K'^{s}_B = K^o - \mathcal{H}_n(r K_B^{v,1},0)G$. Как только он увидит, что $K'^{s}_B = K^{s,1}_B$, он будет знать, что транзакция адресована ему.\footnote{Продвинутый злоумышленник  может преуспеть в связывании подадресов \cite{janus-attack} (атака, известная под названием «атака Януса»). При наличии подадресов $K_B^1$ $ и $ $K_B^2$ (один из которых может быть нормальным адресом) злоумышленник может счесть, что они связаны. В этом случае он создаст выход транзакции $K^o = \mathcal{H}_n(r K_B^{v,2},0)G + K_B^{s,1}$ и включит в неё публичный ключ $r K_B^{s,2}$. Боб вычислит $r K_B^{v,2}$, чтобы найти $K'^{s,1}_B$, но он при этом не будет знать, что использовался ключ {\em другого} (под)адреса! Если он сообщит злоумышленнику, что получил средства на $K_B^1$, то злоумышленник будет знать, что $K_B^2$ является связанным подадресом (или нормальным адресом). Поскольку использование подадресов находится вне области применения, как избежать подобной проблемы решают разработчики кошельков. Пока нам неизвестны случаи, когда это было сделано, и единственным вариантом решения проблемы является разработка кошельков, соответствующих требованиям. Потенциальные способы включают в себя сокрытие от злоумышленников информации о получении средств, включение зашифрованного приватного ключа транзакции $r$ в данные транзакции, использование подписи Шнорра с общим секретом, использующим $K^{s,1}$ в качестве базовой точки вместо $G$, а также включение $rG$ в данные транзакции и верификацию общего секрета при помощи $rK^{s,1} \stackrel{?}{=} (k^s + \mathcal{H}_n(k^v, 1))*rG$ (требует приватного ключа траты). Выходы, полученные на нормальный адрес, также должны верифицироваться. См. работу \cite{janus-mitigation-issue-62}, в которой обсуждаются самые последние способы решения данной проблемы.}
	
	Для того чтобы найти выходы транзакции, предназначенные для его подадресов, Бобу нужен только его приватный ключ просмотра $k_B^v$ и публичный ключ траты подадреса $K^{s,1}_B$.
	
	\item Одноразовыми ключами для выхода будут:\vspace{.175cm}
	\begin{align*}
		K^o &= \mathcal{H}_n(r K_B^{v,1},0)G + K_B^{s,1} = (\mathcal{H}_n(r K_B^{v,1},0) + k_B^{s,1})G  \\ 
		k^o &= \mathcal{H}_n(r K_B^{v,1},0) + k_B^{s,1}
	\end{align*}
\end{enumerate}

Теперь\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key()}} публичный ключ транзакции Элис предназначен для Боба ($r K_B^{s,1}$ вместо $r G$). Если Элис создаст транзакцию с $p$ выходов, где по крайней мере один выход будет предназначен для подадреса, ей потребуется создать уникальный публичный ключ транзакции для каждого выхода $t \in \{0,...,p-1\}$. Другими словами, если Элис решит отправить средства на подадрес Боба $(K_B^{v,1}, K_B^{s,1})$ и на адрес Кэрол $(K_C^v, K_C^s)$, ей придётся включить в данные транзакции два публичных ключа транзакции \{$r_1 K_B^{s,1},r_2 G$\}.\footnote{В\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_impl.cpp {\tt get\_account\_ address\_as\_ str()}} случае с Monero подадреса имеют префикс «8», который отделяет их от адресов, которые имеют префикс «4». Это помогает отправителям выбрать правильную процедуру при построении транзакций.}\footnote{При использовании дополнительных публичных ключей транзакции возникает некоторая путаница (см. переход кода {\tt transfer\_selected\_rct()} $\rightarrow$ {\tt construct\_tx\_and\_get\_tx\_key()} $\rightarrow$ {\tt construct\_tx\_with\_tx\_key()} $\rightarrow$ {\tt generate\_output\_ephemeral\_keys()} и {\tt classify\_addresses()}) , связанная с выходами сдачи, если автору транзакции известен ключ просмотра получателя (так как это он сам; ещё один пример фиктивных выходов сдачи, созданных при необходимости в выходах с нулевой суммой, так как авторы генерируют эти адреса). Всякий раз, когда имеется по крайней мере два выхода, не относящихся к сдаче, и по крайней мере один из них принимается на подадрес, всё происходит нормальным образом, как говорилось выше (существующий на данный момент баг в основной реализации добавляет дополнительный публичный ключ транзакции к данным транзакции даже сверх других дополнительных ключей, и он нигде не используется). Если на подадрес направляется либо только выход сдачи, либо имеется только один выход, не относящийся к сдаче, и он направляется на подадрес, создаётся только один публичный ключ транзакции. В первом случае публичным ключом транзакции является $rG$ , а одноразовым ключом сдачи (с индексом подадреса 1, использующим нижний индекс $c$ для обозначения ключей сдачи) является $K^o = \mathcal{H}_n(k^v_c r G,t)G + K_c^{s,1}$, использующий нормальный ключ просмотра и ключ траты подадреса. В последнем случае публичный ключ транзакции $r K^{v,1}$ основан на ключе просмотра подадреса, а одноразовым ключом сдачи является $K^o = \mathcal{H}_n(k^v_c*r K^{v,1},t)G + K_c^s$. . Эти подробности позволяют смешивать часть более часто используемых транзакций с нормальными адресами, транзакции с двумя выходами, которые на момент написания данного документа составляют примерно 95\% от общего объёма транзакций.}



\section{Интегрированные адреса}
\label{sec:integrated-addresses}

Для того чтобы отличить между собой полученные выходы, получатель может попросить у отправителей включить в данные транзакции {\em идентификатор (ID) платежа}.\footnote{В настоящее время Monero поддерживает только один ID платежа на транзакцию, независимо от того, сколько выходов в ней используется.} Например, если Элис захочет купить яблоко у Боба во вторник, то Боб может выписать квитанцию об оплате, в которой будет указан покупаемый предмет, а также попросить Элис включить ID платежа, указанный в квитанции, когда она будет отправлять ему деньги. Таким образом, Боб может связать деньги, которые он получает, с яблоком, которое он продал.

Отправители могут сообщать ID платежа простым текстом, но ручной ввод ID в данные транзакции является неудобным способом, а также представляет собой определённую опас\-ность с точки зрения приватности получателей, которые могут случайно раскрыть свои действия.\footnote{Эти длинные (256 бит) ID платежа в форме простого текста были исключены после выхода версии v0.15 основного программного обеспечения (одновременно с выходом версии v12 протокола в ноябре 2019). Несмотря на то, что некоторые кошельки могут поддерживать их и включать в данные транзакций по сей день, основной кошелёк будет игнорировать такие идентификаторы.} В\marginnote{src/crypto- note\_basic/ cryptonote\_ basic\_ impl.cpp {\tt get\_ account\_ integrated\_ address\_as\_ str()}} случае с Monero получатели могут интегрировать ID платежа в свои адреса и передавать такие {\em интегрированные адреса}, содержащие ($K^v$, $K^s$, ID платежа), отправителям. ID платежа могут быть технически интегрированы в любой вид адреса, включая обычные адреса, подадреса и адреса с мультиподписями.\footnote{Насколько известно автору, интегрированные адреса были реализованы только для нормальных адресов.}

Отправители, которые направляют выходы на интегрированные адреса, могут зашифровать ID платежа, используя общий секрет $r K_t^v$ и операцию XOR (см. подпункт \ref{sec:XOR_section}), чтобы получатель мог потом расшифровать идентификатор при помощи соответствующего публич\-ного ключа транзакции или другой процедуры XOR \cite{integrated-addresses}. Шифрование ID платежа подобным образом позволяет отправителям доказать, что они провели определённую транзакцию (то есть в случае аудита, возмещения средств и других подобных случаях).\footnote{Поскольку наблюдатель может распознать различие между транзакциями с ID платежей и без них, их использование делает историю транзакций менее единообразной. Поэтому, начиная с версии v10 протокола, основной вариант реализации предусматривает добавление фиктивных\marginnote{src/crypto- note\_core/ cryptonote\_ tx\_utils.cpp {\tt construct\_ tx\_with\_ tx\_key\(\)}} зашифрованных ID платежа во все транзакции с двумя выходами. Расшифровка одной вскроет все нулевые (это не является требованием протокола, но представляет собой хороший практический способ).}


\subsubsection*{Шифрование}

Отправитель\marginnote{src/device/ device\_de- fault.cpp {\tt encrypt\_ payment\_ id()}} зашифровывает каждый ID платежа для его включения в данные транзакции\footnote{В случае Monero ID платежа в интегрированных адресах традиционно имеют длину 64 бита.}\vspace{.175cm}
\begin{align*}
         k_{\textrm{mask}} &= \mathcal{H}_n(r K_t^v,\textrm{pid\_tag}) \\
      k_{\textrm{payment ID}} &= k_{\textrm{mask}} \rightarrow \textrm{сокращение до длины ID платежа в битах}\\
  \textrm{зашифрованный ID платежа} &= \textrm{XOR}(k_{\textrm{payment ID}}, \textrm{ID платежа})
\end{align*}

Мы используем pid\_tag, чтобы $k_{\textrm{mask}}$ гарантированно отличался от компонента $\mathcal{H}_n(r K_t^v, t)$ в одноразовых адресах выходов.\footnote{В случае Monero pid\_tag = {\tt ENCRYPTED\_PAYMENT\_ID\_TAIL} = 141. В транзакциях с множеством входов, например,  мы вычисляем $\mathcal{H}_n(r K_t^v, t) \pmod l$, чтобы гарантировано использовать скалярную величину, которая будет меньше порядка подгруппы EC, но так как $l$ составляет 253 бита, а идентификаторы платежей всего 64 бита, использование модуля для шифровки ID платежей не будет иметь смысла, поэтому мы этого и не делаем.}


\subsubsection*{Расшифровка}

Любой\marginnote{src/device/ device.hpp {\tt decrypt\_ payment\_ id()}} получатель, для которого был создан ID платежа, может найти его, используя свой ключ просмотра и публичный ключ транзакции $r G$:\footnote{В данных транзакции не указывается, к какому выходы «принадлежит» ID платежа. Получателям необходимо указывать собственные ID платежей.}\vspace{.175cm}
\begin{align*}
         k_{\textrm{mask}} &= \mathcal{H}_n(k_t^v r G,\textrm{pid\_tag}) \\
      k_{\textrm{payment ID}} &= k_{\textrm{mask}} \rightarrow \textrm{сокращение до длины ID платежа в битах}\\
          \textrm{ID платежа} &= \textrm{XOR}(k_{\textrm{payment ID}}, \textrm{зашифрованный ID платежа})
\end{align*}

Подобным образом отправители могу расшифровывать ID платежа, который они ранее за\-шифровали, путём пересчёта общего секрета.%remove this line?



\section{Адреса, использующие мультиподписи}
\label{sec:multisignature-addresses}

Иногда бывает полезно разделить владение средствами между различными людьми/адресами. Этой теме посвящена Глава \ref{chapter:multisignatures}.